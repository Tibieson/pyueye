/* Generated by Cython 0.12.1 on Mon Sep  6 16:14:56 2010 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#else

#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#if PY_VERSION_HEX < 0x02040000
  #define METH_COEXIST 0
  #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
  #define PyDict_Contains(d,o)   PySequence_Contains(d,o)
#endif

#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PY_FORMAT_SIZE_T ""
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)
  #define PyNumber_Index(o)    PyNumber_Int(o)
  #define PyIndex_Check(o)     PyNumber_Check(o)
  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
#endif

#if PY_VERSION_HEX < 0x02060000
  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
  #define PyVarObject_HEAD_INIT(type, size) \
          PyObject_HEAD_INIT(type) size,
  #define PyType_Modified(t)

  typedef struct {
     void *buf;
     PyObject *obj;
     Py_ssize_t len;
     Py_ssize_t itemsize;
     int readonly;
     int ndim;
     char *format;
     Py_ssize_t *shape;
     Py_ssize_t *strides;
     Py_ssize_t *suboffsets;
     void *internal;
  } Py_buffer;

  #define PyBUF_SIMPLE 0
  #define PyBUF_WRITABLE 0x0001
  #define PyBUF_FORMAT 0x0004
  #define PyBUF_ND 0x0008
  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)

#endif

#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
#endif

#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif

#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif

#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyString_Type                PyUnicode_Type
  #define PyString_CheckExact          PyUnicode_CheckExact
#else
  #define PyBytes_Type                 PyString_Type
  #define PyBytes_CheckExact           PyString_CheckExact
#endif

#if PY_MAJOR_VERSION >= 3
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)

#endif

#if PY_MAJOR_VERSION >= 3
  #define PyMethod_New(func, self, klass) PyInstanceMethod_New(func)
#endif

#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#else
  #define _USE_MATH_DEFINES
#endif

#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
#else
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
#endif

#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_NAMESTR(n) ((char *)(n))
  #define __Pyx_DOCSTR(n)  ((char *)(n))
#else
  #define __Pyx_NAMESTR(n) (n)
  #define __Pyx_DOCSTR(n)  (n)
#endif
#ifdef __cplusplus
#define __PYX_EXTERN_C extern "C"
#else
#define __PYX_EXTERN_C extern
#endif
#include <math.h>
#define __PYX_HAVE_API__ueye__ueye
#include "stdint.h"
#include "uEye.h"
#include "stdlib.h"
#include "stdio.h"
#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"

#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #else
    #define CYTHON_INLINE 
  #endif
#endif

typedef struct {PyObject **p; char *s; const long n; const char* encoding; const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/


/* Type Conversion Predeclarations */

#if PY_MAJOR_VERSION < 3
#define __Pyx_PyBytes_FromString          PyString_FromString
#define __Pyx_PyBytes_FromStringAndSize   PyString_FromStringAndSize
#define __Pyx_PyBytes_AsString            PyString_AsString
#else
#define __Pyx_PyBytes_FromString          PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize   PyBytes_FromStringAndSize
#define __Pyx_PyBytes_AsString            PyBytes_AsString
#endif

#define __Pyx_PyBytes_FromUString(s)      __Pyx_PyBytes_FromString((char*)s)
#define __Pyx_PyBytes_AsUString(s)        ((unsigned char*) __Pyx_PyBytes_AsString(s))

#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);

#if !defined(T_PYSSIZET)
#if PY_VERSION_HEX < 0x02050000
#define T_PYSSIZET T_INT
#elif !defined(T_LONGLONG)
#define T_PYSSIZET \
        ((sizeof(Py_ssize_t) == sizeof(int))  ? T_INT  : \
        ((sizeof(Py_ssize_t) == sizeof(long)) ? T_LONG : -1))
#else
#define T_PYSSIZET \
        ((sizeof(Py_ssize_t) == sizeof(int))          ? T_INT      : \
        ((sizeof(Py_ssize_t) == sizeof(long))         ? T_LONG     : \
        ((sizeof(Py_ssize_t) == sizeof(PY_LONG_LONG)) ? T_LONGLONG : -1)))
#endif
#endif


#if !defined(T_ULONGLONG)
#define __Pyx_T_UNSIGNED_INT(x) \
        ((sizeof(x) == sizeof(unsigned char))  ? T_UBYTE : \
        ((sizeof(x) == sizeof(unsigned short)) ? T_USHORT : \
        ((sizeof(x) == sizeof(unsigned int))   ? T_UINT : \
        ((sizeof(x) == sizeof(unsigned long))  ? T_ULONG : -1))))
#else
#define __Pyx_T_UNSIGNED_INT(x) \
        ((sizeof(x) == sizeof(unsigned char))  ? T_UBYTE : \
        ((sizeof(x) == sizeof(unsigned short)) ? T_USHORT : \
        ((sizeof(x) == sizeof(unsigned int))   ? T_UINT : \
        ((sizeof(x) == sizeof(unsigned long))  ? T_ULONG : \
        ((sizeof(x) == sizeof(unsigned PY_LONG_LONG)) ? T_ULONGLONG : -1)))))
#endif
#if !defined(T_LONGLONG)
#define __Pyx_T_SIGNED_INT(x) \
        ((sizeof(x) == sizeof(char))  ? T_BYTE : \
        ((sizeof(x) == sizeof(short)) ? T_SHORT : \
        ((sizeof(x) == sizeof(int))   ? T_INT : \
        ((sizeof(x) == sizeof(long))  ? T_LONG : -1))))
#else
#define __Pyx_T_SIGNED_INT(x) \
        ((sizeof(x) == sizeof(char))  ? T_BYTE : \
        ((sizeof(x) == sizeof(short)) ? T_SHORT : \
        ((sizeof(x) == sizeof(int))   ? T_INT : \
        ((sizeof(x) == sizeof(long))  ? T_LONG : \
        ((sizeof(x) == sizeof(PY_LONG_LONG))   ? T_LONGLONG : -1)))))
#endif

#define __Pyx_T_FLOATING(x) \
        ((sizeof(x) == sizeof(float)) ? T_FLOAT : \
        ((sizeof(x) == sizeof(double)) ? T_DOUBLE : -1))

#if !defined(T_SIZET)
#if !defined(T_ULONGLONG)
#define T_SIZET \
        ((sizeof(size_t) == sizeof(unsigned int))  ? T_UINT  : \
        ((sizeof(size_t) == sizeof(unsigned long)) ? T_ULONG : -1))
#else
#define T_SIZET \
        ((sizeof(size_t) == sizeof(unsigned int))          ? T_UINT      : \
        ((sizeof(size_t) == sizeof(unsigned long))         ? T_ULONG     : \
        ((sizeof(size_t) == sizeof(unsigned PY_LONG_LONG)) ? T_ULONGLONG : -1)))
#endif
#endif

static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);

#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))


#ifdef __GNUC__
/* Test for GCC > 2.95 */
#if __GNUC__ > 2 ||               (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)) 
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#else /* __GNUC__ > 2 ... */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;
static const char **__pyx_f;


#if !defined(CYTHON_CCOMPLEX)
  #if defined(__cplusplus)
    #define CYTHON_CCOMPLEX 1
  #elif defined(_Complex_I)
    #define CYTHON_CCOMPLEX 1
  #else
    #define CYTHON_CCOMPLEX 0
  #endif
#endif

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    #include <complex>
  #else
    #include <complex.h>
  #endif
#endif

#if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
  #undef _Complex_I
  #define _Complex_I 1.0fj
#endif

typedef npy_int8 __pyx_t_5numpy_int8_t;

typedef npy_int16 __pyx_t_5numpy_int16_t;

typedef npy_int32 __pyx_t_5numpy_int32_t;

typedef npy_int64 __pyx_t_5numpy_int64_t;

typedef npy_uint8 __pyx_t_5numpy_uint8_t;

typedef npy_uint16 __pyx_t_5numpy_uint16_t;

typedef npy_uint32 __pyx_t_5numpy_uint32_t;

typedef npy_uint64 __pyx_t_5numpy_uint64_t;

typedef npy_float32 __pyx_t_5numpy_float32_t;

typedef npy_float64 __pyx_t_5numpy_float64_t;

typedef npy_long __pyx_t_5numpy_int_t;

typedef npy_longlong __pyx_t_5numpy_long_t;

typedef npy_intp __pyx_t_5numpy_intp_t;

typedef npy_uintp __pyx_t_5numpy_uintp_t;

typedef npy_ulong __pyx_t_5numpy_uint_t;

typedef npy_ulonglong __pyx_t_5numpy_ulong_t;

typedef npy_double __pyx_t_5numpy_float_t;

typedef npy_double __pyx_t_5numpy_double_t;

typedef npy_longdouble __pyx_t_5numpy_longdouble_t;

typedef INT __pyx_t_4ueye_4ueye_IDSEXP;

typedef ULONG __pyx_t_4ueye_4ueye_IDSEXPUL;

typedef char __pyx_t_4ueye_4ueye_IS_CHAR;

typedef DWORD __pyx_t_4ueye_4ueye_HIDS;

typedef DWORD __pyx_t_4ueye_4ueye_HCAM;

typedef DWORD __pyx_t_4ueye_4ueye_HFALC;

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex< float > __pyx_t_float_complex;
  #else
    typedef float _Complex __pyx_t_float_complex;
  #endif
#else
    typedef struct { float real, imag; } __pyx_t_float_complex;
#endif

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex< double > __pyx_t_double_complex;
  #else
    typedef double _Complex __pyx_t_double_complex;
  #endif
#else
    typedef struct { double real, imag; } __pyx_t_double_complex;
#endif

/* Type declarations */

typedef npy_cfloat __pyx_t_5numpy_cfloat_t;

typedef npy_cdouble __pyx_t_5numpy_cdouble_t;

typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;

typedef npy_cdouble __pyx_t_5numpy_complex_t;

/* "/home/oscar/pyueye/ueye/ueye.pyx":133
 * npy.import_array()
 * 
 * cdef class Cam:             # <<<<<<<<<<<<<<
 *     '''Class used to control a uEye camera
 * 
 */

struct __pyx_obj_4ueye_4ueye_Cam {
  PyObject_HEAD
  char *Img;
  __pyx_t_4ueye_4ueye_HIDS cid;
  PyObject *SerNo;
  PyObject *ID;
  PyObject *Version;
  PyObject *Date;
  PyObject *Select;
  PyObject *SensorID;
  PyObject *strSensorName;
  PyObject *nColorMode;
  PyObject *nMaxWidth;
  PyObject *nMaxHeight;
  PyObject *bMasterGain;
  PyObject *bRGain;
  PyObject *bGGain;
  PyObject *bBGain;
  PyObject *bGlobShutter;
  PyObject *bitspixel;
  PyObject *colormode;
  INT LineInc;
  int ImgMemId;
};

#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif

#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct * __Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
  end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
  }
  #define __Pyx_RefNannySetupContext(name)           void *__pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
  #define __Pyx_RefNannyFinishContext()           __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r) __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r) __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r) __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XDECREF(r) do { if((r) != NULL) {__Pyx_DECREF(r);} } while(0)
#else
  #define __Pyx_RefNannySetupContext(name)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
#endif /* CYTHON_REFNANNY */
#define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);} } while(0)
#define __Pyx_XGOTREF(r) do { if((r) != NULL) {__Pyx_GOTREF(r);} } while(0)

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name, PyObject* kw_name); /*proto*/

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],     PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,     const char* function_name); /*proto*/

static CYTHON_INLINE long __Pyx_div_long(long, long); /* proto */

static CYTHON_INLINE PyObject* __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
    if (likely(PyList_CheckExact(L))) {
        if (PyList_Append(L, x) < 0) return NULL;
        Py_INCREF(Py_None);
        return Py_None; /* this is just to have an accurate signature */
    }
    else {
        PyObject *r, *m;
        m = __Pyx_GetAttrString(L, "append");
        if (!m) return NULL;
        r = PyObject_CallFunctionObjArgs(m, x, NULL);
        Py_DECREF(m);
        return r;
    }
}


static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}


#define __Pyx_GetItemInt_List(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
                                                    __Pyx_GetItemInt_List_Fast(o, i, size <= sizeof(long)) : \
                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))

static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
    if (likely(o != Py_None)) {
        if (likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
            PyObject *r = PyList_GET_ITEM(o, i);
            Py_INCREF(r);
            return r;
        }
        else if ((-PyList_GET_SIZE(o) <= i) & (i < 0)) {
            PyObject *r = PyList_GET_ITEM(o, PyList_GET_SIZE(o) + i);
            Py_INCREF(r);
            return r;
        }
    }
    return __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
}

#define __Pyx_GetItemInt_Tuple(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
                                                    __Pyx_GetItemInt_Tuple_Fast(o, i, size <= sizeof(long)) : \
                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))

static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
    if (likely(o != Py_None)) {
        if (likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, i);
            Py_INCREF(r);
            return r;
        }
        else if ((-PyTuple_GET_SIZE(o) <= i) & (i < 0)) {
            PyObject *r = PyTuple_GET_ITEM(o, PyTuple_GET_SIZE(o) + i);
            Py_INCREF(r);
            return r;
        }
    }
    return __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
}


#define __Pyx_GetItemInt(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
                                                    __Pyx_GetItemInt_Fast(o, i, size <= sizeof(long)) : \
                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))

static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
    PyObject *r;
    if (PyList_CheckExact(o) && ((0 <= i) & (i < PyList_GET_SIZE(o)))) {
        r = PyList_GET_ITEM(o, i);
        Py_INCREF(r);
    }
    else if (PyTuple_CheckExact(o) && ((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
        r = PyTuple_GET_ITEM(o, i);
        Py_INCREF(r);
    }
    else if (Py_TYPE(o)->tp_as_sequence && Py_TYPE(o)->tp_as_sequence->sq_item && (likely(i >= 0))) {
        r = PySequence_GetItem(o, i);
    }
    else {
        r = __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
    }
    return r;
}

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(void);

static PyObject *__Pyx_UnpackItem(PyObject *, Py_ssize_t index); /*proto*/
static int __Pyx_EndUnpack(PyObject *); /*proto*/

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/

static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);

static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index); /*proto*/

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list); /*proto*/

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_INT(INT);

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb); /*proto*/

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_WORD(WORD);

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_DWORD(DWORD);

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_BOOL(BOOL);

static CYTHON_INLINE npy_intp __Pyx_PyInt_from_py_npy_intp(PyObject *);

static CYTHON_INLINE INT __Pyx_PyInt_from_py_INT(PyObject *);

static CYTHON_INLINE DWORD __Pyx_PyInt_from_py_DWORD(PyObject *);

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_UINT(UINT);

static CYTHON_INLINE WORD __Pyx_PyInt_from_py_WORD(PyObject *);

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_ULONG(ULONG);

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    #define __Pyx_CREAL(z) ((z).real())
    #define __Pyx_CIMAG(z) ((z).imag())
  #else
    #define __Pyx_CREAL(z) (__real__(z))
    #define __Pyx_CIMAG(z) (__imag__(z))
  #endif
#else
    #define __Pyx_CREAL(z) ((z).real)
    #define __Pyx_CIMAG(z) ((z).imag)
#endif

#if defined(_WIN32) && defined(__cplusplus) && CYTHON_CCOMPLEX
    #define __Pyx_SET_CREAL(z,x) ((z).real(x))
    #define __Pyx_SET_CIMAG(z,y) ((z).imag(y))
#else
    #define __Pyx_SET_CREAL(z,x) __Pyx_CREAL(z) = (x)
    #define __Pyx_SET_CIMAG(z,y) __Pyx_CIMAG(z) = (y)
#endif

static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float, float);

#if CYTHON_CCOMPLEX
    #define __Pyx_c_eqf(a, b)   ((a)==(b))
    #define __Pyx_c_sumf(a, b)  ((a)+(b))
    #define __Pyx_c_difff(a, b) ((a)-(b))
    #define __Pyx_c_prodf(a, b) ((a)*(b))
    #define __Pyx_c_quotf(a, b) ((a)/(b))
    #define __Pyx_c_negf(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zerof(z) ((z)==(float)0)
    #define __Pyx_c_conjf(z)    (::std::conj(z))
    /*#define __Pyx_c_absf(z)     (::std::abs(z))*/
  #else
    #define __Pyx_c_is_zerof(z) ((z)==0)
    #define __Pyx_c_conjf(z)    (conjf(z))
    /*#define __Pyx_c_absf(z)     (cabsf(z))*/
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex);
    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex);
    /*static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex);*/
#endif

static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double, double);

#if CYTHON_CCOMPLEX
    #define __Pyx_c_eq(a, b)   ((a)==(b))
    #define __Pyx_c_sum(a, b)  ((a)+(b))
    #define __Pyx_c_diff(a, b) ((a)-(b))
    #define __Pyx_c_prod(a, b) ((a)*(b))
    #define __Pyx_c_quot(a, b) ((a)/(b))
    #define __Pyx_c_neg(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zero(z) ((z)==(double)0)
    #define __Pyx_c_conj(z)    (::std::conj(z))
    /*#define __Pyx_c_abs(z)     (::std::abs(z))*/
  #else
    #define __Pyx_c_is_zero(z) ((z)==0)
    #define __Pyx_c_conj(z)    (conj(z))
    /*#define __Pyx_c_abs(z)     (cabs(z))*/
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eq(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_diff(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_prod(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_neg(__pyx_t_double_complex);
    static CYTHON_INLINE int __Pyx_c_is_zero(__pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj(__pyx_t_double_complex);
    /*static CYTHON_INLINE double __Pyx_c_abs(__pyx_t_double_complex);*/
#endif

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);

static CYTHON_INLINE UINT __Pyx_PyInt_from_py_UINT(PyObject *);

static CYTHON_INLINE BOOL __Pyx_PyInt_from_py_BOOL(PyObject *);

static CYTHON_INLINE ULONG __Pyx_PyInt_from_py_ULONG(PyObject *);

static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, long size, int strict);  /*proto*/

static PyObject *__Pyx_ImportModule(const char *name); /*proto*/

static void __Pyx_AddTraceback(const char *funcname); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
/* Module declarations from stdlib */

/* Module declarations from python_ref */

/* Module declarations from python_cobject */

/* Module declarations from python_buffer */

/* Module declarations from stdio */

/* Module declarations from numpy */

/* Module declarations from numpy */

static PyTypeObject *__pyx_ptype_5numpy_dtype = 0;
static PyTypeObject *__pyx_ptype_5numpy_flatiter = 0;
static PyTypeObject *__pyx_ptype_5numpy_broadcast = 0;
static PyTypeObject *__pyx_ptype_5numpy_ndarray = 0;
static PyTypeObject *__pyx_ptype_5numpy_ufunc = 0;
static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *); /*proto*/
static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *, PyObject *); /*proto*/
static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *, PyObject *, PyObject *); /*proto*/
static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *, PyObject *, PyObject *, PyObject *); /*proto*/
static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *, PyObject *, PyObject *, PyObject *, PyObject *); /*proto*/
static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *, char *, char *, int *); /*proto*/
static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *, PyObject *); /*proto*/
static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *); /*proto*/
/* Module declarations from ueye.ueye */

static PyTypeObject *__pyx_ptype_4ueye_4ueye_Cam = 0;
#define __Pyx_MODULE_NAME "ueye.ueye"
int __pyx_module_is_main_ueye__ueye = 0;

/* Implementation of ueye.ueye */
static PyObject *__pyx_builtin_Exception;
static PyObject *__pyx_builtin_enumerate;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_RuntimeError;
static char __pyx_k_1[] = "The camera's starter firmware is not compatible with the driver and needs to be updated.";
static char __pyx_k_2[] = "Colormode not supported";
static char __pyx_k_3[] = "ColorFormat not suported";
static char __pyx_k_4[] = "Could not set timeout";
static char __pyx_k_5[] = "Table lenght must be even";
static char __pyx_k_6[] = "Invalid nMode Parameter";
static char __pyx_k_7[] = "WhiteBalanceMultipliers";
static char __pyx_k_8[] = "the tuple WhiteBalanceMultipliers must contain 3 double numbers";
static char __pyx_k_9[] = "Error getting error message";
static char __pyx_k_10[] = "ndarray is not C contiguous";
static char __pyx_k_11[] = "ndarray is not Fortran contiguous";
static char __pyx_k_12[] = "Non-native byte order not supported";
static char __pyx_k_13[] = "unknown dtype code in numpy.pxd (%d)";
static char __pyx_k_14[] = "Format string allocated too short, see comment in numpy.pxd";
static char __pyx_k_15[] = "Format string allocated too short.";
static char __pyx_k__B[] = "B";
static char __pyx_k__H[] = "H";
static char __pyx_k__I[] = "I";
static char __pyx_k__L[] = "L";
static char __pyx_k__O[] = "O";
static char __pyx_k__Q[] = "Q";
static char __pyx_k__b[] = "b";
static char __pyx_k__d[] = "d";
static char __pyx_k__f[] = "f";
static char __pyx_k__g[] = "g";
static char __pyx_k__h[] = "h";
static char __pyx_k__i[] = "i";
static char __pyx_k__l[] = "l";
static char __pyx_k__q[] = "q";
static char __pyx_k__x[] = "x";
static char __pyx_k__y[] = "y";
static char __pyx_k__ID[] = "ID";
static char __pyx_k__Zd[] = "Zd";
static char __pyx_k__Zf[] = "Zf";
static char __pyx_k__Zg[] = "Zg";
static char __pyx_k__Img[] = "Img";
static char __pyx_k__buf[] = "buf";
static char __pyx_k__cid[] = "cid";
static char __pyx_k__npy[] = "npy";
static char __pyx_k__obj[] = "obj";
static char __pyx_k__Date[] = "Date";
static char __pyx_k__base[] = "base";
static char __pyx_k__nRed[] = "nRed";
static char __pyx_k__ndim[] = "ndim";
static char __pyx_k__type[] = "type";
static char __pyx_k__Gamma[] = "Gamma";
static char __pyx_k__Param[] = "Param";
static char __pyx_k__SerNo[] = "SerNo";
static char __pyx_k__descr[] = "descr";
static char __pyx_k__nBlue[] = "nBlue";
static char __pyx_k__nInfo[] = "nInfo";
static char __pyx_k__nMode[] = "nMode";
static char __pyx_k__names[] = "names";
static char __pyx_k__numpy[] = "numpy";
static char __pyx_k__pXPos[] = "pXPos";
static char __pyx_k__pYPos[] = "pYPos";
static char __pyx_k__param[] = "param";
static char __pyx_k__pval1[] = "pval1";
static char __pyx_k__pval2[] = "pval2";
static char __pyx_k__range[] = "range";
static char __pyx_k__shape[] = "shape";
static char __pyx_k__ChromU[] = "ChromU";
static char __pyx_k__ChromV[] = "ChromV";
static char __pyx_k__Select[] = "Select";
static char __pyx_k__bBGain[] = "bBGain";
static char __pyx_k__bGGain[] = "bGGain";
static char __pyx_k__bRGain[] = "bRGain";
static char __pyx_k__effect[] = "effect";
static char __pyx_k__fields[] = "fields";
static char __pyx_k__format[] = "format";
static char __pyx_k__nGreen[] = "nGreen";
static char __pyx_k__offset[] = "offset";
static char __pyx_k__pWidth[] = "pWidth";
static char __pyx_k__LineInc[] = "LineInc";
static char __pyx_k__Timeout[] = "Timeout";
static char __pyx_k__Version[] = "Version";
static char __pyx_k__nEnable[] = "nEnable";
static char __pyx_k__nFactor[] = "nFactor";
static char __pyx_k__nMaster[] = "nMaster";
static char __pyx_k__pHeight[] = "pHeight";
static char __pyx_k__pixList[] = "pixList";
static char __pyx_k__strides[] = "strides";
static char __pyx_k__ulValue[] = "ulValue";
static char __pyx_k__ImgMemId[] = "ImgMemId";
static char __pyx_k__SensorID[] = "SensorID";
static char __pyx_k____main__[] = "__main__";
static char __pyx_k__itemsize[] = "itemsize";
static char __pyx_k__readonly[] = "readonly";
static char __pyx_k__type_num[] = "type_num";
static char __pyx_k__ColorMode[] = "ColorMode";
static char __pyx_k__Exception[] = "Exception";
static char __pyx_k__TestImage[] = "TestImage";
static char __pyx_k__bitspixel[] = "bitspixel";
static char __pyx_k__byteorder[] = "byteorder";
static char __pyx_k__colormode[] = "colormode";
static char __pyx_k__enumerate[] = "enumerate";
static char __pyx_k__nMaxWidth[] = "nMaxWidth";
static char __pyx_k__threshold[] = "threshold";
static char __pyx_k__ValueError[] = "ValueError";
static char __pyx_k__nColorMode[] = "nColorMode";
static char __pyx_k__nMaxHeight[] = "nMaxHeight";
static char __pyx_k__suboffsets[] = "suboffsets";
static char __pyx_k__ConvertMode[] = "ConvertMode";
static char __pyx_k__bMasterGain[] = "bMasterGain";
static char __pyx_k__RuntimeError[] = "RuntimeError";
static char __pyx_k__SetColorMode[] = "SetColorMode";
static char __pyx_k__bGlobShutter[] = "bGlobShutter";
static char __pyx_k__strSensorName[] = "strSensorName";
static char __pyx_k__CheckNoSuccess[] = "CheckNoSuccess";
static char __pyx_k__ColorCorrection[] = "ColorCorrection";
static char __pyx_k__SetBlCompensation[] = "SetBlCompensation";
static char __pyx_k__BayerConversionMode[] = "BayerConversionMode";
static PyObject *__pyx_kp_s_1;
static PyObject *__pyx_kp_u_10;
static PyObject *__pyx_kp_u_11;
static PyObject *__pyx_kp_u_12;
static PyObject *__pyx_kp_u_13;
static PyObject *__pyx_kp_u_14;
static PyObject *__pyx_kp_u_15;
static PyObject *__pyx_kp_s_2;
static PyObject *__pyx_kp_s_3;
static PyObject *__pyx_kp_s_4;
static PyObject *__pyx_kp_s_5;
static PyObject *__pyx_kp_s_6;
static PyObject *__pyx_n_s_7;
static PyObject *__pyx_kp_s_8;
static PyObject *__pyx_kp_s_9;
static PyObject *__pyx_n_s__BayerConversionMode;
static PyObject *__pyx_n_s__CheckNoSuccess;
static PyObject *__pyx_n_s__ChromU;
static PyObject *__pyx_n_s__ChromV;
static PyObject *__pyx_n_s__ColorCorrection;
static PyObject *__pyx_n_s__ColorMode;
static PyObject *__pyx_n_s__ConvertMode;
static PyObject *__pyx_n_s__Date;
static PyObject *__pyx_n_s__Exception;
static PyObject *__pyx_n_s__Gamma;
static PyObject *__pyx_n_s__ID;
static PyObject *__pyx_n_s__Img;
static PyObject *__pyx_n_s__ImgMemId;
static PyObject *__pyx_n_s__LineInc;
static PyObject *__pyx_n_s__Param;
static PyObject *__pyx_n_s__RuntimeError;
static PyObject *__pyx_n_s__Select;
static PyObject *__pyx_n_s__SensorID;
static PyObject *__pyx_n_s__SerNo;
static PyObject *__pyx_n_s__SetBlCompensation;
static PyObject *__pyx_n_s__SetColorMode;
static PyObject *__pyx_n_s__TestImage;
static PyObject *__pyx_n_s__Timeout;
static PyObject *__pyx_n_s__ValueError;
static PyObject *__pyx_n_s__Version;
static PyObject *__pyx_n_s____main__;
static PyObject *__pyx_n_s__bBGain;
static PyObject *__pyx_n_s__bGGain;
static PyObject *__pyx_n_s__bGlobShutter;
static PyObject *__pyx_n_s__bMasterGain;
static PyObject *__pyx_n_s__bRGain;
static PyObject *__pyx_n_s__base;
static PyObject *__pyx_n_s__bitspixel;
static PyObject *__pyx_n_s__buf;
static PyObject *__pyx_n_s__byteorder;
static PyObject *__pyx_n_s__cid;
static PyObject *__pyx_n_s__colormode;
static PyObject *__pyx_n_s__descr;
static PyObject *__pyx_n_s__effect;
static PyObject *__pyx_n_s__enumerate;
static PyObject *__pyx_n_s__fields;
static PyObject *__pyx_n_s__format;
static PyObject *__pyx_n_s__itemsize;
static PyObject *__pyx_n_s__nBlue;
static PyObject *__pyx_n_s__nColorMode;
static PyObject *__pyx_n_s__nEnable;
static PyObject *__pyx_n_s__nFactor;
static PyObject *__pyx_n_s__nGreen;
static PyObject *__pyx_n_s__nInfo;
static PyObject *__pyx_n_s__nMaster;
static PyObject *__pyx_n_s__nMaxHeight;
static PyObject *__pyx_n_s__nMaxWidth;
static PyObject *__pyx_n_s__nMode;
static PyObject *__pyx_n_s__nRed;
static PyObject *__pyx_n_s__names;
static PyObject *__pyx_n_s__ndim;
static PyObject *__pyx_n_s__npy;
static PyObject *__pyx_n_s__numpy;
static PyObject *__pyx_n_s__obj;
static PyObject *__pyx_n_s__offset;
static PyObject *__pyx_n_s__pHeight;
static PyObject *__pyx_n_s__pWidth;
static PyObject *__pyx_n_s__pXPos;
static PyObject *__pyx_n_s__pYPos;
static PyObject *__pyx_n_s__param;
static PyObject *__pyx_n_s__pixList;
static PyObject *__pyx_n_s__pval1;
static PyObject *__pyx_n_s__pval2;
static PyObject *__pyx_n_s__range;
static PyObject *__pyx_n_s__readonly;
static PyObject *__pyx_n_s__shape;
static PyObject *__pyx_n_s__strSensorName;
static PyObject *__pyx_n_s__strides;
static PyObject *__pyx_n_s__suboffsets;
static PyObject *__pyx_n_s__threshold;
static PyObject *__pyx_n_s__type;
static PyObject *__pyx_n_s__type_num;
static PyObject *__pyx_n_s__ulValue;
static PyObject *__pyx_n_s__x;
static PyObject *__pyx_n_s__y;
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_2;
static PyObject *__pyx_int_8;
static PyObject *__pyx_int_neg_1;
static PyObject *__pyx_int_15;
static PyObject *__pyx_int_16;
static PyObject *__pyx_int_24;
static PyObject *__pyx_int_32;

/* "/home/oscar/pyueye/ueye/ueye.pyx":38
 * cimport numpy as npy
 * 
 * def GetNumberOfCameras():             # <<<<<<<<<<<<<<
 *     '''Returns the number of connected cams
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_GetNumberOfCameras(PyObject *__pyx_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_GetNumberOfCameras[] = "Returns the number of connected cams\n    \n    Syntax:\n    =======\n        \n    ncam=GetNumberOfCameras()\n    \n    Return Value:\n    =============\n    \n    ncam: \n        Number of connected cams\n    ";
static PyObject *__pyx_pf_4ueye_4ueye_GetNumberOfCameras(PyObject *__pyx_self, PyObject *unused) {
  INT __pyx_v_ncam;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("GetNumberOfCameras");
  __pyx_self = __pyx_self;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":53
 *     '''
 *     cdef INT ncam
 *     is_GetNumberOfCameras(&ncam)             # <<<<<<<<<<<<<<
 *     return ncam
 * 
 */
  is_GetNumberOfCameras((&__pyx_v_ncam));

  /* "/home/oscar/pyueye/ueye/ueye.pyx":54
 *     cdef INT ncam
 *     is_GetNumberOfCameras(&ncam)
 *     return ncam             # <<<<<<<<<<<<<<
 * 
 * #~ def GetCameraList(): #NotWorking
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(__pyx_v_ncam); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("ueye.ueye.GetNumberOfCameras");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":71
 *     #~ return None
 * 
 * def GetDLLVersion():             # <<<<<<<<<<<<<<
 *     ''' Returns the ueye_api.so/dll mayor,minor,version numbers
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_GetDLLVersion(PyObject *__pyx_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_GetDLLVersion[] = " Returns the ueye_api.so/dll mayor,minor,version numbers\n    \n    Syntax:\n    =======\n    \n    mayor,minor,build=GetDLLVersion()\n    \n    Return Value:\n    =============\n    \n    mayor:\n        mayor version number\n    minor:\n        minor version number\n    build:\n        build version number\n    ";
static PyObject *__pyx_pf_4ueye_4ueye_GetDLLVersion(PyObject *__pyx_self, PyObject *unused) {
  INT __pyx_v_ver;
  PyObject *__pyx_v_build;
  PyObject *__pyx_v_minor;
  PyObject *__pyx_v_mayor;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("GetDLLVersion");
  __pyx_self = __pyx_self;
  __pyx_v_build = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_minor = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_mayor = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":90
 *     '''
 *     cdef INT ver
 *     ver=is_GetDLLVersion()             # <<<<<<<<<<<<<<
 *     build=ver&0xFFFF
 *     minor=(ver>>16) & 0xFF
 */
  __pyx_v_ver = is_GetDLLVersion();

  /* "/home/oscar/pyueye/ueye/ueye.pyx":91
 *     cdef INT ver
 *     ver=is_GetDLLVersion()
 *     build=ver&0xFFFF             # <<<<<<<<<<<<<<
 *     minor=(ver>>16) & 0xFF
 *     mayor=(ver>>24) & 0xFF
 */
  __pyx_t_1 = PyInt_FromLong((__pyx_v_ver & 0xFFFF)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 91; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_build);
  __pyx_v_build = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":92
 *     ver=is_GetDLLVersion()
 *     build=ver&0xFFFF
 *     minor=(ver>>16) & 0xFF             # <<<<<<<<<<<<<<
 *     mayor=(ver>>24) & 0xFF
 *     return mayor,minor,build
 */
  __pyx_t_1 = PyInt_FromLong(((__pyx_v_ver >> 16) & 0xFF)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_minor);
  __pyx_v_minor = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":93
 *     build=ver&0xFFFF
 *     minor=(ver>>16) & 0xFF
 *     mayor=(ver>>24) & 0xFF             # <<<<<<<<<<<<<<
 *     return mayor,minor,build
 * 
 */
  __pyx_t_1 = PyInt_FromLong(((__pyx_v_ver >> 24) & 0xFF)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 93; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_mayor);
  __pyx_v_mayor = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":94
 *     minor=(ver>>16) & 0xFF
 *     mayor=(ver>>24) & 0xFF
 *     return mayor,minor,build             # <<<<<<<<<<<<<<
 * 
 * def bitspixel(colormode):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_mayor);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_mayor);
  __Pyx_GIVEREF(__pyx_v_mayor);
  __Pyx_INCREF(__pyx_v_minor);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_minor);
  __Pyx_GIVEREF(__pyx_v_minor);
  __Pyx_INCREF(__pyx_v_build);
  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_build);
  __Pyx_GIVEREF(__pyx_v_build);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("ueye.ueye.GetDLLVersion");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_build);
  __Pyx_DECREF(__pyx_v_minor);
  __Pyx_DECREF(__pyx_v_mayor);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":96
 *     return mayor,minor,build
 * 
 * def bitspixel(colormode):             # <<<<<<<<<<<<<<
 *     '''Returns the bits per pixel corresponding a given colormode
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_bitspixel(PyObject *__pyx_self, PyObject *__pyx_v_colormode); /*proto*/
static char __pyx_doc_4ueye_4ueye_bitspixel[] = "Returns the bits per pixel corresponding a given colormode\n    \n    Syntax:\n    =======\n    \n    bpp=bitspixel(colormode)\n    \n    Input Parameters:\n    =================\n    \n    colormode:\n        Colormode to check, all the CM_... constants are defined\n    \n    Return Value:\n    =============\n    \n    bpp:\n        Bits per pixel corresponding to the given colormode\n    ";
static PyObject *__pyx_pf_4ueye_4ueye_bitspixel(PyObject *__pyx_self, PyObject *__pyx_v_colormode) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_t_10;
  int __pyx_t_11;
  __Pyx_RefNannySetupContext("bitspixel");
  __pyx_self = __pyx_self;
  __Pyx_INCREF(__pyx_v_colormode);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":116
 *         Bits per pixel corresponding to the given colormode
 *     '''
 *     if colormode==IS_CM_MONO8 or colormode==IS_CM_BAYER_RG8:             # <<<<<<<<<<<<<<
 *         return 8
 *     elif colormode==IS_CM_MONO12        or colormode==IS_CM_MONO16        \
 */
  __pyx_t_1 = PyInt_FromLong(IS_CM_MONO8); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (!__pyx_t_3) {
    __pyx_t_2 = PyInt_FromLong(IS_CM_BAYER_RG8); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = __pyx_t_4;
  } else {
    __pyx_t_5 = __pyx_t_3;
  }
  if (__pyx_t_5) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":117
 *     '''
 *     if colormode==IS_CM_MONO8 or colormode==IS_CM_BAYER_RG8:
 *         return 8             # <<<<<<<<<<<<<<
 *     elif colormode==IS_CM_MONO12        or colormode==IS_CM_MONO16        \
 *       or colormode==IS_CM_BAYER_RG12    or colormode==IS_CM_BAYER_RG16    \
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_8);
    __pyx_r = __pyx_int_8;
    goto __pyx_L0;
    goto __pyx_L5;
  }

  /* "/home/oscar/pyueye/ueye/ueye.pyx":118
 *     if colormode==IS_CM_MONO8 or colormode==IS_CM_BAYER_RG8:
 *         return 8
 *     elif colormode==IS_CM_MONO12        or colormode==IS_CM_MONO16        \             # <<<<<<<<<<<<<<
 *       or colormode==IS_CM_BAYER_RG12    or colormode==IS_CM_BAYER_RG16    \
 *       or colormode==IS_CM_BGR555_PACKED or colormode==IS_CM_BGR565_PACKED \
 */
  __pyx_t_1 = PyInt_FromLong(IS_CM_MONO12); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (!__pyx_t_5) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":119
 *         return 8
 *     elif colormode==IS_CM_MONO12        or colormode==IS_CM_MONO16        \
 *       or colormode==IS_CM_BAYER_RG12    or colormode==IS_CM_BAYER_RG16    \             # <<<<<<<<<<<<<<
 *       or colormode==IS_CM_BGR555_PACKED or colormode==IS_CM_BGR565_PACKED \
 *       or colormode==IS_CM_UYVY_PACKED   or colormode==IS_CM_CBYCRY_PACKED:
 */
    __pyx_t_2 = PyInt_FromLong(IS_CM_MONO16); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (!__pyx_t_3) {
      __pyx_t_1 = PyInt_FromLong(IS_CM_BAYER_RG12); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (!__pyx_t_4) {

        /* "/home/oscar/pyueye/ueye/ueye.pyx":120
 *     elif colormode==IS_CM_MONO12        or colormode==IS_CM_MONO16        \
 *       or colormode==IS_CM_BAYER_RG12    or colormode==IS_CM_BAYER_RG16    \
 *       or colormode==IS_CM_BGR555_PACKED or colormode==IS_CM_BGR565_PACKED \             # <<<<<<<<<<<<<<
 *       or colormode==IS_CM_UYVY_PACKED   or colormode==IS_CM_CBYCRY_PACKED:
 *         return 16
 */
        __pyx_t_2 = PyInt_FromLong(IS_CM_BAYER_RG16); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (!__pyx_t_6) {
          __pyx_t_1 = PyInt_FromLong(IS_CM_BGR555_PACKED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          if (!__pyx_t_7) {

            /* "/home/oscar/pyueye/ueye/ueye.pyx":121
 *       or colormode==IS_CM_BAYER_RG12    or colormode==IS_CM_BAYER_RG16    \
 *       or colormode==IS_CM_BGR555_PACKED or colormode==IS_CM_BGR565_PACKED \
 *       or colormode==IS_CM_UYVY_PACKED   or colormode==IS_CM_CBYCRY_PACKED:             # <<<<<<<<<<<<<<
 *         return 16
 *     elif colormode==IS_CM_RGB8_PACKED or colormode==IS_CM_BGR8_PACKED:
 */
            __pyx_t_2 = PyInt_FromLong(IS_CM_BGR565_PACKED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            __Pyx_GOTREF(__pyx_t_2);
            __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            __Pyx_GOTREF(__pyx_t_1);
            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
            __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
            if (!__pyx_t_8) {
              __pyx_t_1 = PyInt_FromLong(IS_CM_UYVY_PACKED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
              __Pyx_GOTREF(__pyx_t_1);
              __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
              __Pyx_GOTREF(__pyx_t_2);
              __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
              __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_9 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
              __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
              if (!__pyx_t_9) {
                __pyx_t_2 = PyInt_FromLong(IS_CM_CBYCRY_PACKED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
                __Pyx_GOTREF(__pyx_t_2);
                __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
                __Pyx_GOTREF(__pyx_t_1);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_10 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
                __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
                __pyx_t_11 = __pyx_t_10;
              } else {
                __pyx_t_11 = __pyx_t_9;
              }
              __pyx_t_9 = __pyx_t_11;
            } else {
              __pyx_t_9 = __pyx_t_8;
            }
            __pyx_t_8 = __pyx_t_9;
          } else {
            __pyx_t_8 = __pyx_t_7;
          }
          __pyx_t_7 = __pyx_t_8;
        } else {
          __pyx_t_7 = __pyx_t_6;
        }
        __pyx_t_6 = __pyx_t_7;
      } else {
        __pyx_t_6 = __pyx_t_4;
      }
      __pyx_t_4 = __pyx_t_6;
    } else {
      __pyx_t_4 = __pyx_t_3;
    }
    __pyx_t_3 = __pyx_t_4;
  } else {
    __pyx_t_3 = __pyx_t_5;
  }
  if (__pyx_t_3) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":122
 *       or colormode==IS_CM_BGR555_PACKED or colormode==IS_CM_BGR565_PACKED \
 *       or colormode==IS_CM_UYVY_PACKED   or colormode==IS_CM_CBYCRY_PACKED:
 *         return 16             # <<<<<<<<<<<<<<
 *     elif colormode==IS_CM_RGB8_PACKED or colormode==IS_CM_BGR8_PACKED:
 *         return 24
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_16);
    __pyx_r = __pyx_int_16;
    goto __pyx_L0;
    goto __pyx_L5;
  }

  /* "/home/oscar/pyueye/ueye/ueye.pyx":123
 *       or colormode==IS_CM_UYVY_PACKED   or colormode==IS_CM_CBYCRY_PACKED:
 *         return 16
 *     elif colormode==IS_CM_RGB8_PACKED or colormode==IS_CM_BGR8_PACKED:             # <<<<<<<<<<<<<<
 *         return 24
 *     elif colormode==IS_CM_RGBA8_PACKED or colormode==IS_CM_BGRA8_PACKED   \
 */
  __pyx_t_1 = PyInt_FromLong(IS_CM_RGB8_PACKED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (!__pyx_t_3) {
    __pyx_t_2 = PyInt_FromLong(IS_CM_BGR8_PACKED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_4 = __pyx_t_5;
  } else {
    __pyx_t_4 = __pyx_t_3;
  }
  if (__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":124
 *         return 16
 *     elif colormode==IS_CM_RGB8_PACKED or colormode==IS_CM_BGR8_PACKED:
 *         return 24             # <<<<<<<<<<<<<<
 *     elif colormode==IS_CM_RGBA8_PACKED or colormode==IS_CM_BGRA8_PACKED   \
 *       or colormode==IS_CM_RGBY8_PACKED or colormode==IS_CM_BGRY8_PACKED   \
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_24);
    __pyx_r = __pyx_int_24;
    goto __pyx_L0;
    goto __pyx_L5;
  }

  /* "/home/oscar/pyueye/ueye/ueye.pyx":125
 *     elif colormode==IS_CM_RGB8_PACKED or colormode==IS_CM_BGR8_PACKED:
 *         return 24
 *     elif colormode==IS_CM_RGBA8_PACKED or colormode==IS_CM_BGRA8_PACKED   \             # <<<<<<<<<<<<<<
 *       or colormode==IS_CM_RGBY8_PACKED or colormode==IS_CM_BGRY8_PACKED   \
 *       or colormode==IS_CM_RGB10V2_PACKED or colormode==IS_CM_BGR10V2_PACKED:
 */
  __pyx_t_1 = PyInt_FromLong(IS_CM_RGBA8_PACKED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (!__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":126
 *         return 24
 *     elif colormode==IS_CM_RGBA8_PACKED or colormode==IS_CM_BGRA8_PACKED   \
 *       or colormode==IS_CM_RGBY8_PACKED or colormode==IS_CM_BGRY8_PACKED   \             # <<<<<<<<<<<<<<
 *       or colormode==IS_CM_RGB10V2_PACKED or colormode==IS_CM_BGR10V2_PACKED:
 *         return 32;
 */
    __pyx_t_2 = PyInt_FromLong(IS_CM_BGRA8_PACKED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (!__pyx_t_3) {
      __pyx_t_1 = PyInt_FromLong(IS_CM_RGBY8_PACKED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (!__pyx_t_5) {

        /* "/home/oscar/pyueye/ueye/ueye.pyx":127
 *     elif colormode==IS_CM_RGBA8_PACKED or colormode==IS_CM_BGRA8_PACKED   \
 *       or colormode==IS_CM_RGBY8_PACKED or colormode==IS_CM_BGRY8_PACKED   \
 *       or colormode==IS_CM_RGB10V2_PACKED or colormode==IS_CM_BGR10V2_PACKED:             # <<<<<<<<<<<<<<
 *         return 32;
 *     else: return 8
 */
        __pyx_t_2 = PyInt_FromLong(IS_CM_BGRY8_PACKED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (!__pyx_t_6) {
          __pyx_t_1 = PyInt_FromLong(IS_CM_RGB10V2_PACKED); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_2 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          if (!__pyx_t_7) {
            __pyx_t_2 = PyInt_FromLong(IS_CM_BGR10V2_PACKED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            __Pyx_GOTREF(__pyx_t_2);
            __pyx_t_1 = PyObject_RichCompare(__pyx_v_colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            __Pyx_GOTREF(__pyx_t_1);
            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
            __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
            __pyx_t_9 = __pyx_t_8;
          } else {
            __pyx_t_9 = __pyx_t_7;
          }
          __pyx_t_7 = __pyx_t_9;
        } else {
          __pyx_t_7 = __pyx_t_6;
        }
        __pyx_t_6 = __pyx_t_7;
      } else {
        __pyx_t_6 = __pyx_t_5;
      }
      __pyx_t_5 = __pyx_t_6;
    } else {
      __pyx_t_5 = __pyx_t_3;
    }
    __pyx_t_3 = __pyx_t_5;
  } else {
    __pyx_t_3 = __pyx_t_4;
  }
  if (__pyx_t_3) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":128
 *       or colormode==IS_CM_RGBY8_PACKED or colormode==IS_CM_BGRY8_PACKED   \
 *       or colormode==IS_CM_RGB10V2_PACKED or colormode==IS_CM_BGR10V2_PACKED:
 *         return 32;             # <<<<<<<<<<<<<<
 *     else: return 8
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_32);
    __pyx_r = __pyx_int_32;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  /*else*/ {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":129
 *       or colormode==IS_CM_RGB10V2_PACKED or colormode==IS_CM_BGR10V2_PACKED:
 *         return 32;
 *     else: return 8             # <<<<<<<<<<<<<<
 * 
 * npy.import_array()
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_int_8);
    __pyx_r = __pyx_int_8;
    goto __pyx_L0;
  }
  __pyx_L5:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("ueye.ueye.bitspixel");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_colormode);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":161
 *     cdef public int ImgMemId
 * 
 *     def __init__(self,HIDS cid=0):             # <<<<<<<<<<<<<<
 *         #cdef HWND hWnd
 *         rv=is_InitCamera(&cid, NULL)
 */

static int __pyx_pf_4ueye_4ueye_3Cam___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pf_4ueye_4ueye_3Cam___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  __pyx_t_4ueye_4ueye_HIDS __pyx_v_cid;
  PyObject *__pyx_v_rv;
  CAMINFO __pyx_v_cInfo;
  SENSORINFO __pyx_v_sInfo;
  PyObject *__pyx_v_colormode;
  int __pyx_r;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__cid,0};
  __Pyx_RefNannySetupContext("__init__");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[1] = {0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      if (kw_args > 1) {
        PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__cid);
        if (unlikely(value)) { values[0] = value; kw_args--; }
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    if (values[0]) {
      __pyx_v_cid = __Pyx_PyInt_from_py_DWORD(values[0]); if (unlikely((__pyx_v_cid == (DWORD)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_cid = ((__pyx_t_4ueye_4ueye_HIDS)0);
    }
  } else {
    __pyx_v_cid = ((__pyx_t_4ueye_4ueye_HIDS)0);
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  1: __pyx_v_cid = __Pyx_PyInt_from_py_DWORD(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_cid == (DWORD)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.__init__");
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __Pyx_INCREF((PyObject *)__pyx_v_self);
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_colormode = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":163
 *     def __init__(self,HIDS cid=0):
 *         #cdef HWND hWnd
 *         rv=is_InitCamera(&cid, NULL)             # <<<<<<<<<<<<<<
 *         #IS_SUCCESS
 *         self.CheckNoSuccess(rv)
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_InitCamera((&__pyx_v_cid), NULL)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":165
 *         rv=is_InitCamera(&cid, NULL)
 *         #IS_SUCCESS
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         if rv==IS_STARTER_FW_UPLOAD_NEEDED:
 *             raise Exception("The camera's starter firmware is not compatible with the driver and needs to be updated.")
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":166
 *         #IS_SUCCESS
 *         self.CheckNoSuccess(rv)
 *         if rv==IS_STARTER_FW_UPLOAD_NEEDED:             # <<<<<<<<<<<<<<
 *             raise Exception("The camera's starter firmware is not compatible with the driver and needs to be updated.")
 *         self.cid=cid
 */
  __pyx_t_3 = PyInt_FromLong(IS_STARTER_FW_UPLOAD_NEEDED); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_rv, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":167
 *         self.CheckNoSuccess(rv)
 *         if rv==IS_STARTER_FW_UPLOAD_NEEDED:
 *             raise Exception("The camera's starter firmware is not compatible with the driver and needs to be updated.")             # <<<<<<<<<<<<<<
 *         self.cid=cid
 * 
 */
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(((PyObject *)__pyx_kp_s_1));
    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_kp_s_1));
    __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_1));
    __pyx_t_3 = PyObject_Call(__pyx_builtin_Exception, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":168
 *         if rv==IS_STARTER_FW_UPLOAD_NEEDED:
 *             raise Exception("The camera's starter firmware is not compatible with the driver and needs to be updated.")
 *         self.cid=cid             # <<<<<<<<<<<<<<
 * 
 *         cdef CAMINFO cInfo
 */
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid = __pyx_v_cid;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":171
 * 
 *         cdef CAMINFO cInfo
 *         rv =is_GetCameraInfo(self.cid, &cInfo)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_INT(is_GetCameraInfo(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&__pyx_v_cInfo))); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":172
 *         cdef CAMINFO cInfo
 *         rv =is_GetCameraInfo(self.cid, &cInfo)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         self.SerNo=cInfo.SerNo
 */
  __pyx_t_3 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_1 = PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":174
 *         self.CheckNoSuccess(rv)
 * 
 *         self.SerNo=cInfo.SerNo             # <<<<<<<<<<<<<<
 *         self.ID=cInfo.ID
 *         self.Version=cInfo.Version
 */
  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_cInfo.SerNo); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_GIVEREF(((PyObject *)__pyx_t_1));
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->SerNo);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->SerNo);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->SerNo = ((PyObject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":175
 * 
 *         self.SerNo=cInfo.SerNo
 *         self.ID=cInfo.ID             # <<<<<<<<<<<<<<
 *         self.Version=cInfo.Version
 *         self.Date=cInfo.Date
 */
  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_cInfo.ID); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_GIVEREF(((PyObject *)__pyx_t_1));
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->ID);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->ID);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->ID = ((PyObject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":176
 *         self.SerNo=cInfo.SerNo
 *         self.ID=cInfo.ID
 *         self.Version=cInfo.Version             # <<<<<<<<<<<<<<
 *         self.Date=cInfo.Date
 *         self.Select=cInfo.Select
 */
  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_cInfo.Version); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_GIVEREF(((PyObject *)__pyx_t_1));
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Version);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Version);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Version = ((PyObject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":177
 *         self.ID=cInfo.ID
 *         self.Version=cInfo.Version
 *         self.Date=cInfo.Date             # <<<<<<<<<<<<<<
 *         self.Select=cInfo.Select
 *         #pInfo.Type,pInfo.Reserved
 */
  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_cInfo.Date); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_GIVEREF(((PyObject *)__pyx_t_1));
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Date);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Date);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Date = ((PyObject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":178
 *         self.Version=cInfo.Version
 *         self.Date=cInfo.Date
 *         self.Select=cInfo.Select             # <<<<<<<<<<<<<<
 *         #pInfo.Type,pInfo.Reserved
 * 
 */
  __pyx_t_1 = PyInt_FromLong(__pyx_v_cInfo.Select); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Select);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Select);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Select = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":182
 * 
 *         cdef SENSORINFO sInfo
 *         rv=is_GetSensorInfo(self.cid, &sInfo)             # <<<<<<<<<<<<<<
 * 
 *         self.CheckNoSuccess(rv)
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetSensorInfo(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&__pyx_v_sInfo))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":184
 *         rv=is_GetSensorInfo(self.cid, &sInfo)
 * 
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         self.SensorID=sInfo.SensorID            # e.g. IS_SENSOR_UI224X_C
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":186
 *         self.CheckNoSuccess(rv)
 * 
 *         self.SensorID=sInfo.SensorID            # e.g. IS_SENSOR_UI224X_C             # <<<<<<<<<<<<<<
 *         self.strSensorName=<char*>sInfo.strSensorName  # e.g. "UI-224X-C"
 *         self.nColorMode=sInfo.nColorMode        # e.g. IS_COLORMODE_BAYER
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_WORD(__pyx_v_sInfo.SensorID); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->SensorID);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->SensorID);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->SensorID = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":187
 * 
 *         self.SensorID=sInfo.SensorID            # e.g. IS_SENSOR_UI224X_C
 *         self.strSensorName=<char*>sInfo.strSensorName  # e.g. "UI-224X-C"             # <<<<<<<<<<<<<<
 *         self.nColorMode=sInfo.nColorMode        # e.g. IS_COLORMODE_BAYER
 *         self.nMaxWidth=sInfo.nMaxWidth          # e.g. 1280
 */
  __pyx_t_3 = __Pyx_PyBytes_FromString(((char *)__pyx_v_sInfo.strSensorName)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
  __Pyx_GIVEREF(((PyObject *)__pyx_t_3));
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->strSensorName);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->strSensorName);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->strSensorName = ((PyObject *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":188
 *         self.SensorID=sInfo.SensorID            # e.g. IS_SENSOR_UI224X_C
 *         self.strSensorName=<char*>sInfo.strSensorName  # e.g. "UI-224X-C"
 *         self.nColorMode=sInfo.nColorMode        # e.g. IS_COLORMODE_BAYER             # <<<<<<<<<<<<<<
 *         self.nMaxWidth=sInfo.nMaxWidth          # e.g. 1280
 *         self.nMaxHeight=sInfo.nMaxHeight        # e.g. 1024
 */
  __pyx_t_3 = PyInt_FromLong(__pyx_v_sInfo.nColorMode); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 188; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nColorMode);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nColorMode);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nColorMode = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":189
 *         self.strSensorName=<char*>sInfo.strSensorName  # e.g. "UI-224X-C"
 *         self.nColorMode=sInfo.nColorMode        # e.g. IS_COLORMODE_BAYER
 *         self.nMaxWidth=sInfo.nMaxWidth          # e.g. 1280             # <<<<<<<<<<<<<<
 *         self.nMaxHeight=sInfo.nMaxHeight        # e.g. 1024
 *         self.bMasterGain=sInfo.bMasterGain      # e.g. TRUE
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_DWORD(__pyx_v_sInfo.nMaxWidth); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxWidth);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxWidth);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxWidth = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":190
 *         self.nColorMode=sInfo.nColorMode        # e.g. IS_COLORMODE_BAYER
 *         self.nMaxWidth=sInfo.nMaxWidth          # e.g. 1280
 *         self.nMaxHeight=sInfo.nMaxHeight        # e.g. 1024             # <<<<<<<<<<<<<<
 *         self.bMasterGain=sInfo.bMasterGain      # e.g. TRUE
 *         self.bRGain=sInfo.bRGain                # e.g. TRUE
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_DWORD(__pyx_v_sInfo.nMaxHeight); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxHeight);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxHeight);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxHeight = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":191
 *         self.nMaxWidth=sInfo.nMaxWidth          # e.g. 1280
 *         self.nMaxHeight=sInfo.nMaxHeight        # e.g. 1024
 *         self.bMasterGain=sInfo.bMasterGain      # e.g. TRUE             # <<<<<<<<<<<<<<
 *         self.bRGain=sInfo.bRGain                # e.g. TRUE
 *         self.bGGain=sInfo.bGGain                # e.g. TRUE
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_BOOL(__pyx_v_sInfo.bMasterGain); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bMasterGain);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bMasterGain);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bMasterGain = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":192
 *         self.nMaxHeight=sInfo.nMaxHeight        # e.g. 1024
 *         self.bMasterGain=sInfo.bMasterGain      # e.g. TRUE
 *         self.bRGain=sInfo.bRGain                # e.g. TRUE             # <<<<<<<<<<<<<<
 *         self.bGGain=sInfo.bGGain                # e.g. TRUE
 *         self.bBGain=sInfo.bBGain                # e.g. TRUE
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_BOOL(__pyx_v_sInfo.bRGain); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bRGain);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bRGain);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bRGain = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":193
 *         self.bMasterGain=sInfo.bMasterGain      # e.g. TRUE
 *         self.bRGain=sInfo.bRGain                # e.g. TRUE
 *         self.bGGain=sInfo.bGGain                # e.g. TRUE             # <<<<<<<<<<<<<<
 *         self.bBGain=sInfo.bBGain                # e.g. TRUE
 *         self.bGlobShutter=sInfo.bGlobShutter    # e.g. TRUE
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_BOOL(__pyx_v_sInfo.bGGain); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bGGain);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bGGain);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bGGain = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":194
 *         self.bRGain=sInfo.bRGain                # e.g. TRUE
 *         self.bGGain=sInfo.bGGain                # e.g. TRUE
 *         self.bBGain=sInfo.bBGain                # e.g. TRUE             # <<<<<<<<<<<<<<
 *         self.bGlobShutter=sInfo.bGlobShutter    # e.g. TRUE
 * 
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_BOOL(__pyx_v_sInfo.bBGain); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bBGain);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bBGain);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bBGain = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":195
 *         self.bGGain=sInfo.bGGain                # e.g. TRUE
 *         self.bBGain=sInfo.bBGain                # e.g. TRUE
 *         self.bGlobShutter=sInfo.bGlobShutter    # e.g. TRUE             # <<<<<<<<<<<<<<
 * 
 *         cdef int pid
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_BOOL(__pyx_v_sInfo.bGlobShutter); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 195; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bGlobShutter);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bGlobShutter);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bGlobShutter = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":200
 * 
 *         # Check if the cam is color or bw
 *         if self.nColorMode == IS_COLORMODE_BAYER:             # <<<<<<<<<<<<<<
 *             colormode= IS_CM_BGR8_PACKED
 *         elif self.nColorMode == IS_COLORMODE_MONOCHROME:
 */
  __pyx_t_3 = PyInt_FromLong(IS_COLORMODE_BAYER); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_RichCompare(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nColorMode, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":201
 *         # Check if the cam is color or bw
 *         if self.nColorMode == IS_COLORMODE_BAYER:
 *             colormode= IS_CM_BGR8_PACKED             # <<<<<<<<<<<<<<
 *         elif self.nColorMode == IS_COLORMODE_MONOCHROME:
 *             colormode= IS_CM_MONO8
 */
    __pyx_t_2 = PyInt_FromLong(IS_CM_BGR8_PACKED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_v_colormode);
    __pyx_v_colormode = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L7;
  }

  /* "/home/oscar/pyueye/ueye/ueye.pyx":202
 *         if self.nColorMode == IS_COLORMODE_BAYER:
 *             colormode= IS_CM_BGR8_PACKED
 *         elif self.nColorMode == IS_COLORMODE_MONOCHROME:             # <<<<<<<<<<<<<<
 *             colormode= IS_CM_MONO8
 *         else:
 */
  __pyx_t_2 = PyInt_FromLong(IS_COLORMODE_MONOCHROME); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_RichCompare(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nColorMode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":203
 *             colormode= IS_CM_BGR8_PACKED
 *         elif self.nColorMode == IS_COLORMODE_MONOCHROME:
 *             colormode= IS_CM_MONO8             # <<<<<<<<<<<<<<
 *         else:
 *             raise Exception("Colormode not supported")
 */
    __pyx_t_3 = PyInt_FromLong(IS_CM_MONO8); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_v_colormode);
    __pyx_v_colormode = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L7;
  }
  /*else*/ {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":205
 *             colormode= IS_CM_MONO8
 *         else:
 *             raise Exception("Colormode not supported")             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(((PyObject *)__pyx_kp_s_2));
    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_kp_s_2));
    __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_2));
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7:;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":210
 *         #Set colormode and assign image memory. The image memory assigment is done
 *         #in SetColorMode
 *         self.Img=<char *>NULL             # <<<<<<<<<<<<<<
 *         self.SetColorMode (colormode)
 * 
 */
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Img = ((char *)NULL);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":211
 *         #in SetColorMode
 *         self.Img=<char *>NULL
 *         self.SetColorMode (colormode)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__SetColorMode); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_colormode);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_colormode);
  __Pyx_GIVEREF(__pyx_v_colormode);
  __pyx_t_1 = PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":215
 * 
 * 
 *         rv=is_SetExternalTrigger (self.cid, IS_SET_TRIGGER_OFF)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetExternalTrigger(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, IS_SET_TRIGGER_OFF)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":216
 * 
 *         rv=is_SetExternalTrigger (self.cid, IS_SET_TRIGGER_OFF)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         rv=is_FreezeVideo (self.cid, IS_WAIT)
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_2 = PyObject_Call(__pyx_t_1, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":218
 *         self.CheckNoSuccess(rv)
 * 
 *         rv=is_FreezeVideo (self.cid, IS_WAIT)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_to_py_INT(is_FreezeVideo(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, IS_WAIT)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":219
 * 
 *         rv=is_FreezeVideo (self.cid, IS_WAIT)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         #Start with auto BL_Compensation off by default if possible
 */
  __pyx_t_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_1 = PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":223
 *         #Start with auto BL_Compensation off by default if possible
 * 
 *         rv=self.SetBlCompensation(IS_GET_BL_SUPPORTED_MODE, 0)             # <<<<<<<<<<<<<<
 * 
 *         if rv & IS_BL_COMPENSATION_OFFSET:
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__SetBlCompensation); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyInt_FromLong(IS_GET_BL_SUPPORTED_MODE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_int_0);
  __Pyx_GIVEREF(__pyx_int_0);
  __pyx_t_3 = 0;
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":225
 *         rv=self.SetBlCompensation(IS_GET_BL_SUPPORTED_MODE, 0)
 * 
 *         if rv & IS_BL_COMPENSATION_OFFSET:             # <<<<<<<<<<<<<<
 *             self.SetBlCompensation(IS_BL_COMPENSATION_DISABLE, 0)
 * 
 */
  __pyx_t_3 = PyInt_FromLong(IS_BL_COMPENSATION_OFFSET); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyNumber_And(__pyx_v_rv, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":226
 * 
 *         if rv & IS_BL_COMPENSATION_OFFSET:
 *             self.SetBlCompensation(IS_BL_COMPENSATION_DISABLE, 0)             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
    __pyx_t_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__SetBlCompensation); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyInt_FromLong(IS_BL_COMPENSATION_DISABLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_int_0);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_0);
    __Pyx_GIVEREF(__pyx_int_0);
    __pyx_t_3 = 0;
    __pyx_t_3 = PyObject_Call(__pyx_t_2, __pyx_t_1, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L8;
  }
  __pyx_L8:;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.__init__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_DECREF(__pyx_v_colormode);
  __Pyx_DECREF((PyObject *)__pyx_v_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":228
 *             self.SetBlCompensation(IS_BL_COMPENSATION_DISABLE, 0)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 * 
 *         rv=is_FreeImageMem (self.cid,self.Img, self.ImgMemId)
 */

static void __pyx_pf_4ueye_4ueye_3Cam___dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pf_4ueye_4ueye_3Cam___dealloc__(PyObject *__pyx_v_self) {
  PyObject *__pyx_v_rv;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__dealloc__");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":230
 *     def __dealloc__(self):
 * 
 *         rv=is_FreeImageMem (self.cid,self.Img, self.ImgMemId)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_FreeImageMem(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Img, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->ImgMemId)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":231
 * 
 *         rv=is_FreeImageMem (self.cid,self.Img, self.ImgMemId)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         rv=is_ExitCamera (self.cid)
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":233
 *         self.CheckNoSuccess(rv)
 * 
 *         rv=is_ExitCamera (self.cid)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_INT(is_ExitCamera(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":234
 * 
 *         rv=is_ExitCamera (self.cid)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_3 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_1 = PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.__dealloc__");
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_RefNannyFinishContext();
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":237
 * 
 * 
 *     def GrabImage(self):             # <<<<<<<<<<<<<<
 *         '''Grabs and reads an image from the camera and returns a numpy array
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GrabImage(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GrabImage[] = "Grabs and reads an image from the camera and returns a numpy array\n        \n        \n        Syntax:\n        =======\n    \n        im=cam.GrabImage()\n        \n        Return Value:\n        =============\n    \n        im:\n            Numpy array containing the image data. The data from the driver buffer\n            to the numpy array. The returned numpy array is modified each time \n            the method is called. \n            \n        Note: The default colormode for color cameras is BGR, so the imshow in numpy\n        is not showing the correct colors\n\n\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GrabImage(PyObject *__pyx_v_self, PyObject *unused) {
  npy_intp __pyx_v_dims3[3];
  PyObject *__pyx_v_rv;
  PyObject *__pyx_v_data;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  npy_intp __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("GrabImage");
  __Pyx_INCREF((PyObject *)__pyx_v_self);
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_data = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":262
 * 
 * 
 *         rv= is_FreezeVideo (self.cid, IS_WAIT)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_FreezeVideo(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, IS_WAIT)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":263
 * 
 *         rv= is_FreezeVideo (self.cid, IS_WAIT)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         if self.colormode==IS_CM_RGB8_PACKED or self.colormode==IS_CM_BGR8_PACKED:
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":265
 *         self.CheckNoSuccess(rv)
 * 
 *         if self.colormode==IS_CM_RGB8_PACKED or self.colormode==IS_CM_BGR8_PACKED:             # <<<<<<<<<<<<<<
 *             dims3[0]=self.nMaxHeight
 *             dims3[1]=self.LineInc/3
 */
  __pyx_t_3 = PyInt_FromLong(IS_CM_RGB8_PACKED); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_RichCompare(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (!__pyx_t_4) {
    __pyx_t_2 = PyInt_FromLong(IS_CM_BGR8_PACKED); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyObject_RichCompare(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_6 = __pyx_t_5;
  } else {
    __pyx_t_6 = __pyx_t_4;
  }
  if (__pyx_t_6) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":266
 * 
 *         if self.colormode==IS_CM_RGB8_PACKED or self.colormode==IS_CM_BGR8_PACKED:
 *             dims3[0]=self.nMaxHeight             # <<<<<<<<<<<<<<
 *             dims3[1]=self.LineInc/3
 *             dims3[2]=3
 */
    __pyx_t_7 = __Pyx_PyInt_from_py_npy_intp(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxHeight); if (unlikely((__pyx_t_7 == (npy_intp)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    (__pyx_v_dims3[0]) = __pyx_t_7;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":267
 *         if self.colormode==IS_CM_RGB8_PACKED or self.colormode==IS_CM_BGR8_PACKED:
 *             dims3[0]=self.nMaxHeight
 *             dims3[1]=self.LineInc/3             # <<<<<<<<<<<<<<
 *             dims3[2]=3
 *             npy.Py_INCREF( npy.NPY_UINT8 )
 */
    (__pyx_v_dims3[1]) = __Pyx_div_long(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->LineInc, 3);

    /* "/home/oscar/pyueye/ueye/ueye.pyx":268
 *             dims3[0]=self.nMaxHeight
 *             dims3[1]=self.LineInc/3
 *             dims3[2]=3             # <<<<<<<<<<<<<<
 *             npy.Py_INCREF( npy.NPY_UINT8 )
 *             data = npy.PyArray_SimpleNewFromData(3, dims3, npy.NPY_UINT8, self.Img)
 */
    (__pyx_v_dims3[2]) = 3;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":269
 *             dims3[1]=self.LineInc/3
 *             dims3[2]=3
 *             npy.Py_INCREF( npy.NPY_UINT8 )             # <<<<<<<<<<<<<<
 *             data = npy.PyArray_SimpleNewFromData(3, dims3, npy.NPY_UINT8, self.Img)
 *             if self.colormode==IS_CM_BGR8_PACKED:
 */
    __pyx_t_3 = PyInt_FromLong(NPY_UINT8); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    Py_INCREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":270
 *             dims3[2]=3
 *             npy.Py_INCREF( npy.NPY_UINT8 )
 *             data = npy.PyArray_SimpleNewFromData(3, dims3, npy.NPY_UINT8, self.Img)             # <<<<<<<<<<<<<<
 *             if self.colormode==IS_CM_BGR8_PACKED:
 *                 data=data[:,:,::-1]
 */
    __pyx_t_3 = PyArray_SimpleNewFromData(3, __pyx_v_dims3, NPY_UINT8, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Img); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_v_data);
    __pyx_v_data = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":271
 *             npy.Py_INCREF( npy.NPY_UINT8 )
 *             data = npy.PyArray_SimpleNewFromData(3, dims3, npy.NPY_UINT8, self.Img)
 *             if self.colormode==IS_CM_BGR8_PACKED:             # <<<<<<<<<<<<<<
 *                 data=data[:,:,::-1]
 * 
 */
    __pyx_t_3 = PyInt_FromLong(IS_CM_BGR8_PACKED); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = PyObject_RichCompare(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (__pyx_t_6) {

      /* "/home/oscar/pyueye/ueye/ueye.pyx":272
 *             data = npy.PyArray_SimpleNewFromData(3, dims3, npy.NPY_UINT8, self.Img)
 *             if self.colormode==IS_CM_BGR8_PACKED:
 *                 data=data[:,:,::-1]             # <<<<<<<<<<<<<<
 * 
 *         elif self.colormode==IS_CM_MONO8:
 */
      __pyx_t_2 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_1 = PySlice_New(Py_None, Py_None, __pyx_int_neg_1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      __pyx_t_2 = 0;
      __pyx_t_3 = 0;
      __pyx_t_1 = 0;
      __pyx_t_1 = PyObject_GetItem(__pyx_v_data, __pyx_t_8); if (!__pyx_t_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_v_data);
      __pyx_v_data = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L6;
    }
    __pyx_L6:;
    goto __pyx_L5;
  }

  /* "/home/oscar/pyueye/ueye/ueye.pyx":274
 *                 data=data[:,:,::-1]
 * 
 *         elif self.colormode==IS_CM_MONO8:             # <<<<<<<<<<<<<<
 *             dims3[0]=self.nMaxHeight
 *             dims3[1]=self.LineInc
 */
  __pyx_t_1 = PyInt_FromLong(IS_CM_MONO8); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_8 = PyObject_RichCompare(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode, __pyx_t_1, Py_EQ); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (__pyx_t_6) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":275
 * 
 *         elif self.colormode==IS_CM_MONO8:
 *             dims3[0]=self.nMaxHeight             # <<<<<<<<<<<<<<
 *             dims3[1]=self.LineInc
 *             npy.Py_INCREF( npy.NPY_UINT8 )
 */
    __pyx_t_7 = __Pyx_PyInt_from_py_npy_intp(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxHeight); if (unlikely((__pyx_t_7 == (npy_intp)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    (__pyx_v_dims3[0]) = __pyx_t_7;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":276
 *         elif self.colormode==IS_CM_MONO8:
 *             dims3[0]=self.nMaxHeight
 *             dims3[1]=self.LineInc             # <<<<<<<<<<<<<<
 *             npy.Py_INCREF( npy.NPY_UINT8 )
 *             data = npy.PyArray_SimpleNewFromData(2, dims3, npy.NPY_UINT8, self.Img)
 */
    (__pyx_v_dims3[1]) = ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->LineInc;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":277
 *             dims3[0]=self.nMaxHeight
 *             dims3[1]=self.LineInc
 *             npy.Py_INCREF( npy.NPY_UINT8 )             # <<<<<<<<<<<<<<
 *             data = npy.PyArray_SimpleNewFromData(2, dims3, npy.NPY_UINT8, self.Img)
 * 
 */
    __pyx_t_8 = PyInt_FromLong(NPY_UINT8); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    Py_INCREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":278
 *             dims3[1]=self.LineInc
 *             npy.Py_INCREF( npy.NPY_UINT8 )
 *             data = npy.PyArray_SimpleNewFromData(2, dims3, npy.NPY_UINT8, self.Img)             # <<<<<<<<<<<<<<
 * 
 *         else:
 */
    __pyx_t_8 = PyArray_SimpleNewFromData(2, __pyx_v_dims3, NPY_UINT8, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Img); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_v_data);
    __pyx_v_data = __pyx_t_8;
    __pyx_t_8 = 0;
    goto __pyx_L5;
  }
  /*else*/ {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":281
 * 
 *         else:
 *             raise Exception("ColorFormat not suported")             # <<<<<<<<<<<<<<
 *         return data
 * 
 */
    __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_INCREF(((PyObject *)__pyx_kp_s_3));
    PyTuple_SET_ITEM(__pyx_t_8, 0, ((PyObject *)__pyx_kp_s_3));
    __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_3));
    __pyx_t_1 = PyObject_Call(__pyx_builtin_Exception, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5:;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":282
 *         else:
 *             raise Exception("ColorFormat not suported")
 *         return data             # <<<<<<<<<<<<<<
 * 
 *     def GetExposureRange(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_data);
  __pyx_r = __pyx_v_data;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("ueye.ueye.Cam.GrabImage");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_DECREF(__pyx_v_data);
  __Pyx_DECREF((PyObject *)__pyx_v_self);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":284
 *         return data
 * 
 *     def GetExposureRange(self):             # <<<<<<<<<<<<<<
 *         '''Returns the exposure range parameters
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetExposureRange(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetExposureRange[] = "Returns the exposure range parameters\n        \n        Using GetExposureRange(), you can query the exposure values \n        (in milliseconds) available for the currently selected timing \n        (pixel clock, frame rate). The available time values are \n        comprised between min and max and can be set in increments \n        defined by the intervall parameter.\n\n        Syntax:\n        =======\n        \n        min,max,interval=cam.GetExposureRange()\n        \n        \n        Return Value:\n        =============\n        \n        min: \n            Minimum available exposure time\n        max:\n            Maximum available exposure time\n        interval:\n            Allowed increment\n                \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetExposureRange(PyObject *__pyx_v_self, PyObject *unused) {
  double __pyx_v_min;
  double __pyx_v_max;
  double __pyx_v_interval;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("GetExposureRange");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":312
 * 
 *         cdef double min,max,interval
 *         rv= is_GetExposureRange (self.cid, &min, &max, &interval)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetExposureRange(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&__pyx_v_min), (&__pyx_v_max), (&__pyx_v_interval))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":313
 *         cdef double min,max,interval
 *         rv= is_GetExposureRange (self.cid, &min, &max, &interval)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         return (min,max,interval)
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":315
 *         self.CheckNoSuccess(rv)
 * 
 *         return (min,max,interval)             # <<<<<<<<<<<<<<
 * 
 *     def SetExposureTime(self,double expo):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_min); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_max); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_interval); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_3 = 0;
  __pyx_t_2 = 0;
  __pyx_t_1 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("ueye.ueye.Cam.GetExposureRange");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":317
 *         return (min,max,interval)
 * 
 *     def SetExposureTime(self,double expo):             # <<<<<<<<<<<<<<
 *         '''Set the exposure time
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetExposureTime(PyObject *__pyx_v_self, PyObject *__pyx_arg_expo); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetExposureTime[] = "Set the exposure time\n        \n        Using SetExposureTime(), you can set the exposure time \n        (in milliseconds). Since this value depends on the sensor timing, \n        the exposure time actually used may slightly deviate from the \n        value set here. The actual exposure time is returned by the method. \n        In free-running mode (CaptureVideo()),  any modification of the exposure\n        time will only become effective when the next image but one is captured. \n        In trigger mode (SetExternalTrigger()), the modification  will be \n        applied to the next image.\n\n        Syntax:\n        =======\n        \n        nexpo=cam.SetExposureTime(expo)\n        \n        Input Parameters:\n        =================\n        \n        expo: \n            New desired exposure time.\n\n            For expo=0.0, the exposure time is 1/frame rate.\n\n            GET_EXPOSURE_TIME: Returns the current exposure.\n\n            GET_DEFAULT_EXPOSURE: Returns the default exposure time.\n\n            SET_ENABLE_AUTO_SHUTTER: Enables the auto exposure function.\n\n        Return Value:\n        =============\n        \n            nexpo\n                The exposure time actually set\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetExposureTime(PyObject *__pyx_v_self, PyObject *__pyx_arg_expo) {
  double __pyx_v_expo;
  double __pyx_v_nexpo;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetExposureTime");
  assert(__pyx_arg_expo); {
    __pyx_v_expo = __pyx_PyFloat_AsDouble(__pyx_arg_expo); if (unlikely((__pyx_v_expo == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 317; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetExposureTime");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":356
 * 
 *         cdef double nexpo
 *         rv= is_SetExposureTime(self.cid, expo, &nexpo)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return nexpo
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetExposureTime(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_expo, (&__pyx_v_nexpo))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 356; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":357
 *         cdef double nexpo
 *         rv= is_SetExposureTime(self.cid, expo, &nexpo)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return nexpo
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":358
 *         rv= is_SetExposureTime(self.cid, expo, &nexpo)
 *         self.CheckNoSuccess(rv)
 *         return nexpo             # <<<<<<<<<<<<<<
 * 
 *     def GetFramesPerSecond(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_nexpo); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 358; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetExposureTime");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":360
 *         return nexpo
 * 
 *     def GetFramesPerSecond(self):             # <<<<<<<<<<<<<<
 *         '''Return the frames per second
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetFramesPerSecond(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetFramesPerSecond[] = "Return the frames per second\n        \n        In live capture mode started by CaptureVideo(), the GetFramesPerSecond() \n        function returns the number of frames actually captured per second.\n               \n        Syntax:\n        =======\n        dblFPS = cam.GetFramesPerSecond()\n        \n        Return Values:\n        ==============\n            dblFPS: \n                Returns the current frame rate.\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetFramesPerSecond(PyObject *__pyx_v_self, PyObject *unused) {
  double __pyx_v_dblFPS;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("GetFramesPerSecond");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":377
 * 
 *         cdef double dblFPS
 *         rv=is_GetFramesPerSecond (self.cid, &dblFPS)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return dblFPS
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetFramesPerSecond(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&__pyx_v_dblFPS))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":378
 *         cdef double dblFPS
 *         rv=is_GetFramesPerSecond (self.cid, &dblFPS)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return dblFPS
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":379
 *         rv=is_GetFramesPerSecond (self.cid, &dblFPS)
 *         self.CheckNoSuccess(rv)
 *         return dblFPS             # <<<<<<<<<<<<<<
 * 
 *     def GetFrameTimeRange(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_dblFPS); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.GetFramesPerSecond");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":381
 *         return dblFPS
 * 
 *     def GetFrameTimeRange(self):             # <<<<<<<<<<<<<<
 *         '''Returns the frame rate settings
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetFrameTimeRange(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetFrameTimeRange[] = "Returns the frame rate settings\n        \n        Using GetFrameTimeRange(), you can read out the frame rate settings \n        which are available for the current pixel clock setting. \n        The returned values indicate the minimum and maximum frame duration \n        in seconds. You can set the frame duration between min and max \n        in increments defined by the intervall parameter.\n    \n        Syntax:\n        =======\n        \n        min,max,intervall= cam.GetFrameTimeRange()\n           \n        Return Values:\n        ==============\n      \n        min: \n            Minimum available frame duration.\n\n        max:\n            Maximum available frame duration.\n\n        intervall: \n           Increment you can use to change the frame duration.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetFrameTimeRange(PyObject *__pyx_v_self, PyObject *unused) {
  double __pyx_v_min;
  double __pyx_v_max;
  double __pyx_v_intervall;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("GetFrameTimeRange");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":410
 * 
 *         cdef double min,max,intervall
 *         rv=is_GetFrameTimeRange (self.cid, &min, &max, &intervall)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return (min,max,intervall)
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetFrameTimeRange(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&__pyx_v_min), (&__pyx_v_max), (&__pyx_v_intervall))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":411
 *         cdef double min,max,intervall
 *         rv=is_GetFrameTimeRange (self.cid, &min, &max, &intervall)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return (min,max,intervall)
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":412
 *         rv=is_GetFrameTimeRange (self.cid, &min, &max, &intervall)
 *         self.CheckNoSuccess(rv)
 *         return (min,max,intervall)             # <<<<<<<<<<<<<<
 * 
 *     def SetFrameRate(self, double FPS):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_min); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_max); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_intervall); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_3 = 0;
  __pyx_t_2 = 0;
  __pyx_t_1 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("ueye.ueye.Cam.GetFrameTimeRange");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":414
 *         return (min,max,intervall)
 * 
 *     def SetFrameRate(self, double FPS):             # <<<<<<<<<<<<<<
 *         '''Set the Frame rate
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetFrameRate(PyObject *__pyx_v_self, PyObject *__pyx_arg_FPS); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetFrameRate[] = "Set the Frame rate\n        \n        Using SetFrameRate(), you can set the sensor frame rate in \n        freerun mode (live mode). Since this value depends on the sensor\n        timing, the exposure time actually used may slightly deviate from \n        the value set here. After you have called the function, the actual \n        frame rate is returned. If the frame rate is set too high, it might not \n        be possible to transfer every single frame. In this case, the effective \n        frame rate may vary from the set value.\n       \n        The use of the following functions will affect the frame rate:\n        \n        - SetPixelClock()\n        - SetAOI() (if the image size is changed)\n        - SetSubSampling()\n        - SetBinning()\n\n        Changes made to the window size or the read-out timing \n        (pixel clock frequency) also affect the defined frame rate. For this \n        reason, you need to call SetFrameRate() again after such changes.\n       \n        Newer driver versions sometimes allow an extended value range for \n        the frame rate setting. We recommend to query the value range \n        every time and set the frame rate explicitly. Changes to the frame \n        rate affect the value ranges of the exposure time. \n        \n        After executing SetFrameRate(), calling the function SetExposureTime()\n        is recommended in order to keep the defined camera settings.\n           \n        Syntax:\n        =======\n        \n        newFPS=cam.SetFrameRate(FPS)\n        \n        Input Parameters:\n        =================\n    \n        FPS: \n            Desired frame rate in frames per second (fps)\n        \n        Return Values:\n            newFPS: \n                Returns the frame rate actually set.\n                \n                if FPS=GET_FRAMERATE: Returns the current frame rate.\n                \n                if PFS=GET_DEFAULT_FRAMERATE: Returns the default frame rate.\n\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetFrameRate(PyObject *__pyx_v_self, PyObject *__pyx_arg_FPS) {
  double __pyx_v_FPS;
  double __pyx_v_newFPS;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetFrameRate");
  assert(__pyx_arg_FPS); {
    __pyx_v_FPS = __pyx_PyFloat_AsDouble(__pyx_arg_FPS); if (unlikely((__pyx_v_FPS == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 414; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetFrameRate");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":465
 *         '''
 *         cdef double newFPS
 *         rv=is_SetFrameRate (self.cid, FPS, &newFPS)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return newFPS
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetFrameRate(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_FPS, (&__pyx_v_newFPS))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 465; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":466
 *         cdef double newFPS
 *         rv=is_SetFrameRate (self.cid, FPS, &newFPS)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return newFPS
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":467
 *         rv=is_SetFrameRate (self.cid, FPS, &newFPS)
 *         self.CheckNoSuccess(rv)
 *         return newFPS             # <<<<<<<<<<<<<<
 * 
 *     def GetPixelClockRange(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_newFPS); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetFrameRate");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":469
 *         return newFPS
 * 
 *     def GetPixelClockRange(self):             # <<<<<<<<<<<<<<
 *         '''Return the pixel clock range
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetPixelClockRange(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetPixelClockRange[] = "Return the pixel clock range\n        \n        GetPixelClockRange() returns the adjustable pixel clock range.\n        The pixel clock limit values can vary, depending on the camera \n        model and operating mode. \n   \n        Syntax:\n        =======\n        \n        pnMin, pnMax=cam.GetPixelClockRange()\n        \n        Return Values:\n        ==============\n        \n        pnMin: Lower limit value.\n        \n        pnMax: Upper limit value.\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetPixelClockRange(PyObject *__pyx_v_self, PyObject *unused) {
  INT __pyx_v_pnMin;
  INT __pyx_v_pnMax;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("GetPixelClockRange");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":490
 * 
 *         cdef INT pnMin,pnMax
 *         rv=is_GetPixelClockRange (self.cid, &pnMin, &pnMax)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return pnMin,pnMax
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetPixelClockRange(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&__pyx_v_pnMin), (&__pyx_v_pnMax))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 490; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":491
 *         cdef INT pnMin,pnMax
 *         rv=is_GetPixelClockRange (self.cid, &pnMin, &pnMax)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return pnMin,pnMax
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":492
 *         rv=is_GetPixelClockRange (self.cid, &pnMin, &pnMax)
 *         self.CheckNoSuccess(rv)
 *         return pnMin,pnMax             # <<<<<<<<<<<<<<
 * 
 *     def SetPixelClock(self,Clock):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyInt_to_py_INT(__pyx_v_pnMin); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyInt_to_py_INT(__pyx_v_pnMax); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_3 = 0;
  __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.GetPixelClockRange");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":494
 *         return pnMin,pnMax
 * 
 *     def SetPixelClock(self,Clock):             # <<<<<<<<<<<<<<
 *         '''Configure the pixel clock
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetPixelClock(PyObject *__pyx_v_self, PyObject *__pyx_v_Clock); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetPixelClock[] = "Configure the pixel clock\n \n        SetPixelClock() sets the frequency used to read out image data \n        from the sensor (pixel clock frequency). Due to an excessive pixel \n        clock for USB cameras, images may get lost during the transfer. \n        If you change the pixel clock on-the-fly, the current image \n        capturing process will be aborted.\n        \n        Some sensors allow a higher pixel clock setting if binning or \n        subsampling has been activated. If you set a higher pixel clock \n        and then reduce the binning/subsampling factors again, \n        the driver will automatically select the highest possible pixel \n        clock for the new settings.\n        \n        Changes to the image geometry or pixel clock affect the value ranges \n        of the frame rate and exposure time. After executing SetPixelClock(), \n        calling the following functions is recommended in order to keep \n        the defined camera settings:\n    \n        - SetFrameRate()\n        - SetExposureTime()\n        - If you are using the uEye's flash function: SetFlashStrobe()\n       \n        Syntax:\n        =======\n        \n        rv=cam.SetPixelClock(clock)\n        \n        Input Parameters:\n        =================\n        \n        Clock: Pixel clock frequency to be set (in MHz)\n\n        Return Values:\n        ==============\n        \n        rv: \n            SUCCESS: Function executed successfully\n        \n            Current setting when clock = GET_PIXEL_CLOCK\n    \n            INVALID_MODE: Camera is in standby mode, function not allowed.\n\n            INVALID_PARAMETER: The value for Clock is outside the pixel clock \n            range supported by the camera.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetPixelClock(PyObject *__pyx_v_self, PyObject *__pyx_v_Clock) {
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  INT __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("SetPixelClock");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":543
 *         '''
 * 
 *         rv= is_SetPixelClock (self.cid, Clock)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_from_py_INT(__pyx_v_Clock); if (unlikely((__pyx_t_1 == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = __Pyx_PyInt_to_py_INT(is_SetPixelClock(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_t_1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":544
 * 
 *         rv= is_SetPixelClock (self.cid, Clock)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 544; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 544; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_4 = PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 544; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":545
 *         rv= is_SetPixelClock (self.cid, Clock)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetAutoParameter(self,INT param, double pval1, double pval2):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetPixelClock");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":547
 *         return rv
 * 
 *     def SetAutoParameter(self,INT param, double pval1, double pval2):             # <<<<<<<<<<<<<<
 *         '''Set automatic parameters for the cam
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetAutoParameter(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetAutoParameter[] = "Set automatic parameters for the cam\n""        \n""        Using SetAutoParameter(), you can control the automatic gain, \n""        exposure shutter, frame rate and white balance control values.\n""       \n""        - Control is only active as long as the camera is capturing images.\n""        - A manual change of the exposure time and gain settings disables \n""          the auto functions.\n""        - When the auto shutter function is enabled, you cannot modify \n""          the pixel clock frequency.\n""        - The auto frame rate function is only available when the auto \n""          shutter control is on. \n""          Auto frame rate and auto gain cannot be used simultaneously.\n""        - The auto gain function can only be used for cameras with master \n""          gain control set. Auto white balance is only available for cameras\n""          with hardware RGB gain control set.\n""        - The sensor's internal auto functions are only supported by the \n""          sensor of the UI-122x/522x camera models. \n""        \n""        Syntax:\n""        =======\n""        \n""        pv1,pv2=cam.SetAutoParameters(param, pval1, pval2)\n""        \n""        Input Parameters:\n""        =================\n""            param: Configure auto control\n""\n""                SET_ENABLE_AUTO_GAIN  Enables / disables the auto gain function. \n""                Control parameter pval1 = 1 enables, 0 disables control\n""\n""                GET_ENABLE_AUTO_GAIN Returns the current auto gain setting. return \n""                value pv1 returns the current value\n""\n""                SET_ENABLE_AUTO_SENSOR_GAIN Enables / disables the sensor's \n""                internal auto gain function. Control parameter pval1 = 1 enables, \n""                0 disables control\n""\n""                GET_ENABLE_AUTO_SENSOR_GAIN Returns the current setting of the \n""                sensor's internal auto gain function. Return value pv1 returns \n""                the current value\n""\n""                SET_ENABLE_AUTO_SHUTTER  Enables / disables the auto exposure \n""                function. Control parameter pval1= 1 enables, 0 disables control\n""\n""                GET_ENABLE_AUTO_SHUTTER Returns the current auto exposure setting. \n""                Return value pv1 returns the current value\n""\n""                SET_ENABLE_AUTO_SENSOR_SHUTTER Enables / disables the sensor's \n""                internal auto exposure function. Control parameter pval1= 1 enables,\n""                0 disables control\n""\n""                GET_ENABLE_AUTO_SENSOR_SHUTTER Returns the current setting of the \n""                sensor's internal auto exposure function. Return value pv1 returns \n""                the current value\n""\n""                SET_ENABLE_AUTO_WHITEBALANCE Enables / disables the auto white \n""                balance function. Control parameter pval1 = 1 enables, \n""                0 disables control\n""\n""                GET_ENABLE_AUTO_WHITEBALANCE Returns the current auto white balance \n""                setting. Return value pv1 returns the current value\n""\n""                SET_ENABLE_AUTO_FRAMERATE Enables / disables the auto frame rate \n""                function. Control parameter pval1 = 1 enables, 0 disables control\n""\n""                GET_ENABLE_AUTO_FRAMERATE Returns the current auto frame rate \n""                setting. Return value pv1 returns the current value\n""\n""                SET_ENABLE_AUTO_SENSOR_FRAMERATE Enables / disables the sensor's \n""                internal auto frame rate function. Control parameter pval1 = 1 \n""                enables, 0 disables control\n""\n""                GET_ENABLE_AUTO_SENSOR_FRAMERATE Returns the current setting of \n""                the sensor's internal auto frame rate function. Return value pv1\n""                returns the current value\n""\n""                SET_AUTO_REFERENCE Sets the setpoint value for auto gain / auto \n""                shutter. Control parameter pval1 defines the setpoint value \n""                (average image brightness). Independent of pixel bit depth the \n""                setpoint range is:\n""\n""                    0 = black\n""\n""                    128 = 50% grey (default)\n""                    \n""                    255 = white\n""\n""                GET_AUTO_REFERENCE Returns the setpoint value for auto gain/auto \n""                shutter. Return value pv1 returns the current value\n""\n""                SET_AUTO_GAIN_MAX Sets the upper limit for auto gain. Control \n""                parameter pval1 set the valid value for gain (0...100)\n""\n""                GET_AUTO_GAIN_MAX Returns the upper limit for auto gain. Return value\n""                pv1 returns the current value\n""\n""                SET_AUTO_SHUTTER_MAX Sets the upper limit for auto exposure. \n""                Control parameter pval1 defines the valid exposure value \n""                (0 sets the value continuously to max. exposure)\n""\n""                GET_AUTO_SHUTTER_MAX Returns the upper limit for auto exposure. \n""                Return value pv1 returns the current value\n""\n""                SET_AUTO_SPEED Sets the speed value for auto gain / exposure. \n""                Control parameter pval1 defines the control speed (0...100)\n""\n""                GET_AUTO_SPEED Returns the speed value for auto gain / exposure. \n""                Return value pv1 returns the current value\n""\n""                SET_AUTO_HYSTERESIS Sets the hysteresis for auto gain / exposure. \n""                Control parameter pval1 defines the hysteresis value (default: 2)\n""\n""                GET_AUTO_HYSTERESIS Returns the hysteresis for auto gain / exposure.\n""                Return value pv1 returns the current value\n""\n""                GET_AUTO_HYSTERESIS_RANGE Returns range for the hysteresis value. \n""                Return value pv1 returns the minimum value, and pv2 returns the \n""                maximum value\n""\n""                SET_AUTO_SKIPFRAMES Sets the number of frames to be skipped for \n""                auto gain / auto exposure. Control parameter pval1 defines the \n""                number of frames to be skipped (default: 4)\n""\n""                GET_AUTO_SKIPFRAMES Returns the number of frames to be skipped \n""                for auto gain / auto exposure. Return value pv1 returns the \n""                current value\n""\n""                GET_AUTO_SKIPFRAMES_RANGE Returns range for the number of frames \n""                to be skipped. Return value pv1 returns the minimum value, and pv2\n""                returns the maximum value\n""\n""                SET_AUTO_BRIGHTNESS_ONCE Enables / disables automatic disabling \n""                of auto gain / auto exposure. Control parameter pval1 = 1 enables,\n""                0 disables control\n""\n""                GET_AUTO_BRIGHTNESS_ONCE Returns the automatic disable status of \n""                auto gain / auto exposure. Return value pv1 returns the current\n""                value\n""\n""\n""                SET_AUTO_WB_OFFSET Sets the offset value for the red and blue \n""                channels. Control parameter pval1 defines the red level offset \n""                (-50...50) and pval2 defines the blue level offset (-50...50)\n""\n""                GET_AUTO_WB_OFFSET Returns the offset value for the red and blue \n""                channels. Return value pv1 returns the red level offset (-50...50)\n""                and pv2 returns the blue level offset (-50...50)\n""\n""                SET_AUTO_WB_GAIN_RANGE Sets the gain limits for the auto white \n""                balance function. Control parameter pval1 sets the minimum value\n""                and pval2 sets the maximum value\n""                \n""                GET_AUTO_WB_GAIN_RANGE Returns the gain limits for the auto white \n""                balance function. Return value pv1 returns the minimum value and\n""                pv2 returns the maximum value\n""\n""                SET_AUTO_WB_SPEED Sets the speed value for the auto white balance.\n""                Control parameter pval1 defines the control speed (0...100)\n""                \n""                GET_AUTO_WB_SPEED Returns the speed value for the auto white \n""                balance. Return value pv1 returns the current value\n""\n""                SET_AUTO_WB_HYSTERESIS Sets the hysteresis for auto white balance. \n""                Control parameter pval1 defines the hysteresis value (default: 2)\n""\n""                GET_AUTO_WB_HYSTERESIS Returns the hysteresis for auto white \n""                balance. Return value pv1 returns the current value\n""\n""                GET_AUTO_WB_HYSTERESIS_RANGE Returns range for the hysteresis \n""                value. Return value pv1 returns the minimum value and pv2 \n""                returns the maximum value\n""\n""                SET_AUTO_WB_SKIPFRAMES Sets the number of frames to be skipped \n""                for auto white balance. Control parameter pval1 defines the number \n""                of frames to be skipped (default: 4)\n""\n""                GET_AUTO_WB_SKIPFRAMES Returns the number of frames to be skipped \n""                for auto white balance. Return value pv1 returns the current value\n""\n""                GET_AUTO_WB_SKIPFRAMES_RANGE Returns range for the number of frames\n""                to be skipped. Return value pv1 returns the minimum value and pv2\n""                returns the maximum value\n""\n""                SET_AUTO_WB_ONCE Enables / disables automatic disabling of auto \n""                white balance. Control parameter pval1 = 1 enables, 0 disables \n""                control\n""\n""                GET_AUTO_WB_ONCE Returns the automatic disable status of auto \n""                white balance. Return value pv1 returns the current value\n""                \n""                Pre-defined values for auto gain/auto exposure\n""\n""                For parameters pval1 and pval, NULL must be passed.\n""\n""                DEFAULT_AUTO_BRIGHT_REFERENCE Default setpoint value for auto gain /  exposure\n""                \n""                MIN_AUTO_BRIGHT_REFERENCE Minimum setpoint value for auto gain /  exposure\n""\n""                MAX_AUTO_BRIGHT_REFERENCE Maximum setpoint value for auto gain /  exposure\n""\n""                DEFAULT_AUTO_SPEED Default value for auto speed\n""\n""                MAX_AUTO_SPEED Maximum value for auto speed\n""                \n""                Pre-defined values for auto white balance\n""\n""                For parameters pval1 and pval, NULL must be passed.\n""\n""                DEFAULT_WB_OFFSET Default value for auto white balance offset\n""\n""                MIN_WB_OFFSET Minimum value for auto white balance offset\n""\n""                MAX_WB_OFFSET Maximum value for auto white balance offset\n""\n""                DEFAULT_AUTO_WB_SPEED Default value for auto white balance speed\n""\n""                MIN_AUTO_WB_SPEED Minimum value for auto white balance speed\n""\n""                MAX_AUTO_WB_SPEED Maximum value for auto white balance speed\n""        \n""            pval1: \n""                Control parameter, can have a variable value depending on \n""                the corresponding auto function. See table above.\n""\n""            pval2:\n""                Control parameter, can have a variable value depending on \n""                the corresponding auto function. See table above.\n""        \n""        Return Values:\n""        ==============\n""            pv1:\n""                Return value, can have a variable value depending on \n""                the corresponding auto function. See table above.\n""            \n""            pv2:\n""                Return value, can have a variable value depending on \n""                the corresponding auto function. See table above.\n""\n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetAutoParameter(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_param;
  double __pyx_v_pval1;
  double __pyx_v_pval2;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__param,&__pyx_n_s__pval1,&__pyx_n_s__pval2,0};
  __Pyx_RefNannySetupContext("SetAutoParameter");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[3] = {0,0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__param);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pval1);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetAutoParameter", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  2:
      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pval2);
      if (likely(values[2])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetAutoParameter", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetAutoParameter") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_param = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_param == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pval1 = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_pval1 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pval2 = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_pval2 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_param = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_param == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pval1 = __pyx_PyFloat_AsDouble(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_pval1 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pval2 = __pyx_PyFloat_AsDouble(PyTuple_GET_ITEM(__pyx_args, 2)); if (unlikely((__pyx_v_pval2 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetAutoParameter", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetAutoParameter");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":789
 *         '''
 * 
 *         rv= is_SetAutoParameter (self.cid, param, &pval1, &pval2)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return pval1,pval2
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetAutoParameter(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_param, (&__pyx_v_pval1), (&__pyx_v_pval2))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 789; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":790
 * 
 *         rv= is_SetAutoParameter (self.cid, param, &pval1, &pval2)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return pval1,pval2
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":791
 *         rv= is_SetAutoParameter (self.cid, param, &pval1, &pval2)
 *         self.CheckNoSuccess(rv)
 *         return pval1,pval2             # <<<<<<<<<<<<<<
 * 
 *     def SetBlCompensation(self, INT nEnable, INT offset):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_pval1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_pval2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_3 = 0;
  __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetAutoParameter");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":793
 *         return pval1,pval2
 * 
 *     def SetBlCompensation(self, INT nEnable, INT offset):             # <<<<<<<<<<<<<<
 *         '''Set black level compensation
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetBlCompensation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetBlCompensation[] = "Set black level compensation\n""\n""        SetBlCompensation() enables the black level correction function \n""        which might improve the image quality under certain circumstances. \n""        By default, the sensor adjusts the black level value for each pixel \n""        automatically. If the environment is very bright, it can be necessary \n""        to adjust the black level manually.\n""    \n""        Syntax:\n""        =======\n""        rv=cam.SetBlCompensation(nEnable, offset)\n""        \n""        Input Parameters:\n""        =================\n""        \n""        nEnable:\n""    \n""            BL_COMPENSATION_DISABLE: Disables automatic black level correction. \n""            The offset value is used as black level instead. This mode is only \n""            supported by sensors of the UI-154x/554x series.\n""\n""            BL_COMPENSATION_ENABLE: Enables automatic black level correction. \n""            The offset value is added to the automatic black level value.\n""\n""            GET_BL_COMPENSATION: Returns the current mode.\n""\n""            GET_BL_OFFSET: Returns the currently set value for offset.\n""\n""            GET_BL_DEFAULT_MODE: Returns the default mode.\n""\n""            GET_BL_DEFAULT_OFFSET: Returns the default value for offset.\n""\n""            GET_BL_SUPPORTED_MODE: Returns the supported modes.\n""\n""            Possible values:\n""    \n""                BL_COMPENSATION_ENABLE:\n""                The sensor supports automatic black level correction.\n""\n""                BL_COMPENSATION_OFFSET:\n""                For the sensor used, it is also possible to set the offset manual.\n""\n""        IGNORE_PARAMETER: The nEnable parameter is ignored.\n""\n""        offset: \n""            Contains the offset value used for compensation. Valid values \n""            are between 0 and 255.\n""\n""            IGNORE_PARAMETER: The offset parameter is ignored.\n""\n""            \n""        Return Values:\n""        ==============\n""        \n""        rv:\n""            SUCCESS: Function executed successfully\n""\n""            Supported modes when used together with GET_BL_SUPPORTED_MODE\n""    \n""            Current mode when used together with GET_BL_COMPENSATION\n""    \n""            Current offset when used together with GET_BL_OFFSET\n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetBlCompensation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_nEnable;
  INT __pyx_v_offset;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nEnable,&__pyx_n_s__offset,0};
  __Pyx_RefNannySetupContext("SetBlCompensation");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nEnable);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__offset);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetBlCompensation", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 793; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetBlCompensation") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 793; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_nEnable = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_nEnable == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 793; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_offset = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_offset == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 793; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_nEnable = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_nEnable == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 793; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_offset = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_offset == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 793; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetBlCompensation", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 793; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetBlCompensation");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":858
 *         '''
 * 
 *         rv=is_SetBlCompensation (self.cid, nEnable, offset, 0)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetBlCompensation(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nEnable, __pyx_v_offset, 0)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":859
 * 
 *         rv=is_SetBlCompensation (self.cid, nEnable, offset, 0)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 859; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 859; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 859; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":860
 *         rv=is_SetBlCompensation (self.cid, nEnable, offset, 0)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetGainBoost(self, mode):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetBlCompensation");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":862
 *         return rv
 * 
 *     def SetGainBoost(self, mode):             # <<<<<<<<<<<<<<
 *         ''' Set the gain boost
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetGainBoost(PyObject *__pyx_v_self, PyObject *__pyx_v_mode); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetGainBoost[] = " Set the gain boost\n        \n        In some cameras, SetGainBoost() enables an additional analogue \n        hardware gain boost feature on the sensor. \n        \n        Syntax:\n        =======    \n        \n        rv=cam.SetGainBoost(mode)\n        \n        Input Parameters:\n        =================\n        \n        mode:\n            GET_GAINBOOST: Returns the current state of the gain boost function.\n\n            SET_GAINBOOST_ON: Enables the gain boost function.\n\n            SET_GAINBOOST_OFF: Disables the gain boost function.\n\n            GET_SUPPORTED_GAINBOOST: Indicates whether the camera supports a \n            gain boost feature or not.\n            \n        Return Values:\n        ==============\n            \n            SUCCESS: Function executed successfully\n        \n            Current setting when used together with GET_GAINBOOST\n            Returns 0 if the camera does not support a gain boost feature.\n\n            Current setting when used together with GET_SUPPORTED_GAINBOOST\n            Returns SET_GAINBOOST_ON if the function is supported, otherwise \n            it returns SET_GAINBOOST_OFF.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetGainBoost(PyObject *__pyx_v_self, PyObject *__pyx_v_mode) {
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  INT __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("SetGainBoost");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":900
 *         '''
 * 
 *         rv= is_SetGainBoost (self.cid, mode)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_from_py_INT(__pyx_v_mode); if (unlikely((__pyx_t_1 == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 900; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = __Pyx_PyInt_to_py_INT(is_SetGainBoost(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_t_1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 900; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":901
 * 
 *         rv= is_SetGainBoost (self.cid, mode)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_4 = PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":902
 *         rv= is_SetGainBoost (self.cid, mode)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetGamma(self, INT nGamma):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetGainBoost");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":904
 *         return rv
 * 
 *     def SetGamma(self, INT nGamma):             # <<<<<<<<<<<<<<
 *         ''' Set gamma correction
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetGamma(PyObject *__pyx_v_self, PyObject *__pyx_arg_nGamma); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetGamma[] = " Set gamma correction\n        \n        SetGamma() sets the value for digital gamma correction \n        (brighten dark image portions by applying a non-linear characteristic (LUT)). \n        Valid values are in the range between 0.01 and 10.\n        \n        Syntax:\n        =======\n        \n        rv=cam.SetGamma(nGamma)\n        \n        Input Parameters:\n        =================\n        \n        nGamma: \n            Gamma value to be set, multiplied by 100 (Range: 1\342\200\2461000. \n            Default = 100, corresponds to a gamma value of 1.0)\n\n            GET_GAMMA: Returns the current setting.\n        \n        Return Value:\n        =============\n            SUCCESS: Function executed successfully\n        \n            Current setting when used together with GET_GAMMA        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetGamma(PyObject *__pyx_v_self, PyObject *__pyx_arg_nGamma) {
  INT __pyx_v_nGamma;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetGamma");
  assert(__pyx_arg_nGamma); {
    __pyx_v_nGamma = __Pyx_PyInt_from_py_INT(__pyx_arg_nGamma); if (unlikely((__pyx_v_nGamma == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 904; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetGamma");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":932
 *         '''
 * 
 *         rv=is_SetGamma (self.cid, nGamma)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetGamma(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nGamma)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":933
 * 
 *         rv=is_SetGamma (self.cid, nGamma)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 933; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 933; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 933; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":934
 *         rv=is_SetGamma (self.cid, nGamma)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetGlobalShutter(self, INT mode):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetGamma");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":936
 *         return rv
 * 
 *     def SetGlobalShutter(self, INT mode):             # <<<<<<<<<<<<<<
 *         '''Set global shutter
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetGlobalShutter(PyObject *__pyx_v_self, PyObject *__pyx_arg_mode); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetGlobalShutter[] = "Set global shutter        \n        \n        SetGlobalShutter() enables the Global Start shutter function on some sensors.\n        \n        ** The Global Start shutter function is only supported in trigger mode \n        (see also SetExternalTrigger())**.\n        \n        Syntax:\n        =======\n        \n        rv=cam.SetGlobalShutter(mode)\n        \n        Input Parameters:\n        =================\n        \n        mode:\n            GET_GLOBAL_SHUTTER: Returns the current mode or NOT_SUPPORTED \n            if the camera does not support this function.\n\n            SET_GLOBAL_SHUTTER_ON: Enables Global Start shutter mode.\n\n            SET_GLOBAL_SHUTTER_OFF: Disables Global Start shutter mode.\n\n            GET_SUPPORTED_GLOBAL_SHUTTER: Indicates whether the connected camera \n            supports the Global Start shutter or not.\n            \n        Return Values:\n        ==============\n        rv:\n            SUCCESS: Function executed successfully\n\n            When used together with GET_SUPPORTED_GLOBAL_SHUTTER\n            Returns SET_GLOBAL_SHUTTER_ON if this function is supported. \n            Otherwise, it returns SET_GLOBAL_SHUTTER_OFF.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetGlobalShutter(PyObject *__pyx_v_self, PyObject *__pyx_arg_mode) {
  INT __pyx_v_mode;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  __pyx_t_4ueye_4ueye_HIDS __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("SetGlobalShutter");
  assert(__pyx_arg_mode); {
    __pyx_v_mode = __Pyx_PyInt_from_py_INT(__pyx_arg_mode); if (unlikely((__pyx_v_mode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 936; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetGlobalShutter");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":974
 *         '''
 * 
 *         rv=is_SetGlobalShutter (self, mode)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_from_py_DWORD(__pyx_v_self); if (unlikely((__pyx_t_1 == (DWORD)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = __Pyx_PyInt_to_py_INT(is_SetGlobalShutter(__pyx_t_1, __pyx_v_mode)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":975
 * 
 *         rv=is_SetGlobalShutter (self, mode)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_4 = PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":976
 *         rv=is_SetGlobalShutter (self, mode)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetHardwareGain (self, INT nMaster, INT nRed, INT nGreen, INT nBlue):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetGlobalShutter");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":978
 *         return rv
 * 
 *     def SetHardwareGain (self, INT nMaster, INT nRed, INT nGreen, INT nBlue):             # <<<<<<<<<<<<<<
 *         ''' Set hardware gain
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetHardwareGain(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetHardwareGain[] = " Set hardware gain\n""        \n""        SetHardwareGain() controls the sensor gain channels. These can be set \n""        between 0% and 100% independently of of each other. The actual gain factor \n""        obtained for the value 100% depends on the sensor.\n""\n""        You can use the GetSensorInfo() function to query the available gain controls.\n""        Depending on the time when the gain settings are changed, these changes \n""        might only become effective when the next image is captured.\n""        \n""        ** Enabling hardware gain increases not only the image brightness, \n""        but also the image noise. We recommend to use gain values \n""        below 50 for normal operation. \n""        \n""        The default setting values for the red, green and blue channel gain factors \n""        depend on the colour correction matrix that has been set. \n""        If you select a different colour correction matrix, the returned default values \n""        might change (see also SetColorCorrection()).**\n""        \n""        Syntax:\n""        =======\n""        \n""        rv=cam.SetHardwareGain(nMaster, nRed, nGreen, nBlue)\n""        \n""        Input Parameters:\n""        =================\n""        \n""        nMaster: \n""            Sets the overall gain factor (0...100).\n""            \n""            IGNORE_PARAMETER: The master gain factor will not be changed.\n""            \n""            GET_MASTER_GAIN: Returns the master gain factor.\n""            \n""            GET_RED_GAIN: Returns the red channel gain factor.\n""            \n""            GET_GREEN_GAIN: Returns the green channel gain factor.\n""            \n""            GET_BLUE_GAIN: Returns the blue channel gain factor.\n""            \n""            GET_DEFAULT_MASTER: Returns the default master gain factor.\n""            \n""            GET_DEFAULT_RED: Returns the default red channel gain factor.\n""            \n""            GET_DEFAULT_GREEN: Returns the default green channel gain factor.\n""            \n""            GET_DEFAULT_BLUE: Returns the default blue channel gain factor.\n""            \n""            SET_ENABLE_AUTO_GAIN: Enables the auto gain functionality \n""            (see also SetAutoParameter()). You can disable the auto gain functionality\n""            by setting a value for nMaster.\n""\n""        nRed: \n""            Sets the red channel gain factor (0...100).\n""        \n""            IGNORE_PARAMETER: The channel gain factor will not be changed.\n""        \n""        nGreen: \n""            Sets the green channel gain factor (0...100).\n""        \n""            IGNORE_PARAMETER: The green channel gain factor will not be changed.\n""\n""        nBlue: \n""            Sets the blue channel gain factor (0...100).\n""            IGNORE_PARAMETER: The blue channel gain factor will not be changed.\n""        \n""        Return Values:\n""        ==============\n""        \n""        rv:\n""            SUCCESS: Function executed successfully\n""        \n""            Current setting when used together with GET_MASTER_GAIN, GET_RED_GAIN,\n""            GET_GREEN_GAIN, GET_BLUE_GAIN\n""    \n""            INVALID_MODE: Camera is in standby mode, function not allowed.      \n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetHardwareGain(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_nMaster;
  INT __pyx_v_nRed;
  INT __pyx_v_nGreen;
  INT __pyx_v_nBlue;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nMaster,&__pyx_n_s__nRed,&__pyx_n_s__nGreen,&__pyx_n_s__nBlue,0};
  __Pyx_RefNannySetupContext("SetHardwareGain");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[4] = {0,0,0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nMaster);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nRed);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetHardwareGain", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  2:
      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nGreen);
      if (likely(values[2])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetHardwareGain", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  3:
      values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nBlue);
      if (likely(values[3])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetHardwareGain", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetHardwareGain") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_nMaster = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_nMaster == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_nRed = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_nRed == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_nGreen = __Pyx_PyInt_from_py_INT(values[2]); if (unlikely((__pyx_v_nGreen == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_nBlue = __Pyx_PyInt_from_py_INT(values[3]); if (unlikely((__pyx_v_nBlue == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_nMaster = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_nMaster == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_nRed = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_nRed == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_nGreen = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 2)); if (unlikely((__pyx_v_nGreen == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_nBlue = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 3)); if (unlikely((__pyx_v_nBlue == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetHardwareGain", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetHardwareGain");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1057
 *         '''
 * 
 *         rv=is_SetHardwareGain (self.cid, nMaster, nRed, nGreen, nBlue)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetHardwareGain(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nMaster, __pyx_v_nRed, __pyx_v_nGreen, __pyx_v_nBlue)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1057; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1058
 * 
 *         rv=is_SetHardwareGain (self.cid, nMaster, nRed, nGreen, nBlue)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1059
 *         rv=is_SetHardwareGain (self.cid, nMaster, nRed, nGreen, nBlue)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetHardwareGamma (self, INT nMode):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetHardwareGain");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1061
 *         return rv
 * 
 *     def SetHardwareGamma (self, INT nMode):             # <<<<<<<<<<<<<<
 *         ''' Set the hardware gamma value
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetHardwareGamma(PyObject *__pyx_v_self, PyObject *__pyx_arg_nMode); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetHardwareGamma[] = " Set the hardware gamma value\n                \n        SetHardwareGamma() enables the hardware gamma control feature of the camera.\n\n        ** The SetHardwareGamma() function is only supported by cameras of \n        the GigE uEye series.**\n        \n        Syntax:\n        =======\n        \n        rv=cam.SetHardwareGamma(nMode)\n        \n        Input Parameters:\n        =================\n        \n        nMode:\n            GET_HW_SUPPORTED_GAMMA: Indicates whether the camera supports hardware \n            gamma control or not.\n\n            SET_HW_GAMMA_ON: Enables the gamma control feature.\n\n            SET_HW_GAMMA_OFF: Disables gamma control.\n\n            GET_HW_GAMMA: Returns the current state of gamma control.\n        \n        Return Values:\n        ==============\n        \n        rv:\n            SUCCESS: Function executed successfully\n            \n            Current setting when used together with GET_HW_GAMMA\n            \n            When used together with GET_HW_SUPPORTED_GAMMA: \n                \n                SET_HW_GAMMA_ON: The camera supports gamma control.\n                \n                SET_HW_GAMMA_OFF: The camera does not support gamma control.\n            \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetHardwareGamma(PyObject *__pyx_v_self, PyObject *__pyx_arg_nMode) {
  INT __pyx_v_nMode;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetHardwareGamma");
  assert(__pyx_arg_nMode); {
    __pyx_v_nMode = __Pyx_PyInt_from_py_INT(__pyx_arg_nMode); if (unlikely((__pyx_v_nMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1061; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetHardwareGamma");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1103
 *         '''
 * 
 *         rv=is_SetHardwareGamma (self.cid, nMode)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetHardwareGamma(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nMode)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1104
 * 
 *         rv=is_SetHardwareGamma (self.cid, nMode)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1105
 *         rv=is_SetHardwareGamma (self.cid, nMode)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetHWGainFactor (self, INT nMode, INT nFactor):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetHardwareGamma");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1107
 *         return rv
 * 
 *     def SetHWGainFactor (self, INT nMode, INT nFactor):             # <<<<<<<<<<<<<<
 *         ''' Set the hardware gain factor
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetHWGainFactor(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetHWGainFactor[] = " Set the hardware gain factor\n""                \n""        SetHWGainFactor() uses gain factors to control sensor gain channels. \n""        These channels can be set independently of each other. \n""        The SetHardwareGain() does not use factors for setting the gain channels, \n""        but standardised values between 0 and 100. The actual gain factor is \n""        sensor-dependent and can be found in the manual.\n""\n""        You can use the is_GetSensorInfo() function to query the available gain controls.\n""        Depending on the time when the gain settings are changed, these changes might \n""        only become effective when the next image is captured.\n""        \n""        Syntax:\n""        =======\n""        \n""        rv=cam.SetHWGainFactor(nMode, nFactor)\n""        \n""        Input Parameters:\n""        =================\n""        \n""        nmode:\n""            - GET_MASTER_GAIN_FACTOR: Returns the master gain factor.\n""            - GET_RED_GAIN_FACTOR: Returns the red channel gain factor.\n""            - GET_GREEN_GAIN_FACTOR: Returns the green channel gain factor.\n""            - GET_BLUE_GAIN_FACTOR: Returns the blue channel gain factor.\n""            - SET_MASTER_GAIN_FACTOR: Sets the master gain factor.\n""            - SET_RED_GAIN_FACTOR: Sets the red channel gain factor.\n""            - SET_GREEN_GAIN_FACTOR: Sets the green channel gain factor.\n""            - SET_BLUE_GAIN_FACTOR: Sets the blue channel gain factor.\n""            - GET_DEFAULT_MASTER_GAIN_FACTOR: Returns the default master gain factor.\n""            - GET_DEFAULT_RED_GAIN_FACTOR: Returns the default red channel gain factor.\n""            - GET_DEFAULT_GREEN_GAIN_FACTOR: Returns the default green channel gain factor.\n""            - GET_DEFAULT_BLUE_GAIN_FACTOR: Returns the default blue channel gain factor.\n""            - INQUIRE_MASTER_GAIN_FACTOR: Converts the index value for the master gain factor.\n""            - INQUIRE_RED_GAIN_FACTOR: Converts the index value for the red channel gain factor.\n""            - INQUIRE_GREEN_GAIN_FACTOR: Converts the index value for the green channel gain factor.\n""            - INQUIRE_BLUE_GAIN_FACTOR: Converts the index value for the blue channel gain factor.\n""        \n""        nFactor: Gain value (100 = gain factor 1, i. e. no effect)\n""        \n""            For converting a gain value from the SetHardwareGain() function, \n""            you can set the nMode parameter to one of the INQUIRE_x_FACTOR values. \n""            In this case, the value range for nFactor is between 0 and 100.\n""            To set the gain using SET_..._GAIN_FACTOR, you must set the nFactor \n""            parameter to an integer value in the range from 100 to the maximum value. \n""            By calling INQUIRE_x_FACTOR and specifying the value 100 for nFactor, \n""            you can query the maximum value. A gain value of 100 means no gain, \n""            a gain value of 200 means gain to the double level (factor 2), etc.\n""            \n""        Return Values:\n""        ==============\n""        rv:\n""            - SUCCESS: Function executed successfully\n""            - NO_SUCCESS: General error message\n""            - Current setting when used together with GET_MASTER_GAIN_FACTOR,\n""              GET_RED_GAIN_FACTOR, GET_GREEN_GAIN_FACTOR, GET_BLUE_GAIN_FACTOR\n""            - Defined setting when used together with SET_MASTER_GAIN_FACTOR,\n""              SET_RED_GAIN_FACTOR, SET_GREEN_GAIN_FACTOR, SET_BLUE_GAIN_FACTOR.\n""            - Default setting when used together with GET_DEFAULT_MASTER_GAIN_FACTOR,\n""              GET_DEFAULT_RED_GAIN_FACTOR, GET_DEFAULT_GREEN_GAIN_FACTOR, \n""              GET_DEFAULT_BLUE_GAIN_FACTOR.\n""            - When used together with INQUIRE_MASTER_GAIN_FACTOR, INQUIRE_RED_GAIN_FACTOR,\n""              INQUIRE_GREEN_GAIN_FACTOR, INQUIRE_BLUE_GAIN_FACTOR Converted gain \n""              index \n""        \n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetHWGainFactor(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_nMode;
  INT __pyx_v_nFactor;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nMode,&__pyx_n_s__nFactor,0};
  __Pyx_RefNannySetupContext("SetHWGainFactor");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nMode);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nFactor);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetHWGainFactor", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetHWGainFactor") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_nMode = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_nMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_nFactor = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_nFactor == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_nMode = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_nMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_nFactor = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_nFactor == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetHWGainFactor", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1107; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetHWGainFactor");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1175
 *         '''
 * 
 *         rv=is_SetHWGainFactor (self.cid, nMode, nFactor)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetHWGainFactor(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nMode, __pyx_v_nFactor)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1176
 * 
 *         rv=is_SetHWGainFactor (self.cid, nMode, nFactor)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1177
 *         rv=is_SetHWGainFactor (self.cid, nMode, nFactor)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def ResetToDefault (self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetHWGainFactor");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1179
 *         return rv
 * 
 *     def ResetToDefault (self):             # <<<<<<<<<<<<<<
 *         ''' Reset parameters to default
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_ResetToDefault(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_ResetToDefault[] = " Reset parameters to default\n        \n        ResetToDefault() resets all parameters to the camera-specific defaults \n        as specified by the driver. By default, the camera uses full resolution, \n        a medium speed and colour level gain values adapted to daylight exposure. \n        All optional features are disabled.\n        \n        Syntax:\n        =======\n        rv=cam.ResetToDefault()\n        \n        Return Values:\n        ==============\n        \n        rv:\n            SUCCESS: Function executed successfully\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_ResetToDefault(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("ResetToDefault");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1198
 *         '''
 * 
 *         rv=is_ResetToDefault (self.cid)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_ResetToDefault(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1198; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1199
 * 
 *         rv=is_ResetToDefault (self.cid)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *     def SetAOI (self, INT type, INT pXPos, INT pYPos, INT pWidth, INT pHeight):
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.ResetToDefault");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1201
 *         self.CheckNoSuccess(rv)
 * 
 *     def SetAOI (self, INT type, INT pXPos, INT pYPos, INT pWidth, INT pHeight):             # <<<<<<<<<<<<<<
 *         ''' Set the area of interest
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetAOI(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetAOI[] = " Set the area of interest\n""        \n""        SetAOI() can be used to set the size and position of an area of \n""        interest (AOI) within an image. The following AOIs can be defined:\n""        \n""        - Image AOI \342\200\223 display of an image portion\n""        - Auto Brightness AOI \342\200\223 reference area of interest for automatic \n""          brightness control\n""        - Auto Whitebalance AOI \342\200\223 reference area of interest of automatic \n""          white balance control\n""        \n""        ** By default, the window size for auto AOIs is always maximum, \n""        i.e. it corresponds to the current image AOI.\n""        After a change to the image geometry (by resetting an image AOI, \n""        by binning or sub-sampling), the auto AOIs will always be reset \n""        to the image AOI value (i.e. to maximum size). This means that it \n""        might be necessary to set the AOIs for the auto features again manually.\n""        \n""        Changes to the image geometry or pixel clock affect the value ranges \n""        of the frame rate and exposure time. After executing SetAOI(), \n""        calling the following functions is recommended in order to keep \n""        the defined camera settings:\n""        \n""        - SetFrameRate()\n""        - SetExposureTime()\n""        - If you are using the uEye's flash function: SetFlashStrobe()**\n""        \n""        Syntax:\n""        =======\n""        XPos, YPos, Width, Height= cam.SetAOI (type, pXPos, pYPos, pWidth, pHeight)\n""        \n""        Input Parameters:\n""        =================\n""        \n""\n""        The pXPos and pYPos parameters represent an offset with respect \n""        to the upper left image corner. The cut window is copied to the \n""        start position in the memory. If you want the image to be copied \n""        to the same offset within the memory, you can link the new position \n""        with a logical OR to the SET_IMAGEPOS_X_ABS and SET_IMAGEPOS_Y_ABS \n""        parameters.\n""    \n""        type:\n""            - SET_IMAGE_AOI: Sets an image AOI.\n""            - GET_IMAGE_AOI: Returns the current image AOI.\n""            - SET_AUTO_BRIGHT_AOI: Sets average AOI values for auto gain and auto shutter.\n""            - GET_AUTO_BRIGHT_AOI: Returns the current auto brightness AOI.\n""            - SET_AUTO_WB_AOI: Sets an auto white balance AOI.\n""            - GET_AUTO_WB_AOI: Returns the current auto white balance AOI.\n""        \n""        XPos: \n""            Horizontal position of the AOI\n""            0...XPosMax| SET_IMAGEPOS_X_ABS: Applies the absolute position to \n""            the memory as well.\n""        \n""        pYPos: \n""            Vertical position of the AOI\n""            0...YPosMax| SET_IMAGEPOS_Y_ABS: Applies the absolute position to \n""            the memory as well.\n""        \n""        pWidth: \n""            Width of the AOI\n""                \n""        pHeight: \n""            Height of the AOI\n""        \n""        Return Values:\n""        ==============\n""        \n""        Returns the actual XPos, YPos, Width, Height, or the cofigured values when \n""        type is GET...\n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetAOI(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_type;
  INT __pyx_v_pXPos;
  INT __pyx_v_pYPos;
  INT __pyx_v_pWidth;
  INT __pyx_v_pHeight;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__type,&__pyx_n_s__pXPos,&__pyx_n_s__pYPos,&__pyx_n_s__pWidth,&__pyx_n_s__pHeight,0};
  __Pyx_RefNannySetupContext("SetAOI");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[5] = {0,0,0,0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
      case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__type);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pXPos);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetAOI", 1, 5, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  2:
      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pYPos);
      if (likely(values[2])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetAOI", 1, 5, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  3:
      values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pWidth);
      if (likely(values[3])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetAOI", 1, 5, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  4:
      values[4] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pHeight);
      if (likely(values[4])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetAOI", 1, 5, 5, 4); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetAOI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_type = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_type == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pXPos = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_pXPos == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pYPos = __Pyx_PyInt_from_py_INT(values[2]); if (unlikely((__pyx_v_pYPos == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pWidth = __Pyx_PyInt_from_py_INT(values[3]); if (unlikely((__pyx_v_pWidth == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pHeight = __Pyx_PyInt_from_py_INT(values[4]); if (unlikely((__pyx_v_pHeight == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_type = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_type == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pXPos = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_pXPos == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pYPos = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 2)); if (unlikely((__pyx_v_pYPos == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pWidth = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 3)); if (unlikely((__pyx_v_pWidth == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pHeight = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 4)); if (unlikely((__pyx_v_pHeight == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetAOI", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetAOI");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1275
 *         '''
 * 
 *         rv= is_SetAOI (self.cid, type, &pXPos, &pYPos, &pWidth, &pHeight)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetAOI(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_type, (&__pyx_v_pXPos), (&__pyx_v_pYPos), (&__pyx_v_pWidth), (&__pyx_v_pHeight))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1276
 * 
 *         rv= is_SetAOI (self.cid, type, &pXPos, &pYPos, &pWidth, &pHeight)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         return pXPos, pYPos, pWidth, pHeight
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1278
 *         self.CheckNoSuccess(rv)
 * 
 *         return pXPos, pYPos, pWidth, pHeight             # <<<<<<<<<<<<<<
 * 
 *     def SetImagePos (self, INT x, INT y):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyInt_to_py_INT(__pyx_v_pXPos); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyInt_to_py_INT(__pyx_v_pYPos); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(__pyx_v_pWidth); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyInt_to_py_INT(__pyx_v_pHeight); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __pyx_t_3 = 0;
  __pyx_t_2 = 0;
  __pyx_t_1 = 0;
  __pyx_t_4 = 0;
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetAOI");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1280
 *         return pXPos, pYPos, pWidth, pHeight
 * 
 *     def SetImagePos (self, INT x, INT y):             # <<<<<<<<<<<<<<
 *         '''Set the image position
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetImagePos(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetImagePos[] = "Set the image position\n""                \n""        SetImagePos() determines the position of an area of interest (AOI) \n""        in the display window. When used together with the is_SetAOI() \n""        function, you can cut out an area of interest of the full video image.\n""\n""        To avoid a positional mismatch between the display area and the image area, \n""        make sure to call the functions in the correct order. Starting from the \n""        original image, it is mandatory to keep to the following order:\n""        \n""        - SetAOI()\n""        - SetImagePos()\n""        \n""        ** With SetAOI(), you can set the position and size of an area of interest \n""        using a single function call.\n""        \n""        Changes to the image geometry or pixel clock affect the value ranges of \n""        the frame rate and exposure time. After executing SetBinning(), \n""        calling the following functions is recommended in order to keep \n""        the defined camera settings:\n""\n""        - SetFrameRate()\n""        - SetExposureTime()\n""        - If you are using the uEye's flash function: SetFlashStrobe()**\n""        \n""        Syntax:\n""        =======\n""        \n""        rv= cam.SetImagePos(x,y)\n""        \n""        Input Parameters:\n""        =================\n""        \n""        The x and y parameters represent an offset with respect to the upper left \n""        image corner. The cut window is copied to the start position in the memory.\n""        If you want the image to be copied to the same offset within the memory, \n""        you can link the new position with a logical OR to the SET_IMAGE_POS_X_ABS \n""        and SET_IMAGE_POS_Y_ABS parameters.\n""        \n""        x:\n""            - 0...xMax: Sets the horizontal position\n""            - 0...xMax | IS_SET_IMAGE_POS_X_ABS: Applies the absolute position \n""              to the memory as well.\n""            - GET_IMAGE_POS_X: Returns the current x position.\n""            - GET_IMAGE_POS_X_MIN: Returns the minimum value for the horizontal \n""              AOI position.\n""            - GET_IMAGE_POS_X_MAX: Returns the maximum value for the horizontal \n""              AOI position.\n""            - GET_IMAGE_POS_X_INC: Returns the increment for the horizontal AOI \n""              position.\n""            - GET_IMAGE_POS_X_ABS: Returns the absolute horizontal position in \n""              the memory.\n""            - GET_IMAGE_POS_Y: Returns the current Y position.\n""            - GET_IMAGE_POS_Y_MIN: Returns the minimum value for the vertical \n""              AOI position.\n""            - GET_IMAGE_POS_Y_MAX: Returns the maximum value for the vertical \n""              AOI position.\n""            - GET_IMAGE_POS_Y_INC: Returns the increment for the vertical AOI \n""              position.\n""            - GET_IMAGE_POS_Y_ABS: Returns the absolute vertical position in the \n""              memory.\n""        \n""        y:\n""            - 0...yMax: Sets the vertical position\n""            - 0...yMax| IS_SET_IMAGE_POS_Y_ABS: Applies the absolute position to \n""              the memory as well.\n""            - 0: When returning settings via parameter x (s. above)\n""        \n""        Return Values:\n""        ==============\n""        \n""        rv:\n""            - SUCCESS: Function executed successfully\n""            - INVALID_PARAMETER: Parameters x or y are invalid  (x, y < 0)\n""            - Current setting when used together with GET_IMAGE_POS parameters\n""            - INVALID_MODE: Camera is in standby mode, function not allowed.\n""        \n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetImagePos(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_x;
  INT __pyx_v_y;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__y,0};
  __Pyx_RefNannySetupContext("SetImagePos");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetImagePos", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetImagePos") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_x = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_x == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_y = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_y == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_x = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_x == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_y = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_y == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetImagePos", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1280; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetImagePos");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1360
 *         '''
 * 
 *         rv= is_SetImagePos (self.cid, x, y)             # <<<<<<<<<<<<<<
 * 
 *         self.CheckNoSuccess(rv)
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetImagePos(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_x, __pyx_v_y)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1362
 *         rv= is_SetImagePos (self.cid, x, y)
 * 
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *     def SetBinning (self, INT mode):
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetImagePos");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1364
 *         self.CheckNoSuccess(rv)
 * 
 *     def SetBinning (self, INT mode):             # <<<<<<<<<<<<<<
 *         ''' Set or get the binning mode
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetBinning(PyObject *__pyx_v_self, PyObject *__pyx_arg_mode); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetBinning[] = " Set or get the binning mode   \n""        \n""        Using SetBinning(), you can enable the binning mode both in horizontal \n""        and in vertical direction. This way, the image size in the binning \n""        direction can be reduced without scaling down the area of interest. \n""        Depending on the sensor used, the sensitivity or the frame rate can be \n""        increased while binning is enabled.\n""\n""        To enable horizontal and vertical binning at the same time, you can \n""        link the horizontal and vertical binning parameters by a logical OR.\n""\n""        The adjustable binning factors of each sensor are listed in the manual.\n""        \n""        ** Some sensors allow a higher pixel clock setting if binning or \n""        subsampling has been activated. If you set a higher pixel clock \n""        and then reduce the binning/subsampling factors again, the driver will \n""        automatically select the highest possible pixel clock for the new settings.\n""        \n""        Changes to the image geometry or pixel clock affect the value ranges of \n""        the frame rate and exposure time. After executing SetBinning(), \n""        calling the following functions is recommended in order to keep \n""        the defined camera settings:\n""\n""        - SetFrameRate()\n""        - SetExposureTime()\n""        - If you are using the uEye's flash function: SetFlashStrobe()\n""        \n""        Syntax:\n""        =======\n""        rv=cam.SetBinning(mode)\n""        \n""        Input Parameters:\n""        =================\n""        mode:\n""            - BINNING_DISABLE: Disables binning.\n""            - BINNING_2X_VERTICAL: Enables vertical binning with factor 2.\n""            - BINNING_3X_VERTICAL: Enables vertical binning with factor 3.\n""            - BINNING_4X_VERTICAL: Enables vertical binning with factor 4.\n""            - BINNING_6X_VERTICAL: Enables vertical binning with factor 6.\n""            - BINNING_2X_HORIZONTAL: Enables horizontal binning with factor 2.\n""            - BINNING_3X_HORIZONTAL: Enables horizontal binning with factor 3.\n""            - BINNING_4X_HORIZONTAL: Enables horizontal binning with factor 4.\n""            - BINNING_6X_HORIZONTAL: Enables horizontal binning with factor 6.\n""            - GET_BINNING: Returns the current setting.\n""            - GET_BINNING_FACTOR_VERTICAL: Returns the vertical binning factor.\n""            - GET_BINNING_FACTOR_HORIZONTAL: Returns the horizontal binning factor.\n""            - GET_SUPPORTED_BINNING: Returns the supported binning modes.\n""            - GET_BINNING_TYPE: Indicates whether the camera uses colour-proof binning \n""              (IS_BINNING_COLOR) or not (IS_BINNING_MONO).\n""            \n""        Return Values:\n""        ==============\n""        \n""        rv:\n""            - SUCCESS: Function executed successfully\n""            - Current setting when used together with GET_BINNING, \n""              GET_BINNING_FACTOR_VERTICAL, GET_BINNING_FACTOR_HORIZONTAL\n""            - When used with GET_BINNING_TYPE returns BINNING_COLOR if the camera \n""              uses colour-proof subsampling, otherwise BINNING_MONO is returned.\n""            - When used with GET_SUPPORTED_BINNING, returns the supported \n""              subsampling modes linked by logical ORs.\n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetBinning(PyObject *__pyx_v_self, PyObject *__pyx_arg_mode) {
  INT __pyx_v_mode;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetBinning");
  assert(__pyx_arg_mode); {
    __pyx_v_mode = __Pyx_PyInt_from_py_INT(__pyx_arg_mode); if (unlikely((__pyx_v_mode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1364; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetBinning");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1428
 *         '''
 * 
 *         rv=is_SetBinning (self.cid, mode)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetBinning(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_mode)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1428; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1429
 * 
 *         rv=is_SetBinning (self.cid, mode)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1430
 *         rv=is_SetBinning (self.cid, mode)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetRopEffect (self, INT effect, INT param):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetBinning");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1432
 *         return rv
 * 
 *     def SetRopEffect (self, INT effect, INT param):             # <<<<<<<<<<<<<<
 *         '''Set or get ROP effect
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetRopEffect(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetRopEffect[] = "Set or get ROP effect\n\n        SetRopEffect() enables functions for real-time image geometry \n        modification (Rop = raster operation).\n        \n        Syntax:\n        =======\n        \n        rv=cam.SetRopEffect(effect, param)\n        \n        Input Parameters:\n        =================\n        \n        effect:\n            - SET_ROP_MIRROR_UPDOWN: Mirrors the image along the horizontal axis.\n            - SET_ROP_MIRROR_LEFTRIGHT: Mirrors the image along the vertical axis.\n              Depending on the sensor, this operation is performed in the camera \n              or in the PC software.\n            - GET_ROP_EFFECT: Returns the current settings.\n\n        param: \n            Turns the Rop effect on / off. 0 = Turn off , 1 = Turn on\n\n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n            - NO_SUCCESS: General error message\n            - Current setting when used together with SET_ROP_EFFECT\n            - INVALID_MODE: Camera is in standby mode, function not allowed.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetRopEffect(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_effect;
  INT __pyx_v_param;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__effect,&__pyx_n_s__param,0};
  __Pyx_RefNannySetupContext("SetRopEffect");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__effect);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__param);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetRopEffect", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetRopEffect") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_effect = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_effect == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_param = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_param == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_effect = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_effect == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_param = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_param == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetRopEffect", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetRopEffect");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1467
 *         '''
 * 
 *         rv= is_SetRopEffect (self.cid, effect,param, 0)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetRopEffect(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_effect, __pyx_v_param, 0)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1468
 * 
 *         rv= is_SetRopEffect (self.cid, effect,param, 0)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1468; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1468; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1468; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1469
 *         rv= is_SetRopEffect (self.cid, effect,param, 0)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetSubSampling (self, INT mode):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetRopEffect");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1471
 *         return rv
 * 
 *     def SetSubSampling (self, INT mode):             # <<<<<<<<<<<<<<
 *         '''Set or get subsampling
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetSubSampling(PyObject *__pyx_v_self, PyObject *__pyx_arg_mode); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetSubSampling[] = "Set or get subsampling\n""        \n""        Using SetSubSampling(), you can enable sub-sampling mode both in horizontal \n""        and in vertical directions. This allows you to reduce the image size \n""        in the sub-sampling direction without scaling down the area of interest. \n""        In order to simultaneously enable horizontal and vertical sub-sampling, \n""        the horizontal and vertical sub-sampling parameters can by linked \n""        by a logical OR. Some monochrome sensors are limited by their design \n""        to mere colour sub-sampling. In case of fine image structures, \n""        this can result in slight artifacts. The adjustable sub-sampling \n""        factors of each sensor are listed in the manual.\n""        ** Some sensors allow a higher pixel clock setting if binning or \n""        subsampling has been activated. If you set a higher pixel clock \n""        and then reduce the binning/subsampling factors again, \n""        the driver will automatically select the highest possible pixel \n""        clock for the new settings.\n""        Changes to the image geometry or pixel clock affect the value ranges \n""        of the frame rate and exposure time. After executing SetBinning(), \n""        calling the following functions is recommended in order to keep \n""        the defined camera settings:\n""        \n""        - SetFrameRate()\n""        - SetExposureTime()\n""        - If you are using the uEye's flash function: SetFlashStrobe()\n""        \n""        Syntax:\n""        =======\n""        \n""        rv=cam.SetSubSampling(mode)\n""        \n""        Input Parameters:\n""        =================\n""        \n""        mode:\n""            - SUBSAMPLING_DISABLE: Disables sub-sampling.\n""            - SUBSAMPLING_2X_VERTICAL: Enables vertical sub-sampling with factor 2.\n""            - SUBSAMPLING_3X_VERTICAL: Enables vertical sub-sampling with factor 3.\n""            - SUBSAMPLING_4X_VERTICAL: Enables vertical sub-sampling with factor 4.\n""            - SUBSAMPLING_5X_VERTICAL: Enables vertical sub-sampling with factor 5.\n""            - SUBSAMPLING_6X_VERTICAL: Enables vertical sub-sampling with factor 6.\n""            - SUBSAMPLING_8X_VERTICAL: Enables vertical sub-sampling with factor 8.\n""            - SUBSAMPLING_16X_VERTICAL: Enables vertical sub-sampling with factor 16.\n""            - SUBSAMPLING_2X_HORIZONTAL: Enables horizontal sub-sampling with factor 2.\n""            - SUBSAMPLING_3X_HORIZONTAL: Enables horizontal sub-sampling with factor 3.\n""            - SUBSAMPLING_4X_HORIZONTAL: Enables horizontal sub-sampling with factor 4.\n""            - SUBSAMPLING_5X_HORIZONTAL: Enables horizontal sub-sampling with factor 5.\n""            - SUBSAMPLING_6X_HORIZONTAL: Enables horizontal sub-sampling with factor 6.\n""            - SUBSAMPLING_8X_HORIZONTAL: Enables horizontal sub-sampling with factor 8.\n""            - SUBSAMPLING_16X_HORIZONTAL: Enables horizontal sub-sampling with factor 16.\n""            - GET_SUBSAMPLING: Returns the current setting.\n""            - GET_SUBSAMPLING_FACTOR_VERTICAL: Returns the vertical sub-sampling factor\n""            - GET_SUBSAMPLING_FACTOR_HORIZONTAL: Returns the horizontal sub-sampling factor\n""            - GET_SUBSAMPLING_TYPE: Indicates whether the camera uses colour-proof sub-sampling.\n""            - GET_SUPPORTED_SUBSAMPLING: Returns the supported sub-sampling modes.\n""                \n""        Return Values:\n""        ==============\n""        \n""        rv:\n""            - SUCCESS: Function executed successfully\n""            - NO_SUCCESS: General error message\n""            - Current setting when used together with GET_SUBSAMPLING\n""            - When used with GET_SUBSAMPLING_TYPE returns SUBSAMPLING_COLOR \n""              if the camera uses colour-proof sub-sampling, else SUBSAMPLING_MONO \n""            - When used with GET_SUPPORTED_SUBSAMPLING returns the supported \n""              sub-sampling modes linked by logical ORs      \n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetSubSampling(PyObject *__pyx_v_self, PyObject *__pyx_arg_mode) {
  INT __pyx_v_mode;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetSubSampling");
  assert(__pyx_arg_mode); {
    __pyx_v_mode = __Pyx_PyInt_from_py_INT(__pyx_arg_mode); if (unlikely((__pyx_v_mode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1471; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetSubSampling");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1540
 *         '''
 * 
 *         rv=is_SetSubSampling (self.cid, mode)             # <<<<<<<<<<<<<<
 * 
 *         self.CheckNoSuccess(rv)
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetSubSampling(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_mode)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1542
 *         rv=is_SetSubSampling (self.cid, mode)
 * 
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1543
 * 
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def GetTimeout (self, UINT nMode):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetSubSampling");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1545
 *         return rv
 * 
 *     def GetTimeout (self, UINT nMode):             # <<<<<<<<<<<<<<
 *         '''Get user defined timeout
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetTimeout(PyObject *__pyx_v_self, PyObject *__pyx_arg_nMode); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetTimeout[] = "Get user defined timeout\n        \n        Using GetTimeout(), you can read out user-defined timeout values from the uEye API.\n        \n        Syntax:\n        =======\n        \n        pTimeout=cam.GetTimeout(nMode)\n        \n        Input Parameters:\n        =================\n        \n        nMode: \n            Selects the timeout value to be returned\n            - TRIGGER_TIMEOUT: Returns the timeout value in ms for triggered \n              image capture\n        \n            \n        Return Values:\n        ==============\n        \n        pTimeout:\n            Timeout value. Returns 0 if the default value of the uEye API is used.\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetTimeout(PyObject *__pyx_v_self, PyObject *__pyx_arg_nMode) {
  UINT __pyx_v_nMode;
  UINT __pyx_v_pTimeout;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("GetTimeout");
  assert(__pyx_arg_nMode); {
    __pyx_v_nMode = __Pyx_PyInt_from_py_UINT(__pyx_arg_nMode); if (unlikely((__pyx_v_nMode == (UINT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1545; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.GetTimeout");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1571
 *         '''
 *         cdef UINT pTimeout
 *         rv= is_GetTimeout (self.cid, nMode, & pTimeout)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return pTimeout
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetTimeout(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nMode, (&__pyx_v_pTimeout))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1572
 *         cdef UINT pTimeout
 *         rv= is_GetTimeout (self.cid, nMode, & pTimeout)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return pTimeout
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1573
 *         rv= is_GetTimeout (self.cid, nMode, & pTimeout)
 *         self.CheckNoSuccess(rv)
 *         return pTimeout             # <<<<<<<<<<<<<<
 * 
 *     def SetTimeout (self, UINT nMode, UINT Timeout):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyInt_to_py_UINT(__pyx_v_pTimeout); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.GetTimeout");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1575
 *         return pTimeout
 * 
 *     def SetTimeout (self, UINT nMode, UINT Timeout):             # <<<<<<<<<<<<<<
 *         '''Set timeout value
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetTimeout(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetTimeout[] = "Set timeout value\n        \n        Using SetTimeout(), you can change user-defined timeout values of \n        the uEye API. If no user-defined timeout is set, the default value \n        of the uEye  API is used for the relevant timeout.\n\n        ** The user-defined timeout only applies to the specified camera \n        at runtime of the program. **\n        \n        Syntax:\n        =======\n        \n        rv=cam.SetTimeout(nMode, Timeout)\n        \n        Input Parameters:\n        =================\n        nMode: \n            Selects the timeout value to be set\n            - TRIGGER_TIMEOUT: Sets the timeout value for triggered image capture\n            \n        Timeout: \n            Timeout value in 10 ms. Value range [0; 4...429496729] \n            (corresponds to 40 ms to approx. 1193 hours) 0 = use default value \n            of the uEye API, For 1...3, the value 4 is used.\n        \n        Return Values:\n        SUCCESS: Function executed successfully\n   \n        NOT_SUPPORTED: The value for nMode is invalid\n                \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetTimeout(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  UINT __pyx_v_nMode;
  UINT __pyx_v_Timeout;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nMode,&__pyx_n_s__Timeout,0};
  __Pyx_RefNannySetupContext("SetTimeout");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nMode);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__Timeout);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetTimeout", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetTimeout") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_nMode = __Pyx_PyInt_from_py_UINT(values[0]); if (unlikely((__pyx_v_nMode == (UINT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_Timeout = __Pyx_PyInt_from_py_UINT(values[1]); if (unlikely((__pyx_v_Timeout == (UINT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_nMode = __Pyx_PyInt_from_py_UINT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_nMode == (UINT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_Timeout = __Pyx_PyInt_from_py_UINT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_Timeout == (UINT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetTimeout", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetTimeout");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __Pyx_INCREF((PyObject *)__pyx_v_self);
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1608
 *         '''
 * 
 *         rv=is_SetTimeout (self.cid, nMode, Timeout)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         if  rv!= IS_SUCCESS:
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetTimeout(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nMode, __pyx_v_Timeout)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1609
 * 
 *         rv=is_SetTimeout (self.cid, nMode, Timeout)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         if  rv!= IS_SUCCESS:
 *             raise Exception("Could not set timeout")
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1610
 *         rv=is_SetTimeout (self.cid, nMode, Timeout)
 *         self.CheckNoSuccess(rv)
 *         if  rv!= IS_SUCCESS:             # <<<<<<<<<<<<<<
 *             raise Exception("Could not set timeout")
 *         return rv
 */
  __pyx_t_3 = PyInt_FromLong(IS_SUCCESS); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_rv, __pyx_t_3, Py_NE); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1611
 *         self.CheckNoSuccess(rv)
 *         if  rv!= IS_SUCCESS:
 *             raise Exception("Could not set timeout")             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(((PyObject *)__pyx_kp_s_4));
    PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_kp_s_4));
    __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_4));
    __pyx_t_3 = PyObject_Call(__pyx_builtin_Exception, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1612
 *         if  rv!= IS_SUCCESS:
 *             raise Exception("Could not set timeout")
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def CaptureVideo (self, INT Wait):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetTimeout");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_DECREF((PyObject *)__pyx_v_self);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1614
 *         return rv
 * 
 *     def CaptureVideo (self, INT Wait):             # <<<<<<<<<<<<<<
 *         '''Capture Video
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_CaptureVideo(PyObject *__pyx_v_self, PyObject *__pyx_arg_Wait); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_CaptureVideo[] = "Capture Video\n        \n        CaptureVideo() digitises video images in real time and transfers \n        the images to an allocated image memory or, if Direct3D is used, \n        to the graphics card. The image data (DIB mode) is stored in the \n        memory created using AllocImageMem() and designated as active image \n        memory using SetImageMem(). Using GetImageMem(), you can query \n        the memory address. If ring buffering is used, the image capturing \n        function cycles through all image memories used for storing the \n        images of a capture sequence in an endless loop. Sequence memories \n        locked by LockSeqBuf() will be skipped. If the last available sequence \n        memory has been filled, the sequence event or message will be triggered. \n        Capturing always starts with the first element of the sequence.\n        \n        Syntax:\n        =======\n        \n        rv=cam.CaptureVideo(Wait)\n             \n        \n        Input Parameters:\n        =================\n        \n        Wait:\n            - DONT_WAIT:\n            - WAIT: \n            - Time t:\n            \n            Timeout value for image capture  (see also the How To Proceed: \n            Timeout Values for Image Capture section of manual)\n            - GET_LIVE: Returns if live capture is enabled.   \n        \n        Return Values:\n        ==============\n        rv:\n            - SUCCESS: Function executed successfully\n            - When used with GET_LIVE: TRUE if live capture is enabled\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_CaptureVideo(PyObject *__pyx_v_self, PyObject *__pyx_arg_Wait) {
  INT __pyx_v_Wait;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("CaptureVideo");
  assert(__pyx_arg_Wait); {
    __pyx_v_Wait = __Pyx_PyInt_from_py_INT(__pyx_arg_Wait); if (unlikely((__pyx_v_Wait == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1614; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.CaptureVideo");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1655
 *         '''
 * 
 *         rv=is_CaptureVideo (self.cid, Wait)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_CaptureVideo(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_Wait)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1655; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1656
 * 
 *         rv=is_CaptureVideo (self.cid, Wait)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1656; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1656; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1656; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1657
 *         rv=is_CaptureVideo (self.cid, Wait)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def FreezeVideo (self, INT Wait):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.CaptureVideo");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1659
 *         return rv
 * 
 *     def FreezeVideo (self, INT Wait):             # <<<<<<<<<<<<<<
 *         ''' Freeze video capture
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_FreezeVideo(PyObject *__pyx_v_self, PyObject *__pyx_arg_Wait); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_FreezeVideo[] = " Freeze video capture\n        \n        FreezeVideo() acquires a single image from the camera. In DIB mode, \n        the image is stored in the active image memory. If ring buffering \n        is used in DIB mode, the captured image is transferred to the next \n        available image memory of the sequence. Once the last available \n        sequence memory has been filled, the sequence event or message \n        will be triggered.\n\n        In Direct3D mode, the is directly copied to the graphics card buffer \n        and then displayed.\n\n        Image capture will be started by a trigger if you previously enabled \n        the trigger mode using SetExternalTrigger(). A hardware triggered \n        image acquisition can be cancelled using StopLiveVideo() if exposure \n        has not started yet.\n        \n        Syntax:\n        =======\n        rv=FreezeVideo(Wait)\n        \n        Input Parameters:\n        =================\n        Wait:\n            - DONT_WAIT: \n            - WAIT\n            - Time t\n\n            Timeout value for image capture (see also the How To Proceed: \n            Timeout Values for Image Capture section in the manual)\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_FreezeVideo(PyObject *__pyx_v_self, PyObject *__pyx_arg_Wait) {
  INT __pyx_v_Wait;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("FreezeVideo");
  assert(__pyx_arg_Wait); {
    __pyx_v_Wait = __Pyx_PyInt_from_py_INT(__pyx_arg_Wait); if (unlikely((__pyx_v_Wait == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1659; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.FreezeVideo");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1699
 *         '''
 * 
 *         rv=is_FreezeVideo (self.cid, Wait)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_FreezeVideo(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_Wait)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1699; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1700
 * 
 *         rv=is_FreezeVideo (self.cid, Wait)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *     def StopLiveVideo (self, INT Wait):
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1700; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1700; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1700; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.FreezeVideo");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1702
 *         self.CheckNoSuccess(rv)
 * 
 *     def StopLiveVideo (self, INT Wait):             # <<<<<<<<<<<<<<
 *         '''Stop Live Video
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_StopLiveVideo(PyObject *__pyx_v_self, PyObject *__pyx_arg_Wait); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_StopLiveVideo[] = "Stop Live Video\n                  \n        StopLiveVideo() stops live mode or cancels a hardware triggered image \n        capture in case the exposure has not yet started.\n        \n        Syntax:\n        =======\n        \n        rv=cam.StopLiveVideo(Wait)\n        \n        Input Parameters:\n        =================\n        \n        Wait:\n            - WAIT: The function waits until the image save is complete.\n            - DONT_WAIT:The function returns immediately. Digitising the image \n              is completed in the background.\n            - FORCE_VIDEO_STOP: Digitising is stopped immediately.\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_StopLiveVideo(PyObject *__pyx_v_self, PyObject *__pyx_arg_Wait) {
  INT __pyx_v_Wait;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("StopLiveVideo");
  assert(__pyx_arg_Wait); {
    __pyx_v_Wait = __Pyx_PyInt_from_py_INT(__pyx_arg_Wait); if (unlikely((__pyx_v_Wait == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1702; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.StopLiveVideo");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1729
 *         '''
 * 
 *         rv= is_StopLiveVideo (self.cid, Wait)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_StopLiveVideo(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_Wait)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1729; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1730
 * 
 *         rv= is_StopLiveVideo (self.cid, Wait)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1731
 *         rv= is_StopLiveVideo (self.cid, Wait)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetExternalTrigger (self, INT nTriggerMode):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.StopLiveVideo");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1733
 *         return rv
 * 
 *     def SetExternalTrigger (self, INT nTriggerMode):             # <<<<<<<<<<<<<<
 *         '''Set External Triger
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetExternalTrigger(PyObject *__pyx_v_self, PyObject *__pyx_arg_nTriggerMode); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetExternalTrigger[] = "Set External Triger\n""        \n""        Using SetExternalTrigger(), you can activate the trigger mode.\n""        If the camera is in standby mode, it quits this mode and activates \n""        trigger mode.\n""\n""        In hardware trigger mode, image capture is delayed for each function \n""        call until the selected trigger event has occurred.\n""        \n""        In software trigger mode, an image is captured immediately when \n""        FreezeVideo() is called, or a continuous triggered capture is started \n""        when CaptureVideo() is called. In hardware trigger mode, you can \n""        use the ForceTrigger() command to trigger an image capture even if \n""        no electric signal is present.\n""\n""        When you disable the trigger functionality, you can statically \n""        query the signal level at the trigger input. This option causes \n""        the camera to change to freerun mode.\n""        \n""        ** For hardware reasons, the board-level versions of the USB uEye LE \n""        cameras can only be triggered on the falling edge.**\n""        \n""        Syntax:\n""        =======\n""        \n""        rv=cam.SetExternalTrigger(nTriggerMode)\n""        \n""        Input Parameters:\n""        =================\n""        +--------------------------+-------------------+-----------------------+\n""        |nTriggerMode              |  Trigger mode     |    Trigger event      |\n""        +--------------------------+-------------------+-----------------------+\n""        |SET_TRIGGER_OFF           |  Off              |          -            |    \n""        +--------------------------+-------------------+-----------------------+\n""        |SET_TRIGGER_HI_LO         |  Hardware trigger |  Falling signal edge  | \n""        +--------------------------+-------------------+-----------------------+\n""        |SET_TRIGGER_LO_HI         |  Hardware trigger |  Rising signal edge   |\n""        +--------------------------+-------------------+-----------------------+\n""        |SET_TRIGGER_HI_LO_SYNC    | Freerun sync./    | Falling signal edge   |\n""        |                          | hardware trigger* |                       |\n""        +--------------------------+-------------------+-----------------------+\n""        |SET_TRIGGER_LO_HI_SYNC    | Freerun sync./    | Rising signal edge    |\n""        |                          |  hardware trigger*|                       |\n""        +--------------------------+-------------------+-----------------------+\n""        |IS_SET_TRIGGER_SOFTWARE   |Software trigger   |Call of FreezeVideo()  |\n""        |                          |                   |(single frame mode)    |\n""        |                          |                   |Call of CaptureVideo() |\n""        |                          |                   |(continuous mode)      |\n""        +--------------------------+-------------------+-----------------------+\n""        \n""        +--------------------------+-------------------------------------------+\n""        |GET_EXTERNALTRIGGER       |Returns the trigger mode setting           |\n""        +--------------------------+-------------------------------------------+\n""        |GET_TRIGGER_STATUS        |Returns the current signal level at the    |\n""        |                          |trigger input                              |\n""        +--------------------------+-------------------------------------------+\n""        |GET_SUPPORTED_TRIGGER_MODE| Returns the supported trigger modes       |              |\n""        +--------------------------+-------------------------------------------+\n""\n""        * The freerun synchronisation mode is currently only supported by the \n""        UI-146x/546x series sensors.\n""        \n""        Return Values:\n""        ==============\n""        \n""        rv:\n""            - SUCCESS: Function executed successfully\n""            - Current setting when used together with GET_EXTERNALTRIGGER\n""            - When used with GET_TRIGGER_STATUS: Returns the current signal \n""              level at the trigger input\n""            - When used with GET_SUPPORTED_TRIGGER_MODE: Returns the supported \n""              modes linked by logical ORs\n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetExternalTrigger(PyObject *__pyx_v_self, PyObject *__pyx_arg_nTriggerMode) {
  INT __pyx_v_nTriggerMode;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetExternalTrigger");
  assert(__pyx_arg_nTriggerMode); {
    __pyx_v_nTriggerMode = __Pyx_PyInt_from_py_INT(__pyx_arg_nTriggerMode); if (unlikely((__pyx_v_nTriggerMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1733; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetExternalTrigger");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1808
 *         '''
 * 
 *         rv=is_SetExternalTrigger (self.cid, nTriggerMode)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetExternalTrigger(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nTriggerMode)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1809
 * 
 *         rv=is_SetExternalTrigger (self.cid, nTriggerMode)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1810
 *         rv=is_SetExternalTrigger (self.cid, nTriggerMode)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def ForceTrigger (self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetExternalTrigger");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1812
 *         return rv
 * 
 *     def ForceTrigger (self):             # <<<<<<<<<<<<<<
 *         ''' Force Trigger
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_ForceTrigger(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_ForceTrigger[] = " Force Trigger \n        \n        You can use ForceTrigger() to force a software-controlled capture\n        of an image while a capturing process triggered by hardware is in progress.\n        This function can only be used if the triggered capturing process was \n        started using the DONE_WAIT parameter.\n        \n        \n        Syntax:\n        =======\n        rv= cam.ForceTrigger()\n        \n        Return Values:\n        ==============\n        rv:\n            - SUCCESS: Function executed successfully\n    \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_ForceTrigger(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("ForceTrigger");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1831
 * 
 *         '''
 *         rv=is_ForceTrigger (self.cid)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_ForceTrigger(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1832
 *         '''
 *         rv=is_ForceTrigger (self.cid)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *     #~def
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.ForceTrigger");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1837
 *     #INT is_GetCaptureErrorInfo (self.cid, UEYE_CAPTURE_ERROR_INFO* CaptureErrorInfo,UINT SizeCaptureErrorInfo)
 * 
 *     def LoadBadPixelCorrectionTable (self, char* File):             # <<<<<<<<<<<<<<
 *         '''Load bad pixel correction table
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_LoadBadPixelCorrectionTable(PyObject *__pyx_v_self, PyObject *__pyx_arg_File); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_LoadBadPixelCorrectionTable[] = "Load bad pixel correction table\n        \n        LoadBadPixelCorrectionTable() loads a list of sensor hot pixel coordinates \n        that was previously saved using the SaveBadPixelCorrectionTable() function.\n        \n        \n        Syntax:\n        =======\n        rv=cam.LoadBadPixelCorrectionTable (File)\n        \n        Input Values:\n        =============\n        \n        File: \n            string which contains the name of the file where the coordinates are\n            stored. You can either pass an absolute or a relative path.\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_LoadBadPixelCorrectionTable(PyObject *__pyx_v_self, PyObject *__pyx_arg_File) {
  char *__pyx_v_File;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("LoadBadPixelCorrectionTable");
  assert(__pyx_arg_File); {
    __pyx_v_File = __Pyx_PyBytes_AsString(__pyx_arg_File); if (unlikely((!__pyx_v_File) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1837; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.LoadBadPixelCorrectionTable");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1863
 *         '''
 * 
 *         rv= is_LoadBadPixelCorrectionTable (self.cid, File)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_LoadBadPixelCorrectionTable(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_File)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1863; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1864
 * 
 *         rv= is_LoadBadPixelCorrectionTable (self.cid, File)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1864; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1864; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1864; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1865
 *         rv= is_LoadBadPixelCorrectionTable (self.cid, File)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SaveBadPixelCorrectionTable (self, char* File):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.LoadBadPixelCorrectionTable");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1867
 *         return rv
 * 
 *     def SaveBadPixelCorrectionTable (self, char* File):             # <<<<<<<<<<<<<<
 *         '''Save bad pixel correction table
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SaveBadPixelCorrectionTable(PyObject *__pyx_v_self, PyObject *__pyx_arg_File); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SaveBadPixelCorrectionTable[] = "Save bad pixel correction table\n        \n        SaveBadPixelCorrectionTable() saves the user-defined hot pixel list \n        to the specified file.\n        \n        \n        Syntax:\n        =======\n        \n        rv=cam.SaveBadPixelCorrectionTable( File) \n        \n        Input Values:\n        =============\n        \n        File: \n            String which contains the name of the file where the coordinates are \n            stored. You can either pass an absolute or a relative path.\n\n        Return Values:\n        ==============\n        \n        rv:\n            SUCCESS: Function executed successfully\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SaveBadPixelCorrectionTable(PyObject *__pyx_v_self, PyObject *__pyx_arg_File) {
  char *__pyx_v_File;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SaveBadPixelCorrectionTable");
  assert(__pyx_arg_File); {
    __pyx_v_File = __Pyx_PyBytes_AsString(__pyx_arg_File); if (unlikely((!__pyx_v_File) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1867; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SaveBadPixelCorrectionTable");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1893
 *         '''
 * 
 *         rv= is_SaveBadPixelCorrectionTable (self.cid, File)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SaveBadPixelCorrectionTable(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_File)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1893; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1894
 * 
 *         rv= is_SaveBadPixelCorrectionTable (self.cid, File)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1894; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1894; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1894; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1895
 *         rv= is_SaveBadPixelCorrectionTable (self.cid, File)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetBadPixelCorrection (self, INT nEnable, INT threshold):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SaveBadPixelCorrectionTable");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1897
 *         return rv
 * 
 *     def SetBadPixelCorrection (self, INT nEnable, INT threshold):             # <<<<<<<<<<<<<<
 *         '''Set bad pixel correction table
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetBadPixelCorrection(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetBadPixelCorrection[] = "Set bad pixel correction table\n        \n        SetBadPixelCorrection() enables/disables the software correction \n        of sensor hot pixels.\n        \n        Syntax:\n        =======\n        \n        rv=SetBadPixelCorrection (nEnable, threshold)\n        \n        Input Values:\n        =============\n        \n        nEnable:\n            - BPC_DISABLE: Disables the correction function.\n            - BPC_ENABLE_SOFTWARE: Enables software correction based on the hot \n              pixel list stored in the EEPROM.\n            - BPC_ENABLE_USER: Enables software correction based on user-defined \n              values. First, the SetBadPixelCorrectionTable() function must be called.\n            - GET_BPC_MODE: Returns the current mode.\n            - GET_BPC_THRESHOLD: Returns the current threshold value.\n        \n        threshold: Currently not used\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n            - Current mode when used in connection with GET_BPC_MODE\n            - Current threshold value when used in connection with GET_BPC_THRESHOLD\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetBadPixelCorrection(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_nEnable;
  INT __pyx_v_threshold;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nEnable,&__pyx_n_s__threshold,0};
  __Pyx_RefNannySetupContext("SetBadPixelCorrection");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nEnable);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__threshold);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetBadPixelCorrection", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetBadPixelCorrection") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_nEnable = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_nEnable == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_threshold = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_threshold == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_nEnable = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_nEnable == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_threshold = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_threshold == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetBadPixelCorrection", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetBadPixelCorrection");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1932
 *         '''
 * 
 *         rv=is_SetBadPixelCorrection (self.cid, nEnable, threshold)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetBadPixelCorrection(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nEnable, __pyx_v_threshold)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1933
 * 
 *         rv=is_SetBadPixelCorrection (self.cid, nEnable, threshold)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1933; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1933; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1933; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1934
 *         rv=is_SetBadPixelCorrection (self.cid, nEnable, threshold)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetBadPixelCorrectionTable (self, INT nMode, list pixList):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetBadPixelCorrection");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":1936
 *         return rv
 * 
 *     def SetBadPixelCorrectionTable (self, INT nMode, list pixList):             # <<<<<<<<<<<<<<
 *         '''Set or get the bad pixel correction table.
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetBadPixelCorrectionTable(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetBadPixelCorrectionTable[] = "Set or get the bad pixel correction table.\n          \n        This method can be used to set the table containing the hot pixel \n        positions which will be used by the user-defined hot pixel correction \n        function. You can enable hot pixel correction by calling \n        self.SetBadPixelCorrection(). Each value in List consists of an \n        integer number. The coordinates are listed first X, then Y.\n        \n        A table with 3 hot pixels must contain 6 values and will be \n        structured as follows:\n\n        X1 - Y1 - X2 - Y2 - X3 - Y3 \n\n        Syntax:\n        =======\n        \n        rl=cam.SetBadPixelCorrectionTable (nMode, pixList):\n        \n        Input Parameters:\n        =================\n        nMode:\n            - SET_BADPIXEL_LIST: Sets a new user-defined list. The List parameter \n              contains the data using the format described above.\n            - GET_BADPIXEL_LIST: Returns a python list containig the previously \n              user-defined hot pixel list. In this case List is not used.\n            \n        pixList: \n            List containing the the hot pixel table, using the format described \n            above\n\n        Return Values:\n        ==============\n        \n        rl:\n            A a python list containig the user-defined hot pixel list.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetBadPixelCorrectionTable(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_nMode;
  PyObject *__pyx_v_pixList = 0;
  WORD *__pyx_v_pList;
  PyObject *__pyx_v_n;
  PyObject *__pyx_v_i;
  PyObject *__pyx_v_d;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_v_rl;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  size_t __pyx_t_6;
  WORD __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nMode,&__pyx_n_s__pixList,0};
  __Pyx_RefNannySetupContext("SetBadPixelCorrectionTable");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nMode);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pixList);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetBadPixelCorrectionTable", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1936; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetBadPixelCorrectionTable") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1936; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_nMode = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_nMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1936; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pixList = ((PyObject *)values[1]);
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_nMode = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_nMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1936; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_pixList = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 1));
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetBadPixelCorrectionTable", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1936; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetBadPixelCorrectionTable");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __Pyx_INCREF((PyObject *)__pyx_v_self);
  __Pyx_INCREF(__pyx_v_pixList);
  __pyx_v_n = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_i = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_d = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_rl = Py_None; __Pyx_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_pixList), &PyList_Type, 1, "pixList", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1936; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1977
 *         cdef WORD * pList
 * 
 *         if nMode==IS_SET_BADPIXEL_LIST:             # <<<<<<<<<<<<<<
 *             n=len(pixList)
 *             assert n%2==0, "Table lenght must be even"
 */
  __pyx_t_1 = (__pyx_v_nMode == IS_SET_BADPIXEL_LIST);
  if (__pyx_t_1) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1978
 * 
 *         if nMode==IS_SET_BADPIXEL_LIST:
 *             n=len(pixList)             # <<<<<<<<<<<<<<
 *             assert n%2==0, "Table lenght must be even"
 *             pList= <WORD *>malloc((n+1)*sizeof(WORD))
 */
    __pyx_t_2 = PyObject_Length(((PyObject *)__pyx_v_pixList)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_v_n);
    __pyx_v_n = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1979
 *         if nMode==IS_SET_BADPIXEL_LIST:
 *             n=len(pixList)
 *             assert n%2==0, "Table lenght must be even"             # <<<<<<<<<<<<<<
 *             pList= <WORD *>malloc((n+1)*sizeof(WORD))
 *             pList[0]=n/2
 */
    #ifndef PYREX_WITHOUT_ASSERTIONS
    __pyx_t_3 = PyNumber_Remainder(__pyx_v_n, __pyx_int_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_int_0, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_1)) {
      PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    #endif

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1980
 *             n=len(pixList)
 *             assert n%2==0, "Table lenght must be even"
 *             pList= <WORD *>malloc((n+1)*sizeof(WORD))             # <<<<<<<<<<<<<<
 *             pList[0]=n/2
 * 
 */
    __pyx_t_4 = PyNumber_Add(__pyx_v_n, __pyx_int_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1980; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyInt_FromSize_t((sizeof(WORD))); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1980; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PyNumber_Multiply(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1980; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_6 = __Pyx_PyInt_AsSize_t(__pyx_t_5); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1980; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_pList = ((WORD *)malloc(__pyx_t_6));

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1981
 *             assert n%2==0, "Table lenght must be even"
 *             pList= <WORD *>malloc((n+1)*sizeof(WORD))
 *             pList[0]=n/2             # <<<<<<<<<<<<<<
 * 
 *             for i,d in enumerate(pixList):
 */
    __pyx_t_5 = __Pyx_PyNumber_Divide(__pyx_v_n, __pyx_int_2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_7 = __Pyx_PyInt_from_py_WORD(__pyx_t_5); if (unlikely((__pyx_t_7 == (WORD)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    (__pyx_v_pList[0]) = __pyx_t_7;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1983
 *             pList[0]=n/2
 * 
 *             for i,d in enumerate(pixList):             # <<<<<<<<<<<<<<
 *                 pList[i+1]=d
 * 
 */
    __Pyx_INCREF(__pyx_int_0);
    __pyx_t_5 = __pyx_int_0;
    if (likely(((PyObject *)__pyx_v_pixList) != Py_None)) {
      __pyx_t_2 = 0; __pyx_t_3 = ((PyObject *)__pyx_v_pixList); __Pyx_INCREF(__pyx_t_3);
    } else {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable"); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1983; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    for (;;) {
      if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_3)) break;
      __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++;
      __Pyx_DECREF(__pyx_v_d);
      __pyx_v_d = __pyx_t_4;
      __pyx_t_4 = 0;
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_v_i);
      __pyx_v_i = __pyx_t_5;
      __pyx_t_4 = PyNumber_Add(__pyx_t_5, __pyx_int_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1983; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5);
      __pyx_t_5 = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "/home/oscar/pyueye/ueye/ueye.pyx":1984
 * 
 *             for i,d in enumerate(pixList):
 *                 pList[i+1]=d             # <<<<<<<<<<<<<<
 * 
 *             rv=is_SetBadPixelCorrectionTable (self.cid, nMode, pList)
 */
      __pyx_t_7 = __Pyx_PyInt_from_py_WORD(__pyx_v_d); if (unlikely((__pyx_t_7 == (WORD)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_t_4 = PyNumber_Add(__pyx_v_i, __pyx_int_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_8 = __Pyx_PyIndex_AsSsize_t(__pyx_t_4); if (unlikely((__pyx_t_8 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      (__pyx_v_pList[__pyx_t_8]) = __pyx_t_7;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1986
 *                 pList[i+1]=d
 * 
 *             rv=is_SetBadPixelCorrectionTable (self.cid, nMode, pList)             # <<<<<<<<<<<<<<
 * 
 *             self.CheckNoSuccess(rv)
 */
    __pyx_t_5 = __Pyx_PyInt_to_py_INT(is_SetBadPixelCorrectionTable(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nMode, __pyx_v_pList)); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1986; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_v_rv);
    __pyx_v_rv = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1988
 *             rv=is_SetBadPixelCorrectionTable (self.cid, nMode, pList)
 * 
 *             self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *             free(pList)
 *             rl= pixList
 */
    __pyx_t_5 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1988; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1988; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_rv);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_rv);
    __Pyx_GIVEREF(__pyx_v_rv);
    __pyx_t_4 = PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1988; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1989
 * 
 *             self.CheckNoSuccess(rv)
 *             free(pList)             # <<<<<<<<<<<<<<
 *             rl= pixList
 *         elif nMode==IS_GET_BADPIXEL_LIST:
 */
    free(__pyx_v_pList);

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1990
 *             self.CheckNoSuccess(rv)
 *             free(pList)
 *             rl= pixList             # <<<<<<<<<<<<<<
 *         elif nMode==IS_GET_BADPIXEL_LIST:
 *             rl=[]
 */
    __Pyx_INCREF(((PyObject *)__pyx_v_pixList));
    __Pyx_DECREF(__pyx_v_rl);
    __pyx_v_rl = ((PyObject *)__pyx_v_pixList);
    goto __pyx_L6;
  }

  /* "/home/oscar/pyueye/ueye/ueye.pyx":1991
 *             free(pList)
 *             rl= pixList
 *         elif nMode==IS_GET_BADPIXEL_LIST:             # <<<<<<<<<<<<<<
 *             rl=[]
 *             n=is_SetBadPixelCorrectionTable (self.cid, IS_GET_LIST_SIZE, pList)
 */
  __pyx_t_1 = (__pyx_v_nMode == IS_GET_BADPIXEL_LIST);
  if (__pyx_t_1) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1992
 *             rl= pixList
 *         elif nMode==IS_GET_BADPIXEL_LIST:
 *             rl=[]             # <<<<<<<<<<<<<<
 *             n=is_SetBadPixelCorrectionTable (self.cid, IS_GET_LIST_SIZE, pList)
 * 
 */
    __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1992; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
    __Pyx_DECREF(__pyx_v_rl);
    __pyx_v_rl = ((PyObject *)__pyx_t_4);
    __pyx_t_4 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1993
 *         elif nMode==IS_GET_BADPIXEL_LIST:
 *             rl=[]
 *             n=is_SetBadPixelCorrectionTable (self.cid, IS_GET_LIST_SIZE, pList)             # <<<<<<<<<<<<<<
 * 
 *             pList= <WORD *>malloc((2*n+1)*sizeof(WORD))
 */
    __pyx_t_4 = __Pyx_PyInt_to_py_INT(is_SetBadPixelCorrectionTable(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, IS_GET_LIST_SIZE, __pyx_v_pList)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1993; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_v_n);
    __pyx_v_n = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1995
 *             n=is_SetBadPixelCorrectionTable (self.cid, IS_GET_LIST_SIZE, pList)
 * 
 *             pList= <WORD *>malloc((2*n+1)*sizeof(WORD))             # <<<<<<<<<<<<<<
 *             rv=is_SetBadPixelCorrectionTable (self.cid, nMode, pList)
 *             self.CheckNoSuccess(rv)
 */
    __pyx_t_4 = PyNumber_Multiply(__pyx_int_2, __pyx_v_n); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1995; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyNumber_Add(__pyx_t_4, __pyx_int_1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1995; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyInt_FromSize_t((sizeof(WORD))); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1995; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = PyNumber_Multiply(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1995; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyInt_AsSize_t(__pyx_t_5); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1995; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_pList = ((WORD *)malloc(__pyx_t_6));

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1996
 * 
 *             pList= <WORD *>malloc((2*n+1)*sizeof(WORD))
 *             rv=is_SetBadPixelCorrectionTable (self.cid, nMode, pList)             # <<<<<<<<<<<<<<
 *             self.CheckNoSuccess(rv)
 * 
 */
    __pyx_t_5 = __Pyx_PyInt_to_py_INT(is_SetBadPixelCorrectionTable(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nMode, __pyx_v_pList)); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1996; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_v_rv);
    __pyx_v_rv = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1997
 *             pList= <WORD *>malloc((2*n+1)*sizeof(WORD))
 *             rv=is_SetBadPixelCorrectionTable (self.cid, nMode, pList)
 *             self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *             for i in range(2*n):
 */
    __pyx_t_5 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1997; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1997; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(__pyx_v_rv);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_rv);
    __Pyx_GIVEREF(__pyx_v_rv);
    __pyx_t_3 = PyObject_Call(__pyx_t_5, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1997; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":1999
 *             self.CheckNoSuccess(rv)
 * 
 *             for i in range(2*n):             # <<<<<<<<<<<<<<
 *                 rl.append(pList[i+1])
 *                 free(pList)
 */
    __pyx_t_3 = PyNumber_Multiply(__pyx_int_2, __pyx_v_n); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = PyObject_Call(__pyx_builtin_range, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (PyList_CheckExact(__pyx_t_3) || PyTuple_CheckExact(__pyx_t_3)) {
      __pyx_t_2 = 0; __pyx_t_4 = __pyx_t_3; __Pyx_INCREF(__pyx_t_4);
    } else {
      __pyx_t_2 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    for (;;) {
      if (likely(PyList_CheckExact(__pyx_t_4))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_4)) break;
        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++;
      } else if (likely(PyTuple_CheckExact(__pyx_t_4))) {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++;
      } else {
        __pyx_t_3 = PyIter_Next(__pyx_t_4);
        if (!__pyx_t_3) {
          if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          break;
        }
        __Pyx_GOTREF(__pyx_t_3);
      }
      __Pyx_DECREF(__pyx_v_i);
      __pyx_v_i = __pyx_t_3;
      __pyx_t_3 = 0;

      /* "/home/oscar/pyueye/ueye/ueye.pyx":2000
 * 
 *             for i in range(2*n):
 *                 rl.append(pList[i+1])             # <<<<<<<<<<<<<<
 *                 free(pList)
 * 
 */
      __pyx_t_3 = PyNumber_Add(__pyx_v_i, __pyx_int_1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2000; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_8 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_8 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2000; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = __Pyx_PyInt_to_py_WORD((__pyx_v_pList[__pyx_t_8])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2000; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = __Pyx_PyObject_Append(__pyx_v_rl, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2000; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "/home/oscar/pyueye/ueye/ueye.pyx":2001
 *             for i in range(2*n):
 *                 rl.append(pList[i+1])
 *                 free(pList)             # <<<<<<<<<<<<<<
 * 
 *         else:
 */
      free(__pyx_v_pList);
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L6;
  }
  /*else*/ {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":2004
 * 
 *         else:
 *             raise Exception("Invalid nMode Parameter")             # <<<<<<<<<<<<<<
 * 
 *         return rl
 */
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(((PyObject *)__pyx_kp_s_6));
    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_kp_s_6));
    __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_6));
    __pyx_t_5 = PyObject_Call(__pyx_builtin_Exception, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6:;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2006
 *             raise Exception("Invalid nMode Parameter")
 * 
 *         return rl             # <<<<<<<<<<<<<<
 * 
 *     def SetColorConverter (self, INT ColorMode, INT ConvertMode):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rl);
  __pyx_r = __pyx_v_rl;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetBadPixelCorrectionTable");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_n);
  __Pyx_DECREF(__pyx_v_i);
  __Pyx_DECREF(__pyx_v_d);
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_DECREF(__pyx_v_rl);
  __Pyx_DECREF((PyObject *)__pyx_v_self);
  __Pyx_DECREF(__pyx_v_pixList);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2008
 *         return rl
 * 
 *     def SetColorConverter (self, INT ColorMode, INT ConvertMode):             # <<<<<<<<<<<<<<
 *         '''Set color converter
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetColorConverter(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetColorConverter[] = "Set color converter\n\n        Using SetColorConverter, you can select the type of Bayer conversion \n        for colour cameras. Software conversion is done on the PC, while \n        hardware conversion (Gigabit Ethernet uEye only) is done in the camera. \n        The use of a larger filter mask results in a higher image quality, \n        but increases the computational load.\n        \n        ** Hardware conversion is only supported by GigE uEye cameras.\n        While free run mode is active, you cannot change the colour conversion \n        type. To do so, you must first stop the capturing process using \n        StopLiveVideo() or set the camera to trigger mode \n        (see also SetExternalTrigger()).\n        \n        Syntax:\n        =======\n        \n        rv=cam.SetColorConverter (ColorMode, ConvertMode) \n\n        \n        Input Parameters:\n        =================\n        \n        ColorMode: \n            Colour mode for which the converter is to be set.\n        \n        ConvertMode: \n            Conversion mode selection\n            - CONV_MODE_SOFTWARE_3x3: Software conversion using the standard \n              filter mask (default)\n            - CONV_MODE_SOFTWARE_5x5: Software conversion using a large filter mask\n            - CONV_MODE_HARDWARE_3x3: Hardware conversion using the standard \n              filter mask (GigE uEye only)\n            \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n            - CAPTURE_RUNNING: This function cannot be executed since the camera \n              is currently in live operation\n            - INVALID_PARAMETER: The ConvertMode parameter is invalid or not supported\n            - INVALID_COLOR_FORMAT: The ColorMode parameter is invalid or not supported\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetColorConverter(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_ColorMode;
  INT __pyx_v_ConvertMode;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ColorMode,&__pyx_n_s__ConvertMode,0};
  __Pyx_RefNannySetupContext("SetColorConverter");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ColorMode);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ConvertMode);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetColorConverter", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetColorConverter") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_ColorMode = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_ColorMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_ConvertMode = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_ConvertMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_ColorMode = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_ColorMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_ConvertMode = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_ConvertMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetColorConverter", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2008; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetColorConverter");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2055
 *         '''
 * 
 *         rv=is_SetColorConverter (self.cid, ColorMode, ConvertMode)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetColorConverter(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_ColorMode, __pyx_v_ConvertMode)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2056
 * 
 *         rv=is_SetColorConverter (self.cid, ColorMode, ConvertMode)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2056; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2056; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2056; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2057
 *         rv=is_SetColorConverter (self.cid, ColorMode, ConvertMode)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetColorCorrection (self, INT nEnable):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetColorConverter");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2059
 *         return rv
 * 
 *     def SetColorCorrection (self, INT nEnable):             # <<<<<<<<<<<<<<
 *         '''Set color correction
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetColorCorrection(PyObject *__pyx_v_self, PyObject *__pyx_arg_nEnable); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetColorCorrection[] = "Set color correction\n""        \n""        For colour cameras, SetColorCorrection() enables colour correction \n""        in the uEye driver. This enhances the rendering of colours for cameras \n""        with colour sensors. Colour correction is a digital correction based \n""        on a colour matrix which is adjusted individually for each sensor.\n""        If you perform Bayer conversion for GigE uEye HE colour cameras in \n""        the camera itself, colour conversion will automatically also take \n""        place in the camera. \n""        \n""        ** After changing this parameter, perform manual or automatic white \n""        balancing in order to obtain correct colour rendering \n""        (see also SetAutoParameter()).**\n""        \n""        Syntax:\n""        =======\n""        \n""        rv=SetColorCorrection (nEnable)\n""        \n""\n""        Input Parameters:\n""        =================\n""        \n""        nEnable:\n""            - CCOR_ENABLE_NORMAL: Enables simple colour correction. This parameter \n""              replaces CCOR_ENABLE.\n""            - CCOR_ENABLE_BG40_ENHANCED: Enables colour correction for cameras with \n""              optical IR filter glasses of the BG40 type.\n""            - CCOR_ENABLE_HQ_ENHANCED: Enables colour correction for cameras with \n""              optical IR filter glasses of the HQ type.\n""            - CCOR_DISABLE: Disables colour correction.\n""            - GET_CCOR_MODE: Returns the current setting.\n""            - GET_SUPPORTED_CCOR_MODE: Returns all supported colour correction modes. \n""            - GET_DEFAULT_CCOR_MODE: Returns the default colour correction mode.\n""            \n""        Return Values:\n""        ==============\n""        rv:\n""            - SUCCESS: Function executed successfully\n""            - Current setting when used together with GET_CCOR_MODE\n""            - When used together with GET_SUPPORTED_CCOR_MODE:\n""                When used for colour cameras and together with GET_SUPPORTED_CCOR_MODE, \n""                this parameter returns the supported values linked by a logical OR:\n""                - CCOR_ENABLE_NORMAL\n""                - CCOR_ENABLE_BG40_ENHANCED\n""                - CCOR_ENABLE_HQ_ENHANCED\n""        \n""                When used for monochrome cameras, the system returns 0.\n""            - When used together with GET_DEFAULT_CCOR_MODE:\n""                When used for colour cameras and together with GET_DEFAULT_CCOR_MODE, \n""                this parameter returns the default colour correction mode: \n""                CCOR_ENABLE_NORMAL , CCOR_ENABLE_HQ_ENHANCED.\n""                When used for monochrome cameras, the system returns 0.\n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetColorCorrection(PyObject *__pyx_v_self, PyObject *__pyx_arg_nEnable) {
  INT __pyx_v_nEnable;
  double *__pyx_v_factors;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetColorCorrection");
  assert(__pyx_arg_nEnable); {
    __pyx_v_nEnable = __Pyx_PyInt_from_py_INT(__pyx_arg_nEnable); if (unlikely((__pyx_v_nEnable == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2059; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetColorCorrection");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2116
 * 
 *         cdef double* factors
 *         rv= is_SetColorCorrection (self.cid, nEnable, factors)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetColorCorrection(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nEnable, __pyx_v_factors)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2117
 *         cdef double* factors
 *         rv= is_SetColorCorrection (self.cid, nEnable, factors)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2118
 *         rv= is_SetColorCorrection (self.cid, nEnable, factors)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetColorMode (self, INT Mode):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetColorCorrection");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2120
 *         return rv
 * 
 *     def SetColorMode (self, INT Mode):             # <<<<<<<<<<<<<<
 *         '''Set and get color mode
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetColorMode(PyObject *__pyx_v_self, PyObject *__pyx_arg_Mode); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetColorMode[] = "Set and get color mode\n""        \n""        Sets the colour mode to be used when image data are saved or \n""        displayed by the graphics card. For this purpose, the allocated \n""        image memory must be large enough to accommodate the data with \n""        the selected colour mode. When images are transferred directly \n""        to the graphics card memory, make sure that the display settings \n""        match the colour mode settings. Otherwise, the images will be \n""        displayed with altered colours or are not clearly visible.\n""\n""        For the RGB16 and RGB15 data formats, the MSBs of the internal \n""        8-bit R, G and B colours are used.\n""\n""        Syntax:\n""        =======\n""        \n""        rv=cam.SetColorMode (Mode)\n""               \n""        Input Parameters\n""        ================\n""        \n""        Mode: \n""            Colour mode to be set\n""            - CM_BAYER_RG16       -       Raw Bayer (16)\n""            - CM_BAYER_RG12       -       Raw Bayer (12)\n""            - CM_BAYER_RG8        -       Raw Bayer (8)\n""            - CM_MONO16           -       Greyscale (16)\n""            - CM_MONO12           -       Greyscale (12)\n""            - CM_MONO8            -       Greyscale (8)\n""            - CM_RGB10V2_PACKED   -       RGB30 (10 10 10)\n""            - CM_RGBA8_PACKED     -       RGB32 (8 8 8)\n""            - CM_RGBY8_PACKED     -       RGBY (8 8 8 8)\n""            - CM_RGB8_PACKED      -       RGB24 (8 8 8)\n""            - CM_BGR10V2_PACKED   -       BGR30 (10 10 10)\n""            - CM_BGRA8_PACKED     -       BGR32 (8 8 8)\n""            - CM_BGR8_PACKED      -       BGR24 (8 8 8)\n""            - CM_BGRY8_PACKED     -       BGRY (8 8 8)\n""            - CM_BGR565_PACKED    -       BGR16 (5 6 5)\n""            - CM_BGR555_PACKED    -       BGR15 (5 5 5)\n""            - CM_UYVY_PACKED      -       UYVY (8 8 8 8)\n""            - CM_UYVY_MONO_PACKED -       UYVY (8 8 8 8)\n""            - CM_UYVY_BAYER_PACKED-       UYVY (8 8 8 8)\n""            - CM_CBYCRY_PACKED    -       CbYCrY (8 8 8 8)\n""            - GET_COLOR_MODE      -       Returns the current setting.\n""            \n""        Return Values:\n""        ==============\n""        \n""        rv:\n""            if Mode != GET_COLORMODE returns Mode\n""            If Mode == GET_COLORMODE returns the actual colormode\n""            \n""        Note:\n""        =====\n""        The self.Img memory block gets its size adjusted when the color mode is\n""        set.\n""        \n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetColorMode(PyObject *__pyx_v_self, PyObject *__pyx_arg_Mode) {
  INT __pyx_v_Mode;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  INT __pyx_t_5;
  INT __pyx_t_6;
  INT __pyx_t_7;
  __Pyx_RefNannySetupContext("SetColorMode");
  assert(__pyx_arg_Mode); {
    __pyx_v_Mode = __Pyx_PyInt_from_py_INT(__pyx_arg_Mode); if (unlikely((__pyx_v_Mode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2120; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetColorMode");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __Pyx_INCREF((PyObject *)__pyx_v_self);
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2180
 *         '''
 * 
 *         rv=is_SetColorMode (self.cid,  Mode)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         if Mode==IS_GET_COLOR_MODE:
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetColorMode(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_Mode)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2181
 * 
 *         rv=is_SetColorMode (self.cid,  Mode)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         if Mode==IS_GET_COLOR_MODE:
 *             return rv
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2182
 *         rv=is_SetColorMode (self.cid,  Mode)
 *         self.CheckNoSuccess(rv)
 *         if Mode==IS_GET_COLOR_MODE:             # <<<<<<<<<<<<<<
 *             return rv
 * 
 */
  __pyx_t_4 = (__pyx_v_Mode == IS_GET_COLOR_MODE);
  if (__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":2183
 *         self.CheckNoSuccess(rv)
 *         if Mode==IS_GET_COLOR_MODE:
 *             return rv             # <<<<<<<<<<<<<<
 * 
 *         # Save information relevant to the colormode
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_rv);
    __pyx_r = __pyx_v_rv;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2186
 * 
 *         # Save information relevant to the colormode
 *         self.colormode= is_SetColorMode(self.cid, IS_GET_COLOR_MODE)             # <<<<<<<<<<<<<<
 *         self.bitspixel=bitspixel(self.colormode)
 * 
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_INT(is_SetColorMode(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, IS_GET_COLOR_MODE)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2187
 *         # Save information relevant to the colormode
 *         self.colormode= is_SetColorMode(self.cid, IS_GET_COLOR_MODE)
 *         self.bitspixel=bitspixel(self.colormode)             # <<<<<<<<<<<<<<
 * 
 *         if self.Img!=NULL:
 */
  __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__bitspixel); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode);
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode);
  __Pyx_GIVEREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->colormode);
  __pyx_t_1 = PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bitspixel);
  __Pyx_DECREF(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bitspixel);
  ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bitspixel = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2189
 *         self.bitspixel=bitspixel(self.colormode)
 * 
 *         if self.Img!=NULL:             # <<<<<<<<<<<<<<
 *             rv=is_FreeImageMem (self.cid, self.Img, self.ImgMemId)
 *             self.CheckNoSuccess(rv)
 */
  __pyx_t_4 = (((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Img != NULL);
  if (__pyx_t_4) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":2190
 * 
 *         if self.Img!=NULL:
 *             rv=is_FreeImageMem (self.cid, self.Img, self.ImgMemId)             # <<<<<<<<<<<<<<
 *             self.CheckNoSuccess(rv)
 * 
 */
    __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_FreeImageMem(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Img, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->ImgMemId)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_v_rv);
    __pyx_v_rv = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":2191
 *         if self.Img!=NULL:
 *             rv=is_FreeImageMem (self.cid, self.Img, self.ImgMemId)
 *             self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         rv=is_AllocImageMem(self.cid, self.nMaxWidth, self.nMaxHeight, self.bitspixel, &self.Img, &self.ImgMemId)
 */
    __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_rv);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
    __Pyx_GIVEREF(__pyx_v_rv);
    __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2193
 *             self.CheckNoSuccess(rv)
 * 
 *         rv=is_AllocImageMem(self.cid, self.nMaxWidth, self.nMaxHeight, self.bitspixel, &self.Img, &self.ImgMemId)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_5 = __Pyx_PyInt_from_py_INT(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxWidth); if (unlikely((__pyx_t_5 == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_6 = __Pyx_PyInt_from_py_INT(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->nMaxHeight); if (unlikely((__pyx_t_6 == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_7 = __Pyx_PyInt_from_py_INT(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->bitspixel); if (unlikely((__pyx_t_7 == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyInt_to_py_INT(is_AllocImageMem(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_t_5, __pyx_t_6, __pyx_t_7, (&((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Img), (&((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->ImgMemId))); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2193; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2194
 * 
 *         rv=is_AllocImageMem(self.cid, self.nMaxWidth, self.nMaxHeight, self.bitspixel, &self.Img, &self.ImgMemId)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         rv=is_SetImageMem (self.cid, self.Img, self.ImgMemId)
 */
  __pyx_t_3 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_1 = PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2196
 *         self.CheckNoSuccess(rv)
 * 
 *         rv=is_SetImageMem (self.cid, self.Img, self.ImgMemId)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetImageMem(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->Img, ((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->ImgMemId)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2197
 * 
 *         rv=is_SetImageMem (self.cid, self.Img, self.ImgMemId)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2200
 * 
 * 
 *         rv=is_GetImageMemPitch (self.cid, &self.LineInc)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 * 
 */
  __pyx_t_3 = __Pyx_PyInt_to_py_INT(is_GetImageMemPitch(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->LineInc))); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2201
 * 
 *         rv=is_GetImageMemPitch (self.cid, &self.LineInc)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 * 
 *         return Mode
 */
  __pyx_t_3 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_1 = PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2203
 *         self.CheckNoSuccess(rv)
 * 
 *         return Mode             # <<<<<<<<<<<<<<
 * 
 *     def SetConvertParam (self, BOOL ColorCorrection, INT BayerConversionMode, INT ColorMode, INT Gamma, tuple WhiteBalanceMultipliers):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(__pyx_v_Mode); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetColorMode");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_DECREF((PyObject *)__pyx_v_self);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2205
 *         return Mode
 * 
 *     def SetConvertParam (self, BOOL ColorCorrection, INT BayerConversionMode, INT ColorMode, INT Gamma, tuple WhiteBalanceMultipliers):             # <<<<<<<<<<<<<<
 *         '''Set convertion parameters
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetConvertParam(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetConvertParam[] = "Set convertion parameters\n        \n        Using SetConvertParam(), you can set the parameters for converting \n        a raw Bayer image to a colour image. To convert the image, use \n        the ConvertImage() function. \n        \n        Syntax:\n        =======\n        \n        rv=SetConvertParam (ColorCorrection, BayerConversionMode, \n                  ColorMode, Gamma, WhiteBalanceMultipliers)\n        \n        \n        Input Parameters:\n        =================\n        \n        ColorCorrection: \n            Enables / disables colour correction.\n\n        BayerConversionMode: \n            Sets the Bayer conversion mode.\n            - SET_BAYER_CV_BETTER: Better quality\n            - SET_BAYER_CV_BEST: Optimum quality (higher CPU load)\n\n        ColorMode: \n            Sets the colour mode for the output image.\n\n        Gamma: \n            Gamma value multiplied by 100. Range: [1\342\200\2461000]\n\n        WhiteBalanceMultipliers: \n            Tuple containing the red, green and blue gain values\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n            - INVALID_COLOR_FORMAT: Invalid ColorMode parameter\n            - INVALID_PARAMETER: Other invalid parameter.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetConvertParam(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  BOOL __pyx_v_ColorCorrection;
  INT __pyx_v_BayerConversionMode;
  INT __pyx_v_ColorMode;
  INT __pyx_v_Gamma;
  PyObject *__pyx_v_WhiteBalanceMultipliers = 0;
  double __pyx_v_WBM[3];
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  Py_ssize_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  double __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ColorCorrection,&__pyx_n_s__BayerConversionMode,&__pyx_n_s__ColorMode,&__pyx_n_s__Gamma,&__pyx_n_s_7,0};
  __Pyx_RefNannySetupContext("SetConvertParam");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[5] = {0,0,0,0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
      case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ColorCorrection);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__BayerConversionMode);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetConvertParam", 1, 5, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  2:
      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ColorMode);
      if (likely(values[2])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetConvertParam", 1, 5, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  3:
      values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__Gamma);
      if (likely(values[3])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetConvertParam", 1, 5, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
      case  4:
      values[4] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_7);
      if (likely(values[4])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetConvertParam", 1, 5, 5, 4); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetConvertParam") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_ColorCorrection = __Pyx_PyInt_from_py_BOOL(values[0]); if (unlikely((__pyx_v_ColorCorrection == (BOOL)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_BayerConversionMode = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_BayerConversionMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_ColorMode = __Pyx_PyInt_from_py_INT(values[2]); if (unlikely((__pyx_v_ColorMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_Gamma = __Pyx_PyInt_from_py_INT(values[3]); if (unlikely((__pyx_v_Gamma == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_WhiteBalanceMultipliers = ((PyObject *)values[4]);
  } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_ColorCorrection = __Pyx_PyInt_from_py_BOOL(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_ColorCorrection == (BOOL)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_BayerConversionMode = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_BayerConversionMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_ColorMode = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 2)); if (unlikely((__pyx_v_ColorMode == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_Gamma = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 3)); if (unlikely((__pyx_v_Gamma == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_WhiteBalanceMultipliers = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 4));
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetConvertParam", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetConvertParam");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_WhiteBalanceMultipliers), &PyTuple_Type, 1, "WhiteBalanceMultipliers", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2249
 *         '''
 *         cdef double WBM[3]
 *         assert len(WhiteBalanceMultipliers)==3,"the tuple WhiteBalanceMultipliers must contain 3 double numbers"             # <<<<<<<<<<<<<<
 *         WBM[0]=WhiteBalanceMultipliers[0]
 *         WBM[1]=WhiteBalanceMultipliers[1]
 */
  #ifndef PYREX_WITHOUT_ASSERTIONS
  __pyx_t_1 = PyObject_Length(((PyObject *)__pyx_v_WhiteBalanceMultipliers)); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!(__pyx_t_1 == 3))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2250
 *         cdef double WBM[3]
 *         assert len(WhiteBalanceMultipliers)==3,"the tuple WhiteBalanceMultipliers must contain 3 double numbers"
 *         WBM[0]=WhiteBalanceMultipliers[0]             # <<<<<<<<<<<<<<
 *         WBM[1]=WhiteBalanceMultipliers[1]
 *         WBM[2]=WhiteBalanceMultipliers[2]
 */
  __pyx_t_2 = __Pyx_GetItemInt_Tuple(((PyObject *)__pyx_v_WhiteBalanceMultipliers), 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_3 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  (__pyx_v_WBM[0]) = __pyx_t_3;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2251
 *         assert len(WhiteBalanceMultipliers)==3,"the tuple WhiteBalanceMultipliers must contain 3 double numbers"
 *         WBM[0]=WhiteBalanceMultipliers[0]
 *         WBM[1]=WhiteBalanceMultipliers[1]             # <<<<<<<<<<<<<<
 *         WBM[2]=WhiteBalanceMultipliers[2]
 *         rv=is_SetConvertParam (self.cid, ColorCorrection, BayerConversionMode, ColorMode, Gamma, WBM)
 */
  __pyx_t_2 = __Pyx_GetItemInt_Tuple(((PyObject *)__pyx_v_WhiteBalanceMultipliers), 1, sizeof(long), PyInt_FromLong); if (!__pyx_t_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_3 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  (__pyx_v_WBM[1]) = __pyx_t_3;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2252
 *         WBM[0]=WhiteBalanceMultipliers[0]
 *         WBM[1]=WhiteBalanceMultipliers[1]
 *         WBM[2]=WhiteBalanceMultipliers[2]             # <<<<<<<<<<<<<<
 *         rv=is_SetConvertParam (self.cid, ColorCorrection, BayerConversionMode, ColorMode, Gamma, WBM)
 *         self.CheckNoSuccess(rv)
 */
  __pyx_t_2 = __Pyx_GetItemInt_Tuple(((PyObject *)__pyx_v_WhiteBalanceMultipliers), 2, sizeof(long), PyInt_FromLong); if (!__pyx_t_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_3 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  (__pyx_v_WBM[2]) = __pyx_t_3;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2253
 *         WBM[1]=WhiteBalanceMultipliers[1]
 *         WBM[2]=WhiteBalanceMultipliers[2]
 *         rv=is_SetConvertParam (self.cid, ColorCorrection, BayerConversionMode, ColorMode, Gamma, WBM)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_2 = __Pyx_PyInt_to_py_INT(is_SetConvertParam(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_ColorCorrection, __pyx_v_BayerConversionMode, __pyx_v_ColorMode, __pyx_v_Gamma, __pyx_v_WBM)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2254
 *         WBM[2]=WhiteBalanceMultipliers[2]
 *         rv=is_SetConvertParam (self.cid, ColorCorrection, BayerConversionMode, ColorMode, Gamma, WBM)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_2 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_5 = PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2254; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2255
 *         rv=is_SetConvertParam (self.cid, ColorCorrection, BayerConversionMode, ColorMode, Gamma, WBM)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetEdgeEnhancement (self, INT nEnable):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetConvertParam");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2257
 *         return rv
 * 
 *     def SetEdgeEnhancement (self, INT nEnable):             # <<<<<<<<<<<<<<
 *         '''Set edge enhancement
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetEdgeEnhancement(PyObject *__pyx_v_self, PyObject *__pyx_arg_nEnable); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetEdgeEnhancement[] = "Set edge enhancement \n        \n        SetEdgeEnhancement() enables a software edge filter. Due to Bayer \n        format colour conversion, the original edges of a colour image \n        may easily become blurred. By enabling the digital edge filter, \n        you can optimise edge representation. This function causes a higher \n        CPU load.\n\n        If you perform Bayer conversion for GigE uEye HE colour cameras \n        in the camera itself, edge enhancement will automatically also take \n        place in the camera. In this case, the CPU load will not increase.\n        \n        Syntax:\n        =======\n        \n        RV=SetEdgeEnhancement (nEnable)\n        \n        Input Parameters:\n        =================\n        \n        nEnable:\n            - EDGE_EN_DISABLE: Disables the edge filter.\n            - EDGE_EN_STRONG: Enables strong edge enhancement.\n            - EDGE_EN_WEAK: Enables weaker edge enhancement.\n            - GET_EDGE_ENHANCEMENT: Returns the current setting.\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n            - Current setting when used together with GET_EDGE_ENHANCEMENT\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetEdgeEnhancement(PyObject *__pyx_v_self, PyObject *__pyx_arg_nEnable) {
  INT __pyx_v_nEnable;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("SetEdgeEnhancement");
  assert(__pyx_arg_nEnable); {
    __pyx_v_nEnable = __Pyx_PyInt_from_py_INT(__pyx_arg_nEnable); if (unlikely((__pyx_v_nEnable == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2257; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetEdgeEnhancement");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2293
 *         '''
 * 
 *         rv=is_SetEdgeEnhancement (self.cid, nEnable)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetEdgeEnhancement(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nEnable)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2294
 * 
 *         rv=is_SetEdgeEnhancement (self.cid, nEnable)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2295
 *         rv=is_SetEdgeEnhancement (self.cid, nEnable)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def SetSaturation (self, INT ChromU, INT ChromV):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetEdgeEnhancement");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2297
 *         return rv
 * 
 *     def SetSaturation (self, INT ChromU, INT ChromV):             # <<<<<<<<<<<<<<
 *         '''Set saturation
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetSaturation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetSaturation[] = "Set saturation\n        \n        Using SetSaturation(), you can set the software colour saturation. \n        \n        In the YUV format, colour information (i.e. the colour difference signals) \n        is provided by the U and V channels. In the U channel, this information \n        results from the difference between the blue level and Y (luminance), \n        in the V channel from the difference between the red level and Y.\n\n        For use in other colour formats than YUV, U and V are converted \n        using a driver matrix.\n        \n        \n        Syntax:\n        =======\n        \n        rv=cam.SetSaturation (ChromU, ChromV)\n                \n        Input Parameters:\n        =================\n        \n        ChromU:\n            U saturation: value multiplied by 100.\n            \n            Range: [MIN_SATURATION \342\200\246 MAX_SATURATION]\n            \n            GET_SATURATION_U: Returns the current value for the U saturation.\n\n        ChromV:\n            V saturation: value multiplied by 100.\n            \n            Range: [MIN_SATURATION \342\200\246 MAX_SATURATION]\n            \n            GET_SATURATION_V: Returns the current value for the V saturation.\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n            - Current setting when used together with, GET_SATURATION_U, \n              GET_SATURATION_V\n            - INVALID_PARAMETER: Invalid value for the ChromU or ChromV parameter.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetSaturation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_ChromU;
  INT __pyx_v_ChromV;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ChromU,&__pyx_n_s__ChromV,0};
  __Pyx_RefNannySetupContext("SetSaturation");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ChromU);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ChromV);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetSaturation", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2297; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetSaturation") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2297; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_ChromU = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_ChromU == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2297; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_ChromV = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_ChromV == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2297; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_ChromU = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_ChromU == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2297; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_ChromV = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_ChromV == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2297; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetSaturation", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2297; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetSaturation");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2344
 *         '''
 * 
 *         rv=is_SetSaturation (self.cid, ChromU, ChromV)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetSaturation(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_ChromU, __pyx_v_ChromV)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2345
 * 
 *         rv=is_SetSaturation (self.cid, ChromU, ChromV)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2346
 *         rv=is_SetSaturation (self.cid, ChromU, ChromV)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetSaturation");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2349
 * 
 * 
 *     def SetSensorTestImage (self, INT TestImage, INT Param):             # <<<<<<<<<<<<<<
 *         '''Set the sensor test image
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetSensorTestImage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_SetSensorTestImage[] = "Set the sensor test image\n        \n        SetSensorTestImage() enables a test image function in the sensor. \n        You can select different test images. The test images supported \n        by a particular camera can be queried using the GetSupportedTestImages()\n        function. For some test images, the Param  parameter provides \n        additional options. If the test image does not support additional parameters, \n        Param will be ignored.\n        \n        Syntax:\n        =======\n        \n        rv=cam=SetSensorTestImage (TestImage, Param) \n        \n        Input Parameters:\n        =================\n        \n        TestImage: \n            The test image to be set. See also GetSupportedTestImages().\n\n        Param: \n            Additional parameter for used to modify the test image. Not available \n            for all test images.\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n            - INVALID_PARAMETER: The Param parameter is not within the allowed \n              value range.\n            - NOT_SUPPORTED: The test image function is not supported by the camera.\n        \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_SetSensorTestImage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_TestImage;
  INT __pyx_v_Param;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__TestImage,&__pyx_n_s__Param,0};
  __Pyx_RefNannySetupContext("SetSensorTestImage");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__TestImage);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__Param);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("SetSensorTestImage", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "SetSensorTestImage") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_TestImage = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_TestImage == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_Param = __Pyx_PyInt_from_py_INT(values[1]); if (unlikely((__pyx_v_Param == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_TestImage = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_TestImage == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_Param = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_Param == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SetSensorTestImage", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.SetSensorTestImage");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2385
 *         '''
 * 
 *         rv=is_SetSensorTestImage (self.cid, TestImage, Param)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_SetSensorTestImage(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_TestImage, __pyx_v_Param)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2385; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2386
 * 
 *         rv=is_SetSensorTestImage (self.cid, TestImage, Param)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2387
 *         rv=is_SetSensorTestImage (self.cid, TestImage, Param)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def  CameraStatus(self, INT nInfo, ULONG ulValue):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.SetSensorTestImage");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2389
 *         return rv
 * 
 *     def  CameraStatus(self, INT nInfo, ULONG ulValue):             # <<<<<<<<<<<<<<
 *         '''Get the camera status
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_CameraStatus(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_CameraStatus[] = "Get the camera status\n""        \n""        Using CameraStatus(), you can query and partly set various status \n""        information and settings.\n""\n""\n""        Syntax:\n""        =======\n""        rv= cam.CameraStatus(nInfo, ulValue) \n""        \n""        Input Parameters:\n""        =================\n""        \n""        nInfo:\n""            - FIFO_OVR_CNT: Number of FIFO overruns. Is increased if image data \n""              gets lost because the USB bus is congested.\n""            - SEQUENCE_CNT: Returns the sequence count. For CaptureVideo(), this \n""              parameter is set to 0. Each time the sequence buffer (image counter) \n""              changes, the counter is increased by 1.\n""            - SEQUENCE_SIZE: Returns the number of sequence buffers.\n""            - EXT_TRIGGER_EVENT_CNT: Returns the camera's internal count of external \n""              trigger events.\n""            - TRIGGER_MISSED: Returns the number of unprocessed trigger signals. \n""              Is reset to 0 after each call.\n""            - LAST_CAPTURE_ERROR: Returns the last image capture error, e.g. after \n""              a 'transfer failed' event. For a list of all possible error events, \n""              see GetCaptureErrorInfo().\n""            - PARAMETER_SET_1: Indicates whether parameter set 1 including camera \n""              settings is present on the camera (read-only). \n""              See also SaveParameters().\n""            \n""              Return values:\n""                - TRUE        Parameter set 1 present\n""                - FALSE       Parameter set 1 not present\n""\n""            - PARAMETER_SET_2: Indicates whether parameter set 2 including camera \n""              settings is present on the camera (read-only). \n""              See also SaveParameters().\n""             \n""              Return values:\n""              \n""              - TRUE        Parameter set 2 present\n""              - FALSE       Parameter set 2 not present\n""\n""            - STANDBY: Sets the camera to standby mode.\n""                Return values:\n""                - TRUE        Camera changes to standby mode\n""                - FALSE       The camera changes to freerun mode\n""\n""            - STANDBY_SUPPORTED: Queries whether the camera supports standby mode (read-only).\n""                Return values:\n""                - TRUE        The camera supports standby mode\n""                - FALSE       The camera does not support standby mode\n""        \n""        Return Values:\n""        ==============\n""        rv:\n""            - SUCCESS: Function executed successfully\n""            - Returns the information specified by nInfo: Only if ulValue = GET_STATUS\n""            - When used with LAST_CAPTURE_ERROR returns the last image capture \n""            error. For a list of all possible error events, see GetCaptureErrorInfo().\n""        \n""        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_CameraStatus(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  INT __pyx_v_nInfo;
  ULONG __pyx_v_ulValue;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nInfo,&__pyx_n_s__ulValue,0};
  __Pyx_RefNannySetupContext("CameraStatus");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nInfo);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ulValue);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("CameraStatus", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2389; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "CameraStatus") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2389; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_nInfo = __Pyx_PyInt_from_py_INT(values[0]); if (unlikely((__pyx_v_nInfo == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2389; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_ulValue = __Pyx_PyInt_from_py_ULONG(values[1]); if (unlikely((__pyx_v_ulValue == (ULONG)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2389; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_nInfo = __Pyx_PyInt_from_py_INT(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_nInfo == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2389; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_ulValue = __Pyx_PyInt_from_py_ULONG(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_ulValue == (ULONG)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2389; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CameraStatus", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2389; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.CameraStatus");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2453
 * 
 *         '''
 *         rv=is_CameraStatus(self.cid, nInfo, ulValue)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return rv
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_ULONG(is_CameraStatus(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, __pyx_v_nInfo, __pyx_v_ulValue)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2454
 *         '''
 *         rv=is_CameraStatus(self.cid, nInfo, ulValue)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2455
 *         rv=is_CameraStatus(self.cid, nInfo, ulValue)
 *         self.CheckNoSuccess(rv)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def GetBusSpeed(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.CameraStatus");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2457
 *         return rv
 * 
 *     def GetBusSpeed(self):             # <<<<<<<<<<<<<<
 *         '''Get bus speed
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetBusSpeed(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetBusSpeed[] = "Get bus speed\n        \n        Using GetBusSpeed(), you can query whether a camera is connected \n        to a USB 2.0 host controller.\n        When the value 0 is passed for hCam, the function checks whether \n        a USB 2.0 controller is present in the system.\n\n        Syntax:\n        =======\n        \n        rv=cam.GetBusSpeed ()\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - SUCCESS: Function executed successfully\n            - USB_10: The controller to which the camera is connected does not \n              support USB 2.0.\n            - USB_20: The camera is connected to a USB 2.0 controller.\n                \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetBusSpeed(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("GetBusSpeed");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2481
 *         '''
 *         ### Toca hacer uno igual a este pero que este en el modulo
 *         rv=is_GetBusSpeed(self.cid)             # <<<<<<<<<<<<<<
 *         return rv
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetBusSpeed(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2481; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2482
 *         ### Toca hacer uno igual a este pero que este en el modulo
 *         rv=is_GetBusSpeed(self.cid)
 *         return rv             # <<<<<<<<<<<<<<
 * 
 *     def GetCameraType(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_rv);
  __pyx_r = __pyx_v_rv;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("ueye.ueye.Cam.GetBusSpeed");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2484
 *         return rv
 * 
 *     def GetCameraType(self):             # <<<<<<<<<<<<<<
 *         '''Get camera type
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetCameraType(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetCameraType[] = "Get camera type\n        \n        GetCameraType() returns the camera type.\n        \n        Syntax:\n        =======\n        \n        rv=cam.GetCameraType ()\n        \n        Return Values:\n        ==============\n        \n        rv:\n            - CAMERA_TYPE_UEYE_USB_SE: USB uEye SE camera\n            - CAMERA_TYPE_UEYE_USB_ME: USB uEye ME camera\n            - CAMERA_TYPE_UEYE_USB_RE: USB uEye RE camera\n            - CAMERA_TYPE_UEYE_USB_LE: USB uEye LE camera\n            - CAMERA_TYPE_UEYE_ETH_HE: GigE uEye HE camera\n            - CAMERA_TYPE_UEYE_ETH_SE: GigE uEye SE camera\n            \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetCameraType(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("GetCameraType");

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2506
 * 
 *         '''
 *         return is_GetCameraType(self.cid)             # <<<<<<<<<<<<<<
 * 
 *     def CheckNoSuccess(self,INT rv):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetCameraType(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("ueye.ueye.Cam.GetCameraType");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2508
 *         return is_GetCameraType(self.cid)
 * 
 *     def CheckNoSuccess(self,INT rv):             # <<<<<<<<<<<<<<
 *         '''Method that checks the return value of a is_XXXX function.
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_CheckNoSuccess(PyObject *__pyx_v_self, PyObject *__pyx_arg_rv); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_CheckNoSuccess[] = "Method that checks the return value of a is_XXXX function.\n        \n        If rv==NO_SUCCESS, the error mesage is printed and a exception is raised\n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_CheckNoSuccess(PyObject *__pyx_v_self, PyObject *__pyx_arg_rv) {
  INT __pyx_v_rv;
  char *__pyx_v_ermsg;
  PyObject *__pyx_v_rv1;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("CheckNoSuccess");
  assert(__pyx_arg_rv); {
    __pyx_v_rv = __Pyx_PyInt_from_py_INT(__pyx_arg_rv); if (unlikely((__pyx_v_rv == (INT)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2508; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("ueye.ueye.Cam.CheckNoSuccess");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __Pyx_INCREF((PyObject *)__pyx_v_self);
  __pyx_v_rv1 = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2515
 * 
 *         cdef char * ermsg
 *         if rv==IS_NO_SUCCESS:             # <<<<<<<<<<<<<<
 *             rv1=is_GetError (self.cid, &rv, &ermsg)
 *             if rv1==IS_NO_SUCCESS:
 */
  __pyx_t_1 = (__pyx_v_rv == IS_NO_SUCCESS);
  if (__pyx_t_1) {

    /* "/home/oscar/pyueye/ueye/ueye.pyx":2516
 *         cdef char * ermsg
 *         if rv==IS_NO_SUCCESS:
 *             rv1=is_GetError (self.cid, &rv, &ermsg)             # <<<<<<<<<<<<<<
 *             if rv1==IS_NO_SUCCESS:
 *                 raise Exception("Error getting error message")
 */
    __pyx_t_2 = __Pyx_PyInt_to_py_INT(is_GetError(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&__pyx_v_rv), (&__pyx_v_ermsg))); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2516; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_v_rv1);
    __pyx_v_rv1 = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":2517
 *         if rv==IS_NO_SUCCESS:
 *             rv1=is_GetError (self.cid, &rv, &ermsg)
 *             if rv1==IS_NO_SUCCESS:             # <<<<<<<<<<<<<<
 *                 raise Exception("Error getting error message")
 *             raise Exception(ermsg)
 */
    __pyx_t_2 = PyInt_FromLong(IS_NO_SUCCESS); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyObject_RichCompare(__pyx_v_rv1, __pyx_t_2, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_1) {

      /* "/home/oscar/pyueye/ueye/ueye.pyx":2518
 *             rv1=is_GetError (self.cid, &rv, &ermsg)
 *             if rv1==IS_NO_SUCCESS:
 *                 raise Exception("Error getting error message")             # <<<<<<<<<<<<<<
 *             raise Exception(ermsg)
 * 
 */
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_INCREF(((PyObject *)__pyx_kp_s_9));
      PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_kp_s_9));
      __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_9));
      __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;

    /* "/home/oscar/pyueye/ueye/ueye.pyx":2519
 *             if rv1==IS_NO_SUCCESS:
 *                 raise Exception("Error getting error message")
 *             raise Exception(ermsg)             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __pyx_t_2 = __Pyx_PyBytes_FromString(__pyx_v_ermsg); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_2));
    __Pyx_GIVEREF(((PyObject *)__pyx_t_2));
    __pyx_t_2 = 0;
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.CheckNoSuccess");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv1);
  __Pyx_DECREF((PyObject *)__pyx_v_self);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2524
 * 
 * 
 *     def GetGlobalFlashDelays(self):             # <<<<<<<<<<<<<<
 *         '''Get global flash delay
 * 
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetGlobalFlashDelays(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetGlobalFlashDelays[] = "Get global flash delay\n        \n        Rolling shutter cameras:\n\n        Using GetGlobalFlashDelays(), you can determine the times required \n        to implement a global flash function for rolling shutter cameras. \n        This way, a rolling shutter camera can also be used as a global shutter \n        camera provided that no ambient light falls on the sensor outside \n        the flash period.\n        If the exposure time is set too short so that no global flash operation \n        is possible, the function returns NO_SUCCESS.\n        \n        ** To use a rolling shutter camera with the Global Start function, \n        call the SetGlobalShutter() function before GetGlobalFlashDelays(). \n        Otherwise, incorrect values will be returned for Delay and Duration. **\n\n        Global shutter cameras:\n\n        In freerun mode, the exposure of global shutter cameras is delayed \n        if the exposure time is not set to the maximum value. GetGlobalFlashDelays() \n        determines the required delay in order to synchronise exposure and flash operation. \n        In triggered mode, the return values for delay and flash duration are 0, \n        since no delay is necessary before exposure starts.\n\n        \n        Syntax:\n        =======\n        \n        delay,duration=cam.GetGlobalFlashDelays ()\n        \n        Return Values:\n        ==============\n        \n        delay:\n            flash delay in \302\265s.\n            \n        duration: \n            flash duration in \302\265s.\n        \n    \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetGlobalFlashDelays(PyObject *__pyx_v_self, PyObject *unused) {
  ULONG __pyx_v_pulDelay;
  ULONG __pyx_v_pulDuration;
  PyObject *__pyx_v_rv;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("GetGlobalFlashDelays");
  __pyx_v_rv = Py_None; __Pyx_INCREF(Py_None);

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2569
 *         cdef ULONG pulDelay
 *         cdef ULONG pulDuration
 *         rv=is_GetGlobalFlashDelays(self.cid,&pulDelay, &pulDuration)             # <<<<<<<<<<<<<<
 *         self.CheckNoSuccess(rv)
 *         return pulDelay,pulDuration
 */
  __pyx_t_1 = __Pyx_PyInt_to_py_INT(is_GetGlobalFlashDelays(((struct __pyx_obj_4ueye_4ueye_Cam *)__pyx_v_self)->cid, (&__pyx_v_pulDelay), (&__pyx_v_pulDuration))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_rv);
  __pyx_v_rv = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2570
 *         cdef ULONG pulDuration
 *         rv=is_GetGlobalFlashDelays(self.cid,&pulDelay, &pulDuration)
 *         self.CheckNoSuccess(rv)             # <<<<<<<<<<<<<<
 *         return pulDelay,pulDuration
 * 
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__CheckNoSuccess); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_rv);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rv);
  __Pyx_GIVEREF(__pyx_v_rv);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":2571
 *         rv=is_GetGlobalFlashDelays(self.cid,&pulDelay, &pulDuration)
 *         self.CheckNoSuccess(rv)
 *         return pulDelay,pulDuration             # <<<<<<<<<<<<<<
 * 
 *     def GetImageHistogram(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyInt_to_py_ULONG(__pyx_v_pulDelay); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyInt_to_py_ULONG(__pyx_v_pulDuration); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_3 = 0;
  __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("ueye.ueye.Cam.GetGlobalFlashDelays");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_rv);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/home/oscar/pyueye/ueye/ueye.pyx":2573
 *         return pulDelay,pulDuration
 * 
 *     def GetImageHistogram(self):             # <<<<<<<<<<<<<<
 *         """
 *         Syntax:
 */

static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetImageHistogram(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_4ueye_4ueye_3Cam_GetImageHistogram[] = "\n        Syntax:\n        INT GetImageHistogram (int nID, INT ColorMode, DWORD pHistoMem)\n        \n        Description:\n        GetImageHistogram() computes the histogram of the submitted image. \n        The histogram always contains 256 values per channel. For colour modes \n        with a bit depth of more than 8 bits, the system evaluates the 8 most \n        significant bits (MSBs).\n\n        Input Parameters:\n        nID: Memory ID\n\n        ColorMode: Colour mode of the image with the nID memory ID\n\n        pHistoMem: Pointer to a DWORD array\n        The array must be allocated in such a way that it can accommodate 3*256 \n        values for colour formats and in raw Bayer mode. In monochrome mode, \n        the array must be able to accommodate 1*256 values.\n        \n        Return Values:\n        SUCCESS: Function executed successfully\n\n        NO_SUCCESS: General error message\n        \n        IS_NULL_POINTER: Invalid Array\n\n        INVALID_COLOR_FORMAT: Unsupported colour format\n\n        INVALID_PARAMETER: Unknown ColorModeparameter\n                \n        ";
static PyObject *__pyx_pf_4ueye_4ueye_3Cam_GetImageHistogram(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannySetupContext("GetImageHistogram");

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":187
 *         # experimental exception made for __getbuffer__ and __releasebuffer__
 *         # -- the details of this may change.
 *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fullfill the PEP.
 */

static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_v_copy_shape;
  int __pyx_v_i;
  int __pyx_v_ndim;
  int __pyx_v_endian_detector;
  int __pyx_v_little_endian;
  int __pyx_v_t;
  char *__pyx_v_f;
  PyArray_Descr *__pyx_v_descr = 0;
  int __pyx_v_offset;
  int __pyx_v_hasfields;
  int __pyx_r;
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  char *__pyx_t_9;
  __Pyx_RefNannySetupContext("__getbuffer__");
  if (__pyx_v_info == NULL) return 0;
  __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(__pyx_v_info->obj);
  __Pyx_INCREF((PyObject *)__pyx_v_self);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":193
 *             # of flags
 *             cdef int copy_shape, i, ndim
 *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 * 
 */
  __pyx_v_endian_detector = 1;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":194
 *             cdef int copy_shape, i, ndim
 *             cdef int endian_detector = 1
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
 * 
 *             ndim = PyArray_NDIM(self)
 */
  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":196
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 * 
 *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  __pyx_v_ndim = PyArray_NDIM(((PyArrayObject *)__pyx_v_self));

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":198
 *             ndim = PyArray_NDIM(self)
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 copy_shape = 1
 *             else:
 */
  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
  if (__pyx_t_1) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":199
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 copy_shape = 1             # <<<<<<<<<<<<<<
 *             else:
 *                 copy_shape = 0
 */
    __pyx_v_copy_shape = 1;
    goto __pyx_L5;
  }
  /*else*/ {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":201
 *                 copy_shape = 1
 *             else:
 *                 copy_shape = 0             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 */
    __pyx_v_copy_shape = 0;
  }
  __pyx_L5:;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":203
 *                 copy_shape = 0
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")
 */
  __pyx_t_1 = ((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS);
  if (__pyx_t_1) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":204
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 */
    __pyx_t_2 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_C_CONTIGUOUS));
    __pyx_t_3 = __pyx_t_2;
  } else {
    __pyx_t_3 = __pyx_t_1;
  }
  if (__pyx_t_3) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":205
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 */
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(((PyObject *)__pyx_kp_u_10));
    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_kp_u_10));
    __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_10));
    __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":207
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 */
  __pyx_t_3 = ((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS);
  if (__pyx_t_3) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":208
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 * 
 */
    __pyx_t_1 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_F_CONTIGUOUS));
    __pyx_t_2 = __pyx_t_1;
  } else {
    __pyx_t_2 = __pyx_t_3;
  }
  if (__pyx_t_2) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":209
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
 * 
 *             info.buf = PyArray_DATA(self)
 */
    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_INCREF(((PyObject *)__pyx_kp_u_11));
    PyTuple_SET_ITEM(__pyx_t_5, 0, ((PyObject *)__pyx_kp_u_11));
    __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_11));
    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":211
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 * 
 *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<
 *             info.ndim = ndim
 *             if copy_shape:
 */
  __pyx_v_info->buf = PyArray_DATA(((PyArrayObject *)__pyx_v_self));

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":212
 * 
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim             # <<<<<<<<<<<<<<
 *             if copy_shape:
 *                 # Allocate new buffer for strides and shape info. This is allocated
 */
  __pyx_v_info->ndim = __pyx_v_ndim;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":213
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim
 *             if copy_shape:             # <<<<<<<<<<<<<<
 *                 # Allocate new buffer for strides and shape info. This is allocated
 *                 # as one block, strides first.
 */
  __pyx_t_6 = __pyx_v_copy_shape;
  if (__pyx_t_6) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":216
 *                 # Allocate new buffer for strides and shape info. This is allocated
 *                 # as one block, strides first.
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)             # <<<<<<<<<<<<<<
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):
 */
    __pyx_v_info->strides = ((Py_ssize_t *)malloc((((sizeof(Py_ssize_t)) * __pyx_v_ndim) * 2)));

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":217
 *                 # as one block, strides first.
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)
 *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 */
    __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":218
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):             # <<<<<<<<<<<<<<
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 */
    __pyx_t_6 = __pyx_v_ndim;
    for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
      __pyx_v_i = __pyx_t_7;

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":219
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 *             else:
 */
      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":220
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 */
      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);
    }
    goto __pyx_L8;
  }
  /*else*/ {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":222
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL
 */
    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(((PyArrayObject *)__pyx_v_self)));

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":223
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)
 */
    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(((PyArrayObject *)__pyx_v_self)));
  }
  __pyx_L8:;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":224
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
 *             info.itemsize = PyArray_ITEMSIZE(self)
 *             info.readonly = not PyArray_ISWRITEABLE(self)
 */
  __pyx_v_info->suboffsets = NULL;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":225
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<
 *             info.readonly = not PyArray_ISWRITEABLE(self)
 * 
 */
  __pyx_v_info->itemsize = PyArray_ITEMSIZE(((PyArrayObject *)__pyx_v_self));

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":226
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)
 *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<
 * 
 *             cdef int t
 */
  __pyx_v_info->readonly = (!PyArray_ISWRITEABLE(((PyArrayObject *)__pyx_v_self)));

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":229
 * 
 *             cdef int t
 *             cdef char* f = NULL             # <<<<<<<<<<<<<<
 *             cdef dtype descr = self.descr
 *             cdef list stack
 */
  __pyx_v_f = NULL;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":230
 *             cdef int t
 *             cdef char* f = NULL
 *             cdef dtype descr = self.descr             # <<<<<<<<<<<<<<
 *             cdef list stack
 *             cdef int offset
 */
  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_v_self)->descr));
  __pyx_v_descr = ((PyArrayObject *)__pyx_v_self)->descr;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":234
 *             cdef int offset
 * 
 *             cdef bint hasfields = PyDataType_HASFIELDS(descr)             # <<<<<<<<<<<<<<
 * 
 *             if not hasfields and not copy_shape:
 */
  __pyx_v_hasfields = PyDataType_HASFIELDS(__pyx_v_descr);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":236
 *             cdef bint hasfields = PyDataType_HASFIELDS(descr)
 * 
 *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<
 *                 # do not call releasebuffer
 *                 info.obj = None
 */
  __pyx_t_2 = (!__pyx_v_hasfields);
  if (__pyx_t_2) {
    __pyx_t_3 = (!__pyx_v_copy_shape);
    __pyx_t_1 = __pyx_t_3;
  } else {
    __pyx_t_1 = __pyx_t_2;
  }
  if (__pyx_t_1) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":238
 *             if not hasfields and not copy_shape:
 *                 # do not call releasebuffer
 *                 info.obj = None             # <<<<<<<<<<<<<<
 *             else:
 *                 # need to call releasebuffer
 */
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj);
    __pyx_v_info->obj = Py_None;
    goto __pyx_L11;
  }
  /*else*/ {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":241
 *             else:
 *                 # need to call releasebuffer
 *                 info.obj = self             # <<<<<<<<<<<<<<
 * 
 *             if not hasfields:
 */
    __Pyx_INCREF(__pyx_v_self);
    __Pyx_GIVEREF(__pyx_v_self);
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj);
    __pyx_v_info->obj = __pyx_v_self;
  }
  __pyx_L11:;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":243
 *                 info.obj = self
 * 
 *             if not hasfields:             # <<<<<<<<<<<<<<
 *                 t = descr.type_num
 *                 if ((descr.byteorder == '>' and little_endian) or
 */
  __pyx_t_1 = (!__pyx_v_hasfields);
  if (__pyx_t_1) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":244
 * 
 *             if not hasfields:
 *                 t = descr.type_num             # <<<<<<<<<<<<<<
 *                 if ((descr.byteorder == '>' and little_endian) or
 *                     (descr.byteorder == '<' and not little_endian)):
 */
    __pyx_v_t = __pyx_v_descr->type_num;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":245
 *             if not hasfields:
 *                 t = descr.type_num
 *                 if ((descr.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<
 *                     (descr.byteorder == '<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 */
    __pyx_t_1 = (__pyx_v_descr->byteorder == '>');
    if (__pyx_t_1) {
      __pyx_t_2 = __pyx_v_little_endian;
    } else {
      __pyx_t_2 = __pyx_t_1;
    }
    if (!__pyx_t_2) {

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":246
 *                 t = descr.type_num
 *                 if ((descr.byteorder == '>' and little_endian) or
 *                     (descr.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"
 */
      __pyx_t_1 = (__pyx_v_descr->byteorder == '<');
      if (__pyx_t_1) {
        __pyx_t_3 = (!__pyx_v_little_endian);
        __pyx_t_8 = __pyx_t_3;
      } else {
        __pyx_t_8 = __pyx_t_1;
      }
      __pyx_t_1 = __pyx_t_8;
    } else {
      __pyx_t_1 = __pyx_t_2;
    }
    if (__pyx_t_1) {

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":247
 *                 if ((descr.byteorder == '>' and little_endian) or
 *                     (descr.byteorder == '<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 */
      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_INCREF(((PyObject *)__pyx_kp_u_12));
      PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_kp_u_12));
      __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_12));
      __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_Raise(__pyx_t_5, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L13;
    }
    __pyx_L13:;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":248
 *                     (descr.byteorder == '<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_BYTE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__b;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":249
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_UBYTE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__B;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":250
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_SHORT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__h;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":251
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_USHORT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__H;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":252
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_INT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__i;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":253
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_UINT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__I;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":254
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_LONG);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__l;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":255
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_ULONG);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__L;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":256
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_LONGLONG);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__q;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":257
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_ULONGLONG);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__Q;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":258
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_FLOAT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__f;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":259
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_DOUBLE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__d;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":260
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_LONGDOUBLE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__g;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":261
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_CFLOAT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__Zf;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":262
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_CDOUBLE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__Zd;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":263
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_OBJECT:      f = "O"
 *                 else:
 */
    __pyx_t_1 = (__pyx_v_t == NPY_CLONGDOUBLE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__Zg;
      goto __pyx_L14;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":264
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
    __pyx_t_1 = (__pyx_v_t == NPY_OBJECT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__O;
      goto __pyx_L14;
    }
    /*else*/ {

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":266
 *                 elif t == NPY_OBJECT:      f = "O"
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
 *                 info.format = f
 *                 return
 */
      __pyx_t_5 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_4 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_13), __pyx_t_5); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_L14:;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":267
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *                 info.format = f             # <<<<<<<<<<<<<<
 *                 return
 *             else:
 */
    __pyx_v_info->format = __pyx_v_f;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":268
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *                 info.format = f
 *                 return             # <<<<<<<<<<<<<<
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L12;
  }
  /*else*/ {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":270
 *                 return
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<
 *                 info.format[0] = '^' # Native data types, manual alignment
 *                 offset = 0
 */
    __pyx_v_info->format = ((char *)malloc(255));

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":271
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 *                 info.format[0] = '^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
 *                 offset = 0
 *                 f = _util_dtypestring(descr, info.format + 1,
 */
    (__pyx_v_info->format[0]) = '^';

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":272
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 *                 info.format[0] = '^' # Native data types, manual alignment
 *                 offset = 0             # <<<<<<<<<<<<<<
 *                 f = _util_dtypestring(descr, info.format + 1,
 *                                       info.format + _buffer_format_string_len,
 */
    __pyx_v_offset = 0;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":275
 *                 f = _util_dtypestring(descr, info.format + 1,
 *                                       info.format + _buffer_format_string_len,
 *                                       &offset)             # <<<<<<<<<<<<<<
 *                 f[0] = 0 # Terminate format string
 * 
 */
    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 273; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_f = __pyx_t_9;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":276
 *                                       info.format + _buffer_format_string_len,
 *                                       &offset)
 *                 f[0] = 0 # Terminate format string             # <<<<<<<<<<<<<<
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 */
    (__pyx_v_f[0]) = 0;
  }
  __pyx_L12:;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("numpy.ndarray.__getbuffer__");
  __pyx_r = -1;
  __Pyx_GOTREF(__pyx_v_info->obj);
  __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;
  goto __pyx_L2;
  __pyx_L0:;
  if (__pyx_v_info->obj == Py_None) {
    __Pyx_GOTREF(Py_None);
    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
  }
  __pyx_L2:;
  __Pyx_XDECREF((PyObject *)__pyx_v_descr);
  __Pyx_DECREF((PyObject *)__pyx_v_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":278
 *                 f[0] = 0 # Terminate format string
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)
 */

static void __pyx_pf_5numpy_7ndarray___releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
static void __pyx_pf_5numpy_7ndarray___releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__releasebuffer__");
  __Pyx_INCREF((PyObject *)__pyx_v_self);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":279
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  __pyx_t_1 = PyArray_HASFIELDS(((PyArrayObject *)__pyx_v_self));
  if (__pyx_t_1) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":280
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)             # <<<<<<<<<<<<<<
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 stdlib.free(info.strides)
 */
    free(__pyx_v_info->format);
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":281
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 stdlib.free(info.strides)
 *                 # info.shape was stored after info.strides in the same block
 */
  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
  if (__pyx_t_1) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":282
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 stdlib.free(info.strides)             # <<<<<<<<<<<<<<
 *                 # info.shape was stored after info.strides in the same block
 * 
 */
    free(__pyx_v_info->strides);
    goto __pyx_L6;
  }
  __pyx_L6:;

  __Pyx_DECREF((PyObject *)__pyx_v_self);
  __Pyx_RefNannyFinishContext();
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":755
 * ctypedef npy_cdouble     complex_t
 * 
 * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1");

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":756
 * 
 * cdef inline object PyArray_MultiIterNew1(a):
 *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 756; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew1");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":758
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2");

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":759
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew2");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":761
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3");

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":762
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew3");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":764
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4");

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":765
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew4");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":767
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5");

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":768
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 768; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew5");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":770
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
 *     # Recursive utility function used in __getbuffer__ to get format
 *     # string. The new location in the format string is returned.
 */

static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *__pyx_v_descr, char *__pyx_v_f, char *__pyx_v_end, int *__pyx_v_offset) {
  PyArray_Descr *__pyx_v_child;
  int __pyx_v_endian_detector;
  int __pyx_v_little_endian;
  PyObject *__pyx_v_fields;
  PyObject *__pyx_v_childname;
  PyObject *__pyx_v_new_offset;
  PyObject *__pyx_v_t;
  char *__pyx_r;
  Py_ssize_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  char *__pyx_t_10;
  __Pyx_RefNannySetupContext("_util_dtypestring");
  __Pyx_INCREF((PyObject *)__pyx_v_descr);
  __pyx_v_child = ((PyArray_Descr *)Py_None); __Pyx_INCREF(Py_None);
  __pyx_v_fields = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
  __pyx_v_childname = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_new_offset = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_t = Py_None; __Pyx_INCREF(Py_None);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":777
 *     cdef int delta_offset
 *     cdef tuple i
 *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<
 *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 *     cdef tuple fields
 */
  __pyx_v_endian_detector = 1;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":778
 *     cdef tuple i
 *     cdef int endian_detector = 1
 *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
 *     cdef tuple fields
 * 
 */
  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":781
 *     cdef tuple fields
 * 
 *     for childname in descr.names:             # <<<<<<<<<<<<<<
 *         fields = descr.fields[childname]
 *         child, new_offset = fields
 */
  if (likely(((PyObject *)__pyx_v_descr->names) != Py_None)) {
    __pyx_t_1 = 0; __pyx_t_2 = ((PyObject *)__pyx_v_descr->names); __Pyx_INCREF(__pyx_t_2);
  } else {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable"); {__pyx_filename = __pyx_f[1]; __pyx_lineno = 781; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  for (;;) {
    if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_1); __Pyx_INCREF(__pyx_t_3); __pyx_t_1++;
    __Pyx_DECREF(__pyx_v_childname);
    __pyx_v_childname = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":782
 * 
 *     for childname in descr.names:
 *         fields = descr.fields[childname]             # <<<<<<<<<<<<<<
 *         child, new_offset = fields
 * 
 */
    __pyx_t_3 = PyObject_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (!__pyx_t_3) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 782; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected tuple, got %.200s", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 782; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_fields));
    __pyx_v_fields = ((PyObject *)__pyx_t_3);
    __pyx_t_3 = 0;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":783
 *     for childname in descr.names:
 *         fields = descr.fields[childname]
 *         child, new_offset = fields             # <<<<<<<<<<<<<<
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:
 */
    if (likely(((PyObject *)__pyx_v_fields) != Py_None) && likely(PyTuple_GET_SIZE(((PyObject *)__pyx_v_fields)) == 2)) {
      PyObject* tuple = ((PyObject *)__pyx_v_fields);
      __pyx_t_3 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_t_3);
      if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 783; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_t_4 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_t_4);
      __Pyx_DECREF(((PyObject *)__pyx_v_child));
      __pyx_v_child = ((PyArray_Descr *)__pyx_t_3);
      __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_v_new_offset);
      __pyx_v_new_offset = __pyx_t_4;
      __pyx_t_4 = 0;
    } else {
      __Pyx_UnpackTupleError(((PyObject *)__pyx_v_fields), 2);
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 783; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":785
 *         child, new_offset = fields
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 */
    __pyx_t_4 = PyInt_FromLong((__pyx_v_end - __pyx_v_f)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyNumber_Subtract(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_int_15, Py_LT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_6) {

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":786
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
 * 
 *         if ((child.byteorder == '>' and little_endian) or
 */
      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_INCREF(((PyObject *)__pyx_kp_u_14));
      PyTuple_SET_ITEM(__pyx_t_5, 0, ((PyObject *)__pyx_kp_u_14));
      __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_14));
      __pyx_t_3 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L5;
    }
    __pyx_L5:;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":788
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 *         if ((child.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<
 *             (child.byteorder == '<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")
 */
    __pyx_t_6 = (__pyx_v_child->byteorder == '>');
    if (__pyx_t_6) {
      __pyx_t_7 = __pyx_v_little_endian;
    } else {
      __pyx_t_7 = __pyx_t_6;
    }
    if (!__pyx_t_7) {

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":789
 * 
 *         if ((child.byteorder == '>' and little_endian) or
 *             (child.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<
 *             raise ValueError(u"Non-native byte order not supported")
 *             # One could encode it in the format string and have Cython
 */
      __pyx_t_6 = (__pyx_v_child->byteorder == '<');
      if (__pyx_t_6) {
        __pyx_t_8 = (!__pyx_v_little_endian);
        __pyx_t_9 = __pyx_t_8;
      } else {
        __pyx_t_9 = __pyx_t_6;
      }
      __pyx_t_6 = __pyx_t_9;
    } else {
      __pyx_t_6 = __pyx_t_7;
    }
    if (__pyx_t_6) {

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":790
 *         if ((child.byteorder == '>' and little_endian) or
 *             (child.byteorder == '<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *             # One could encode it in the format string and have Cython
 *             # complain instead, BUT: < and > in format strings also imply
 */
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_INCREF(((PyObject *)__pyx_kp_u_12));
      PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_kp_u_12));
      __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_12));
      __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_5, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":800
 * 
 *         # Output padding bytes
 *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<
 *             f[0] = 120 # "x"; pad byte
 *             f += 1
 */
    while (1) {
      __pyx_t_5 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_v_new_offset, Py_LT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (!__pyx_t_6) break;

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":801
 *         # Output padding bytes
 *         while offset[0] < new_offset:
 *             f[0] = 120 # "x"; pad byte             # <<<<<<<<<<<<<<
 *             f += 1
 *             offset[0] += 1
 */
      (__pyx_v_f[0]) = 120;

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":802
 *         while offset[0] < new_offset:
 *             f[0] = 120 # "x"; pad byte
 *             f += 1             # <<<<<<<<<<<<<<
 *             offset[0] += 1
 * 
 */
      __pyx_v_f += 1;

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":803
 *             f[0] = 120 # "x"; pad byte
 *             f += 1
 *             offset[0] += 1             # <<<<<<<<<<<<<<
 * 
 *         offset[0] += child.itemsize
 */
      (__pyx_v_offset[0]) += 1;
    }

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":805
 *             offset[0] += 1
 * 
 *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<
 * 
 *         if not PyDataType_HASFIELDS(child):
 */
    (__pyx_v_offset[0]) += __pyx_v_child->elsize;

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":807
 *         offset[0] += child.itemsize
 * 
 *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
 *             t = child.type_num
 *             if end - f < 5:
 */
    __pyx_t_6 = (!PyDataType_HASFIELDS(__pyx_v_child));
    if (__pyx_t_6) {

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":808
 * 
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num             # <<<<<<<<<<<<<<
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")
 */
      __pyx_t_3 = PyInt_FromLong(__pyx_v_child->type_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_v_t);
      __pyx_v_t = __pyx_t_3;
      __pyx_t_3 = 0;

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":809
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num
 *             if end - f < 5:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError(u"Format string allocated too short.")
 * 
 */
      __pyx_t_6 = ((__pyx_v_end - __pyx_v_f) < 5);
      if (__pyx_t_6) {

        /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":810
 *             t = child.type_num
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 */
        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_INCREF(((PyObject *)__pyx_kp_u_15));
        PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_kp_u_15));
        __Pyx_GIVEREF(((PyObject *)__pyx_kp_u_15));
        __pyx_t_5 = PyObject_Call(__pyx_builtin_RuntimeError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_Raise(__pyx_t_5, 0, 0);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        goto __pyx_L10;
      }
      __pyx_L10:;

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":813
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"             # <<<<<<<<<<<<<<
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 98;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":814
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"             # <<<<<<<<<<<<<<
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 814; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 814; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 814; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 66;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":815
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"             # <<<<<<<<<<<<<<
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 815; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 104;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":816
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"             # <<<<<<<<<<<<<<
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 72;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":817
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"             # <<<<<<<<<<<<<<
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 105;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":818
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 73;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":819
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"             # <<<<<<<<<<<<<<
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 108;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":820
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 76;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":821
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"             # <<<<<<<<<<<<<<
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 113;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":822
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"             # <<<<<<<<<<<<<<
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 81;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":823
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"             # <<<<<<<<<<<<<<
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 102;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":824
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 */
      __pyx_t_3 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 100;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":825
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"             # <<<<<<<<<<<<<<
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 */
      __pyx_t_5 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 103;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":826
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 */
      __pyx_t_3 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 102;
        __pyx_v_f += 1;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":827
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 100;
        __pyx_v_f += 1;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":828
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 *             else:
 */
      __pyx_t_3 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 103;
        __pyx_v_f += 1;
        goto __pyx_L11;
      }

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":829
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"             # <<<<<<<<<<<<<<
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
      __pyx_t_5 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 79;
        goto __pyx_L11;
      }
      /*else*/ {

        /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":831
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
 *             f += 1
 *         else:
 */
        __pyx_t_3 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_13), __pyx_v_t); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
        __Pyx_GIVEREF(__pyx_t_3);
        __pyx_t_3 = 0;
        __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_Raise(__pyx_t_3, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __pyx_L11:;

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":832
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *             f += 1             # <<<<<<<<<<<<<<
 *         else:
 *             # Cython ignores struct boundary information ("T{...}"),
 */
      __pyx_v_f += 1;
      goto __pyx_L9;
    }
    /*else*/ {

      /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":836
 *             # Cython ignores struct boundary information ("T{...}"),
 *             # so don't output it
 *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<
 *     return f
 * 
 */
      __pyx_t_10 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_10 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_v_f = __pyx_t_10;
    }
    __pyx_L9:;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":837
 *             # so don't output it
 *             f = _util_dtypestring(child, f, end, offset)
 *     return f             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_f;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("numpy._util_dtypestring");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF((PyObject *)__pyx_v_child);
  __Pyx_DECREF(__pyx_v_fields);
  __Pyx_DECREF(__pyx_v_childname);
  __Pyx_DECREF(__pyx_v_new_offset);
  __Pyx_DECREF(__pyx_v_t);
  __Pyx_DECREF((PyObject *)__pyx_v_descr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":952
 * 
 * 
 * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
 *      cdef PyObject* baseptr
 *      if base is None:
 */

static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
  PyObject *__pyx_v_baseptr;
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("set_array_base");
  __Pyx_INCREF((PyObject *)__pyx_v_arr);
  __Pyx_INCREF(__pyx_v_base);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":954
 * cdef inline void set_array_base(ndarray arr, object base):
 *      cdef PyObject* baseptr
 *      if base is None:             # <<<<<<<<<<<<<<
 *          baseptr = NULL
 *      else:
 */
  __pyx_t_1 = (__pyx_v_base == Py_None);
  if (__pyx_t_1) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":955
 *      cdef PyObject* baseptr
 *      if base is None:
 *          baseptr = NULL             # <<<<<<<<<<<<<<
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!
 */
    __pyx_v_baseptr = NULL;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":957
 *          baseptr = NULL
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!             # <<<<<<<<<<<<<<
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)
 */
    Py_INCREF(__pyx_v_base);

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":958
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!
 *          baseptr = <PyObject*>base             # <<<<<<<<<<<<<<
 *      Py_XDECREF(arr.base)
 *      arr.base = baseptr
 */
    __pyx_v_baseptr = ((PyObject *)__pyx_v_base);
  }
  __pyx_L3:;

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":959
 *          Py_INCREF(base) # important to do this before decref below!
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)             # <<<<<<<<<<<<<<
 *      arr.base = baseptr
 * 
 */
  Py_XDECREF(__pyx_v_arr->base);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":960
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)
 *      arr.base = baseptr             # <<<<<<<<<<<<<<
 * 
 * cdef inline object get_array_base(ndarray arr):
 */
  __pyx_v_arr->base = __pyx_v_baseptr;

  __Pyx_DECREF((PyObject *)__pyx_v_arr);
  __Pyx_DECREF(__pyx_v_base);
  __Pyx_RefNannyFinishContext();
}

/* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":962
 *      arr.base = baseptr
 * 
 * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
 *     if arr.base is NULL:
 *         return None
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("get_array_base");
  __Pyx_INCREF((PyObject *)__pyx_v_arr);

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":963
 * 
 * cdef inline object get_array_base(ndarray arr):
 *     if arr.base is NULL:             # <<<<<<<<<<<<<<
 *         return None
 *     else:
 */
  __pyx_t_1 = (__pyx_v_arr->base == NULL);
  if (__pyx_t_1) {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":964
 * cdef inline object get_array_base(ndarray arr):
 *     if arr.base is NULL:
 *         return None             # <<<<<<<<<<<<<<
 *     else:
 *         return <object>arr.base
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/numpy.pxd":966
 *         return None
 *     else:
 *         return <object>arr.base             # <<<<<<<<<<<<<<
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(((PyObject *)__pyx_v_arr->base));
    __pyx_r = ((PyObject *)__pyx_v_arr->base);
    goto __pyx_L0;
  }
  __pyx_L3:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __pyx_L0:;
  __Pyx_DECREF((PyObject *)__pyx_v_arr);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_tp_new_4ueye_4ueye_Cam(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_4ueye_4ueye_Cam *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct __pyx_obj_4ueye_4ueye_Cam *)o);
  p->SerNo = Py_None; Py_INCREF(Py_None);
  p->ID = Py_None; Py_INCREF(Py_None);
  p->Version = Py_None; Py_INCREF(Py_None);
  p->Date = Py_None; Py_INCREF(Py_None);
  p->Select = Py_None; Py_INCREF(Py_None);
  p->SensorID = Py_None; Py_INCREF(Py_None);
  p->strSensorName = Py_None; Py_INCREF(Py_None);
  p->nColorMode = Py_None; Py_INCREF(Py_None);
  p->nMaxWidth = Py_None; Py_INCREF(Py_None);
  p->nMaxHeight = Py_None; Py_INCREF(Py_None);
  p->bMasterGain = Py_None; Py_INCREF(Py_None);
  p->bRGain = Py_None; Py_INCREF(Py_None);
  p->bGGain = Py_None; Py_INCREF(Py_None);
  p->bBGain = Py_None; Py_INCREF(Py_None);
  p->bGlobShutter = Py_None; Py_INCREF(Py_None);
  p->bitspixel = Py_None; Py_INCREF(Py_None);
  p->colormode = Py_None; Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_4ueye_4ueye_Cam(PyObject *o) {
  struct __pyx_obj_4ueye_4ueye_Cam *p = (struct __pyx_obj_4ueye_4ueye_Cam *)o;
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pf_4ueye_4ueye_3Cam___dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_XDECREF(p->SerNo);
  Py_XDECREF(p->ID);
  Py_XDECREF(p->Version);
  Py_XDECREF(p->Date);
  Py_XDECREF(p->Select);
  Py_XDECREF(p->SensorID);
  Py_XDECREF(p->strSensorName);
  Py_XDECREF(p->nColorMode);
  Py_XDECREF(p->nMaxWidth);
  Py_XDECREF(p->nMaxHeight);
  Py_XDECREF(p->bMasterGain);
  Py_XDECREF(p->bRGain);
  Py_XDECREF(p->bGGain);
  Py_XDECREF(p->bBGain);
  Py_XDECREF(p->bGlobShutter);
  Py_XDECREF(p->bitspixel);
  Py_XDECREF(p->colormode);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_4ueye_4ueye_Cam(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_4ueye_4ueye_Cam *p = (struct __pyx_obj_4ueye_4ueye_Cam *)o;
  if (p->SerNo) {
    e = (*v)(p->SerNo, a); if (e) return e;
  }
  if (p->ID) {
    e = (*v)(p->ID, a); if (e) return e;
  }
  if (p->Version) {
    e = (*v)(p->Version, a); if (e) return e;
  }
  if (p->Date) {
    e = (*v)(p->Date, a); if (e) return e;
  }
  if (p->Select) {
    e = (*v)(p->Select, a); if (e) return e;
  }
  if (p->SensorID) {
    e = (*v)(p->SensorID, a); if (e) return e;
  }
  if (p->strSensorName) {
    e = (*v)(p->strSensorName, a); if (e) return e;
  }
  if (p->nColorMode) {
    e = (*v)(p->nColorMode, a); if (e) return e;
  }
  if (p->nMaxWidth) {
    e = (*v)(p->nMaxWidth, a); if (e) return e;
  }
  if (p->nMaxHeight) {
    e = (*v)(p->nMaxHeight, a); if (e) return e;
  }
  if (p->bMasterGain) {
    e = (*v)(p->bMasterGain, a); if (e) return e;
  }
  if (p->bRGain) {
    e = (*v)(p->bRGain, a); if (e) return e;
  }
  if (p->bGGain) {
    e = (*v)(p->bGGain, a); if (e) return e;
  }
  if (p->bBGain) {
    e = (*v)(p->bBGain, a); if (e) return e;
  }
  if (p->bGlobShutter) {
    e = (*v)(p->bGlobShutter, a); if (e) return e;
  }
  if (p->bitspixel) {
    e = (*v)(p->bitspixel, a); if (e) return e;
  }
  if (p->colormode) {
    e = (*v)(p->colormode, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_4ueye_4ueye_Cam(PyObject *o) {
  struct __pyx_obj_4ueye_4ueye_Cam *p = (struct __pyx_obj_4ueye_4ueye_Cam *)o;
  PyObject* tmp;
  tmp = ((PyObject*)p->SerNo);
  p->SerNo = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->ID);
  p->ID = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->Version);
  p->Version = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->Date);
  p->Date = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->Select);
  p->Select = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->SensorID);
  p->SensorID = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->strSensorName);
  p->strSensorName = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->nColorMode);
  p->nColorMode = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->nMaxWidth);
  p->nMaxWidth = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->nMaxHeight);
  p->nMaxHeight = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->bMasterGain);
  p->bMasterGain = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->bRGain);
  p->bRGain = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->bGGain);
  p->bGGain = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->bBGain);
  p->bBGain = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->bGlobShutter);
  p->bGlobShutter = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->bitspixel);
  p->bitspixel = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->colormode);
  p->colormode = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static struct PyMethodDef __pyx_methods_4ueye_4ueye_Cam[] = {
  {__Pyx_NAMESTR("GrabImage"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GrabImage, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GrabImage)},
  {__Pyx_NAMESTR("GetExposureRange"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetExposureRange, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetExposureRange)},
  {__Pyx_NAMESTR("SetExposureTime"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetExposureTime, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetExposureTime)},
  {__Pyx_NAMESTR("GetFramesPerSecond"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetFramesPerSecond, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetFramesPerSecond)},
  {__Pyx_NAMESTR("GetFrameTimeRange"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetFrameTimeRange, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetFrameTimeRange)},
  {__Pyx_NAMESTR("SetFrameRate"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetFrameRate, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetFrameRate)},
  {__Pyx_NAMESTR("GetPixelClockRange"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetPixelClockRange, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetPixelClockRange)},
  {__Pyx_NAMESTR("SetPixelClock"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetPixelClock, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetPixelClock)},
  {__Pyx_NAMESTR("SetAutoParameter"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetAutoParameter, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetAutoParameter)},
  {__Pyx_NAMESTR("SetBlCompensation"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetBlCompensation, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetBlCompensation)},
  {__Pyx_NAMESTR("SetGainBoost"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetGainBoost, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetGainBoost)},
  {__Pyx_NAMESTR("SetGamma"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetGamma, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetGamma)},
  {__Pyx_NAMESTR("SetGlobalShutter"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetGlobalShutter, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetGlobalShutter)},
  {__Pyx_NAMESTR("SetHardwareGain"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetHardwareGain, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetHardwareGain)},
  {__Pyx_NAMESTR("SetHardwareGamma"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetHardwareGamma, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetHardwareGamma)},
  {__Pyx_NAMESTR("SetHWGainFactor"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetHWGainFactor, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetHWGainFactor)},
  {__Pyx_NAMESTR("ResetToDefault"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_ResetToDefault, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_ResetToDefault)},
  {__Pyx_NAMESTR("SetAOI"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetAOI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetAOI)},
  {__Pyx_NAMESTR("SetImagePos"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetImagePos, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetImagePos)},
  {__Pyx_NAMESTR("SetBinning"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetBinning, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetBinning)},
  {__Pyx_NAMESTR("SetRopEffect"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetRopEffect, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetRopEffect)},
  {__Pyx_NAMESTR("SetSubSampling"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetSubSampling, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetSubSampling)},
  {__Pyx_NAMESTR("GetTimeout"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetTimeout, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetTimeout)},
  {__Pyx_NAMESTR("SetTimeout"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetTimeout, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetTimeout)},
  {__Pyx_NAMESTR("CaptureVideo"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_CaptureVideo, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_CaptureVideo)},
  {__Pyx_NAMESTR("FreezeVideo"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_FreezeVideo, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_FreezeVideo)},
  {__Pyx_NAMESTR("StopLiveVideo"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_StopLiveVideo, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_StopLiveVideo)},
  {__Pyx_NAMESTR("SetExternalTrigger"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetExternalTrigger, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetExternalTrigger)},
  {__Pyx_NAMESTR("ForceTrigger"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_ForceTrigger, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_ForceTrigger)},
  {__Pyx_NAMESTR("LoadBadPixelCorrectionTable"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_LoadBadPixelCorrectionTable, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_LoadBadPixelCorrectionTable)},
  {__Pyx_NAMESTR("SaveBadPixelCorrectionTable"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SaveBadPixelCorrectionTable, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SaveBadPixelCorrectionTable)},
  {__Pyx_NAMESTR("SetBadPixelCorrection"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetBadPixelCorrection, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetBadPixelCorrection)},
  {__Pyx_NAMESTR("SetBadPixelCorrectionTable"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetBadPixelCorrectionTable, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetBadPixelCorrectionTable)},
  {__Pyx_NAMESTR("SetColorConverter"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetColorConverter, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetColorConverter)},
  {__Pyx_NAMESTR("SetColorCorrection"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetColorCorrection, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetColorCorrection)},
  {__Pyx_NAMESTR("SetColorMode"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetColorMode, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetColorMode)},
  {__Pyx_NAMESTR("SetConvertParam"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetConvertParam, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetConvertParam)},
  {__Pyx_NAMESTR("SetEdgeEnhancement"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetEdgeEnhancement, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetEdgeEnhancement)},
  {__Pyx_NAMESTR("SetSaturation"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetSaturation, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetSaturation)},
  {__Pyx_NAMESTR("SetSensorTestImage"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_SetSensorTestImage, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_SetSensorTestImage)},
  {__Pyx_NAMESTR("CameraStatus"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_CameraStatus, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_CameraStatus)},
  {__Pyx_NAMESTR("GetBusSpeed"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetBusSpeed, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetBusSpeed)},
  {__Pyx_NAMESTR("GetCameraType"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetCameraType, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetCameraType)},
  {__Pyx_NAMESTR("CheckNoSuccess"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_CheckNoSuccess, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_CheckNoSuccess)},
  {__Pyx_NAMESTR("GetGlobalFlashDelays"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetGlobalFlashDelays, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetGlobalFlashDelays)},
  {__Pyx_NAMESTR("GetImageHistogram"), (PyCFunction)__pyx_pf_4ueye_4ueye_3Cam_GetImageHistogram, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_3Cam_GetImageHistogram)},
  {0, 0, 0, 0}
};

static struct PyMemberDef __pyx_members_4ueye_4ueye_Cam[] = {
  {(char *)"cid", __Pyx_T_UNSIGNED_INT(DWORD), offsetof(struct __pyx_obj_4ueye_4ueye_Cam, cid), 0, 0},
  {(char *)"SerNo", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, SerNo), 0, 0},
  {(char *)"ID", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, ID), 0, 0},
  {(char *)"Version", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, Version), 0, 0},
  {(char *)"Date", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, Date), 0, 0},
  {(char *)"Select", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, Select), 0, 0},
  {(char *)"SensorID", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, SensorID), 0, 0},
  {(char *)"strSensorName", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, strSensorName), 0, 0},
  {(char *)"nColorMode", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, nColorMode), 0, 0},
  {(char *)"nMaxWidth", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, nMaxWidth), 0, 0},
  {(char *)"nMaxHeight", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, nMaxHeight), 0, 0},
  {(char *)"bMasterGain", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, bMasterGain), 0, 0},
  {(char *)"bRGain", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, bRGain), 0, 0},
  {(char *)"bGGain", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, bGGain), 0, 0},
  {(char *)"bBGain", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, bBGain), 0, 0},
  {(char *)"bGlobShutter", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, bGlobShutter), 0, 0},
  {(char *)"bitspixel", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, bitspixel), 0, 0},
  {(char *)"colormode", T_OBJECT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, colormode), 0, 0},
  {(char *)"LineInc", __Pyx_T_SIGNED_INT(INT), offsetof(struct __pyx_obj_4ueye_4ueye_Cam, LineInc), 0, 0},
  {(char *)"ImgMemId", T_INT, offsetof(struct __pyx_obj_4ueye_4ueye_Cam, ImgMemId), 0, 0},
  {0, 0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_Cam = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION >= 3
  0, /*reserved*/
  #else
  0, /*nb_long*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if (PY_MAJOR_VERSION >= 3) || (Py_TPFLAGS_DEFAULT & Py_TPFLAGS_HAVE_INDEX)
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_Cam = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_Cam = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_Cam = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

PyTypeObject __pyx_type_4ueye_4ueye_Cam = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("ueye.ueye.Cam"), /*tp_name*/
  sizeof(struct __pyx_obj_4ueye_4ueye_Cam), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_4ueye_4ueye_Cam, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  0, /*tp_compare*/
  0, /*tp_repr*/
  &__pyx_tp_as_number_Cam, /*tp_as_number*/
  &__pyx_tp_as_sequence_Cam, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_Cam, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_Cam, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  __Pyx_DOCSTR("Class used to control a uEye camera\n\n    Syntax:\n    =======\n    \n    cam=Cam(cid)\n    \n    Input Parameters:\n    =================\n    \n    cid:\n        Camera id of the cam to be used. If cid is not given, or cid=0, the first\n        available camera is used\n    \n    Return Value:\n    =============\n    \n    cam:\n        Instance to the Cam class assigned to the requested cam.\n    "), /*tp_doc*/
  __pyx_tp_traverse_4ueye_4ueye_Cam, /*tp_traverse*/
  __pyx_tp_clear_4ueye_4ueye_Cam, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_4ueye_4ueye_Cam, /*tp_methods*/
  __pyx_members_4ueye_4ueye_Cam, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pf_4ueye_4ueye_3Cam___init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_4ueye_4ueye_Cam, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  #if PY_VERSION_HEX >= 0x02060000
  0, /*tp_version_tag*/
  #endif
};

static struct PyMethodDef __pyx_methods[] = {
  {__Pyx_NAMESTR("GetNumberOfCameras"), (PyCFunction)__pyx_pf_4ueye_4ueye_GetNumberOfCameras, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_GetNumberOfCameras)},
  {__Pyx_NAMESTR("GetDLLVersion"), (PyCFunction)__pyx_pf_4ueye_4ueye_GetDLLVersion, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_GetDLLVersion)},
  {__Pyx_NAMESTR("bitspixel"), (PyCFunction)__pyx_pf_4ueye_4ueye_bitspixel, METH_O, __Pyx_DOCSTR(__pyx_doc_4ueye_4ueye_bitspixel)},
  {0, 0, 0, 0}
};

static void __pyx_init_filenames(void); /*proto*/

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    __Pyx_NAMESTR("ueye"),
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 0},
  {&__pyx_kp_u_10, __pyx_k_10, sizeof(__pyx_k_10), 0, 1, 0, 0},
  {&__pyx_kp_u_11, __pyx_k_11, sizeof(__pyx_k_11), 0, 1, 0, 0},
  {&__pyx_kp_u_12, __pyx_k_12, sizeof(__pyx_k_12), 0, 1, 0, 0},
  {&__pyx_kp_u_13, __pyx_k_13, sizeof(__pyx_k_13), 0, 1, 0, 0},
  {&__pyx_kp_u_14, __pyx_k_14, sizeof(__pyx_k_14), 0, 1, 0, 0},
  {&__pyx_kp_u_15, __pyx_k_15, sizeof(__pyx_k_15), 0, 1, 0, 0},
  {&__pyx_kp_s_2, __pyx_k_2, sizeof(__pyx_k_2), 0, 0, 1, 0},
  {&__pyx_kp_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 0},
  {&__pyx_kp_s_4, __pyx_k_4, sizeof(__pyx_k_4), 0, 0, 1, 0},
  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
  {&__pyx_kp_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 0},
  {&__pyx_n_s_7, __pyx_k_7, sizeof(__pyx_k_7), 0, 0, 1, 1},
  {&__pyx_kp_s_8, __pyx_k_8, sizeof(__pyx_k_8), 0, 0, 1, 0},
  {&__pyx_kp_s_9, __pyx_k_9, sizeof(__pyx_k_9), 0, 0, 1, 0},
  {&__pyx_n_s__BayerConversionMode, __pyx_k__BayerConversionMode, sizeof(__pyx_k__BayerConversionMode), 0, 0, 1, 1},
  {&__pyx_n_s__CheckNoSuccess, __pyx_k__CheckNoSuccess, sizeof(__pyx_k__CheckNoSuccess), 0, 0, 1, 1},
  {&__pyx_n_s__ChromU, __pyx_k__ChromU, sizeof(__pyx_k__ChromU), 0, 0, 1, 1},
  {&__pyx_n_s__ChromV, __pyx_k__ChromV, sizeof(__pyx_k__ChromV), 0, 0, 1, 1},
  {&__pyx_n_s__ColorCorrection, __pyx_k__ColorCorrection, sizeof(__pyx_k__ColorCorrection), 0, 0, 1, 1},
  {&__pyx_n_s__ColorMode, __pyx_k__ColorMode, sizeof(__pyx_k__ColorMode), 0, 0, 1, 1},
  {&__pyx_n_s__ConvertMode, __pyx_k__ConvertMode, sizeof(__pyx_k__ConvertMode), 0, 0, 1, 1},
  {&__pyx_n_s__Date, __pyx_k__Date, sizeof(__pyx_k__Date), 0, 0, 1, 1},
  {&__pyx_n_s__Exception, __pyx_k__Exception, sizeof(__pyx_k__Exception), 0, 0, 1, 1},
  {&__pyx_n_s__Gamma, __pyx_k__Gamma, sizeof(__pyx_k__Gamma), 0, 0, 1, 1},
  {&__pyx_n_s__ID, __pyx_k__ID, sizeof(__pyx_k__ID), 0, 0, 1, 1},
  {&__pyx_n_s__Img, __pyx_k__Img, sizeof(__pyx_k__Img), 0, 0, 1, 1},
  {&__pyx_n_s__ImgMemId, __pyx_k__ImgMemId, sizeof(__pyx_k__ImgMemId), 0, 0, 1, 1},
  {&__pyx_n_s__LineInc, __pyx_k__LineInc, sizeof(__pyx_k__LineInc), 0, 0, 1, 1},
  {&__pyx_n_s__Param, __pyx_k__Param, sizeof(__pyx_k__Param), 0, 0, 1, 1},
  {&__pyx_n_s__RuntimeError, __pyx_k__RuntimeError, sizeof(__pyx_k__RuntimeError), 0, 0, 1, 1},
  {&__pyx_n_s__Select, __pyx_k__Select, sizeof(__pyx_k__Select), 0, 0, 1, 1},
  {&__pyx_n_s__SensorID, __pyx_k__SensorID, sizeof(__pyx_k__SensorID), 0, 0, 1, 1},
  {&__pyx_n_s__SerNo, __pyx_k__SerNo, sizeof(__pyx_k__SerNo), 0, 0, 1, 1},
  {&__pyx_n_s__SetBlCompensation, __pyx_k__SetBlCompensation, sizeof(__pyx_k__SetBlCompensation), 0, 0, 1, 1},
  {&__pyx_n_s__SetColorMode, __pyx_k__SetColorMode, sizeof(__pyx_k__SetColorMode), 0, 0, 1, 1},
  {&__pyx_n_s__TestImage, __pyx_k__TestImage, sizeof(__pyx_k__TestImage), 0, 0, 1, 1},
  {&__pyx_n_s__Timeout, __pyx_k__Timeout, sizeof(__pyx_k__Timeout), 0, 0, 1, 1},
  {&__pyx_n_s__ValueError, __pyx_k__ValueError, sizeof(__pyx_k__ValueError), 0, 0, 1, 1},
  {&__pyx_n_s__Version, __pyx_k__Version, sizeof(__pyx_k__Version), 0, 0, 1, 1},
  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
  {&__pyx_n_s__bBGain, __pyx_k__bBGain, sizeof(__pyx_k__bBGain), 0, 0, 1, 1},
  {&__pyx_n_s__bGGain, __pyx_k__bGGain, sizeof(__pyx_k__bGGain), 0, 0, 1, 1},
  {&__pyx_n_s__bGlobShutter, __pyx_k__bGlobShutter, sizeof(__pyx_k__bGlobShutter), 0, 0, 1, 1},
  {&__pyx_n_s__bMasterGain, __pyx_k__bMasterGain, sizeof(__pyx_k__bMasterGain), 0, 0, 1, 1},
  {&__pyx_n_s__bRGain, __pyx_k__bRGain, sizeof(__pyx_k__bRGain), 0, 0, 1, 1},
  {&__pyx_n_s__base, __pyx_k__base, sizeof(__pyx_k__base), 0, 0, 1, 1},
  {&__pyx_n_s__bitspixel, __pyx_k__bitspixel, sizeof(__pyx_k__bitspixel), 0, 0, 1, 1},
  {&__pyx_n_s__buf, __pyx_k__buf, sizeof(__pyx_k__buf), 0, 0, 1, 1},
  {&__pyx_n_s__byteorder, __pyx_k__byteorder, sizeof(__pyx_k__byteorder), 0, 0, 1, 1},
  {&__pyx_n_s__cid, __pyx_k__cid, sizeof(__pyx_k__cid), 0, 0, 1, 1},
  {&__pyx_n_s__colormode, __pyx_k__colormode, sizeof(__pyx_k__colormode), 0, 0, 1, 1},
  {&__pyx_n_s__descr, __pyx_k__descr, sizeof(__pyx_k__descr), 0, 0, 1, 1},
  {&__pyx_n_s__effect, __pyx_k__effect, sizeof(__pyx_k__effect), 0, 0, 1, 1},
  {&__pyx_n_s__enumerate, __pyx_k__enumerate, sizeof(__pyx_k__enumerate), 0, 0, 1, 1},
  {&__pyx_n_s__fields, __pyx_k__fields, sizeof(__pyx_k__fields), 0, 0, 1, 1},
  {&__pyx_n_s__format, __pyx_k__format, sizeof(__pyx_k__format), 0, 0, 1, 1},
  {&__pyx_n_s__itemsize, __pyx_k__itemsize, sizeof(__pyx_k__itemsize), 0, 0, 1, 1},
  {&__pyx_n_s__nBlue, __pyx_k__nBlue, sizeof(__pyx_k__nBlue), 0, 0, 1, 1},
  {&__pyx_n_s__nColorMode, __pyx_k__nColorMode, sizeof(__pyx_k__nColorMode), 0, 0, 1, 1},
  {&__pyx_n_s__nEnable, __pyx_k__nEnable, sizeof(__pyx_k__nEnable), 0, 0, 1, 1},
  {&__pyx_n_s__nFactor, __pyx_k__nFactor, sizeof(__pyx_k__nFactor), 0, 0, 1, 1},
  {&__pyx_n_s__nGreen, __pyx_k__nGreen, sizeof(__pyx_k__nGreen), 0, 0, 1, 1},
  {&__pyx_n_s__nInfo, __pyx_k__nInfo, sizeof(__pyx_k__nInfo), 0, 0, 1, 1},
  {&__pyx_n_s__nMaster, __pyx_k__nMaster, sizeof(__pyx_k__nMaster), 0, 0, 1, 1},
  {&__pyx_n_s__nMaxHeight, __pyx_k__nMaxHeight, sizeof(__pyx_k__nMaxHeight), 0, 0, 1, 1},
  {&__pyx_n_s__nMaxWidth, __pyx_k__nMaxWidth, sizeof(__pyx_k__nMaxWidth), 0, 0, 1, 1},
  {&__pyx_n_s__nMode, __pyx_k__nMode, sizeof(__pyx_k__nMode), 0, 0, 1, 1},
  {&__pyx_n_s__nRed, __pyx_k__nRed, sizeof(__pyx_k__nRed), 0, 0, 1, 1},
  {&__pyx_n_s__names, __pyx_k__names, sizeof(__pyx_k__names), 0, 0, 1, 1},
  {&__pyx_n_s__ndim, __pyx_k__ndim, sizeof(__pyx_k__ndim), 0, 0, 1, 1},
  {&__pyx_n_s__npy, __pyx_k__npy, sizeof(__pyx_k__npy), 0, 0, 1, 1},
  {&__pyx_n_s__numpy, __pyx_k__numpy, sizeof(__pyx_k__numpy), 0, 0, 1, 1},
  {&__pyx_n_s__obj, __pyx_k__obj, sizeof(__pyx_k__obj), 0, 0, 1, 1},
  {&__pyx_n_s__offset, __pyx_k__offset, sizeof(__pyx_k__offset), 0, 0, 1, 1},
  {&__pyx_n_s__pHeight, __pyx_k__pHeight, sizeof(__pyx_k__pHeight), 0, 0, 1, 1},
  {&__pyx_n_s__pWidth, __pyx_k__pWidth, sizeof(__pyx_k__pWidth), 0, 0, 1, 1},
  {&__pyx_n_s__pXPos, __pyx_k__pXPos, sizeof(__pyx_k__pXPos), 0, 0, 1, 1},
  {&__pyx_n_s__pYPos, __pyx_k__pYPos, sizeof(__pyx_k__pYPos), 0, 0, 1, 1},
  {&__pyx_n_s__param, __pyx_k__param, sizeof(__pyx_k__param), 0, 0, 1, 1},
  {&__pyx_n_s__pixList, __pyx_k__pixList, sizeof(__pyx_k__pixList), 0, 0, 1, 1},
  {&__pyx_n_s__pval1, __pyx_k__pval1, sizeof(__pyx_k__pval1), 0, 0, 1, 1},
  {&__pyx_n_s__pval2, __pyx_k__pval2, sizeof(__pyx_k__pval2), 0, 0, 1, 1},
  {&__pyx_n_s__range, __pyx_k__range, sizeof(__pyx_k__range), 0, 0, 1, 1},
  {&__pyx_n_s__readonly, __pyx_k__readonly, sizeof(__pyx_k__readonly), 0, 0, 1, 1},
  {&__pyx_n_s__shape, __pyx_k__shape, sizeof(__pyx_k__shape), 0, 0, 1, 1},
  {&__pyx_n_s__strSensorName, __pyx_k__strSensorName, sizeof(__pyx_k__strSensorName), 0, 0, 1, 1},
  {&__pyx_n_s__strides, __pyx_k__strides, sizeof(__pyx_k__strides), 0, 0, 1, 1},
  {&__pyx_n_s__suboffsets, __pyx_k__suboffsets, sizeof(__pyx_k__suboffsets), 0, 0, 1, 1},
  {&__pyx_n_s__threshold, __pyx_k__threshold, sizeof(__pyx_k__threshold), 0, 0, 1, 1},
  {&__pyx_n_s__type, __pyx_k__type, sizeof(__pyx_k__type), 0, 0, 1, 1},
  {&__pyx_n_s__type_num, __pyx_k__type_num, sizeof(__pyx_k__type_num), 0, 0, 1, 1},
  {&__pyx_n_s__ulValue, __pyx_k__ulValue, sizeof(__pyx_k__ulValue), 0, 0, 1, 1},
  {&__pyx_n_s__x, __pyx_k__x, sizeof(__pyx_k__x), 0, 0, 1, 1},
  {&__pyx_n_s__y, __pyx_k__y, sizeof(__pyx_k__y), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_Exception = __Pyx_GetName(__pyx_b, __pyx_n_s__Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_enumerate = __Pyx_GetName(__pyx_b, __pyx_n_s__enumerate); if (!__pyx_builtin_enumerate) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1983; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_range = __Pyx_GetName(__pyx_b, __pyx_n_s__range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_ValueError = __Pyx_GetName(__pyx_b, __pyx_n_s__ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_RuntimeError = __Pyx_GetName(__pyx_b, __pyx_n_s__RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_8 = PyInt_FromLong(8); if (unlikely(!__pyx_int_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_15 = PyInt_FromLong(15); if (unlikely(!__pyx_int_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_16 = PyInt_FromLong(16); if (unlikely(!__pyx_int_16)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_24 = PyInt_FromLong(24); if (unlikely(!__pyx_int_24)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_32 = PyInt_FromLong(32); if (unlikely(!__pyx_int_32)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initueye(void); /*proto*/
PyMODINIT_FUNC initueye(void)
#else
PyMODINIT_FUNC PyInit_ueye(void); /*proto*/
PyMODINIT_FUNC PyInit_ueye(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  #if CYTHON_REFNANNY
  void* __pyx_refnanny = NULL;
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  __pyx_refnanny = __Pyx_RefNanny->SetupContext("PyMODINIT_FUNC PyInit_ueye(void)", __LINE__, __FILE__);
  #endif
  __pyx_init_filenames();
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION < 3
  __pyx_empty_bytes = PyString_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #else
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("ueye"), __pyx_methods, 0, 0, PYTHON_API_VERSION);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  #if PY_MAJOR_VERSION < 3
  Py_INCREF(__pyx_m);
  #endif
  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME));
  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_module_is_main_ueye__ueye) {
    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_4ueye_4ueye_Cam) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_SetAttrString(__pyx_m, "Cam", (PyObject *)&__pyx_type_4ueye_4ueye_Cam) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_4ueye_4ueye_Cam = &__pyx_type_4ueye_4ueye_Cam;
  /*--- Type import code ---*/
  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr), 0); if (unlikely(!__pyx_ptype_5numpy_dtype)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_flatiter)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_broadcast)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject), 0); if (unlikely(!__pyx_ptype_5numpy_ndarray)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType("numpy", "ufunc", sizeof(PyUFuncObject), 0); if (unlikely(!__pyx_ptype_5numpy_ufunc)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "/home/oscar/pyueye/ueye/ueye.pyx":35
 * from stdlib cimport *
 * from python_cobject cimport *
 * import numpy as npy             # <<<<<<<<<<<<<<
 * cimport numpy as npy
 * 
 */
  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__numpy), 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 35; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__npy, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 35; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "/home/oscar/pyueye/ueye/ueye.pyx":131
 *     else: return 8
 * 
 * npy.import_array()             # <<<<<<<<<<<<<<
 * 
 * cdef class Cam:
 */
  import_array();

  /* "/usr/local/lib/python2.6/dist-packages/Cython/Includes/python_cobject.pxd":1
 * from python_ref cimport PyObject             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "Python.h":
 */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  if (__pyx_m) {
    __Pyx_AddTraceback("init ueye.ueye");
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init ueye.ueye");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

static const char *__pyx_filenames[] = {
  "ueye.pyx",
  "numpy.pxd",
};

/* Runtime support code */

static void __pyx_init_filenames(void) {
  __pyx_f = __pyx_filenames;
}

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AS_STRING(kw_name));
        #endif
}

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *number, *more_or_less;

    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    number = (num_expected == 1) ? "" : "s";
    PyErr_Format(PyExc_TypeError,
        #if PY_VERSION_HEX < 0x02050000
            "%s() takes %s %d positional argument%s (%d given)",
        #else
            "%s() takes %s %zd positional argument%s (%zd given)",
        #endif
        func_name, more_or_less, num_expected, number, num_found);
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;

    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
        } else {
            #if PY_MAJOR_VERSION < 3
            if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key))) {
            #else
            if (unlikely(!PyUnicode_CheckExact(key)) && unlikely(!PyUnicode_Check(key))) {
            #endif
                goto invalid_keyword_type;
            } else {
                for (name = first_kw_arg; *name; name++) {
                    #if PY_MAJOR_VERSION >= 3
                    if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
                        PyUnicode_Compare(**name, key) == 0) break;
                    #else
                    if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
                        _PyString_Eq(**name, key)) break;
                    #endif
                }
                if (*name) {
                    values[name-argnames] = value;
                } else {
                    /* unexpected keyword found */
                    for (name=argnames; name != first_kw_arg; name++) {
                        if (**name == key) goto arg_passed_twice;
                        #if PY_MAJOR_VERSION >= 3
                        if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
                            PyUnicode_Compare(**name, key) == 0) goto arg_passed_twice;
                        #else
                        if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
                            _PyString_Eq(**name, key)) goto arg_passed_twice;
                        #endif
                    }
                    if (kwds2) {
                        if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
                    } else {
                        goto invalid_keyword;
                    }
                }
            }
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, **name);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
    long q = a / b;
    long r = a - q*b;
    q -= ((r != 0) & ((r ^ b) < 0));
    return q;
}


static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
        #if PY_VERSION_HEX < 0x02050000
                 "need more than %d value%s to unpack", (int)index,
        #else
                 "need more than %zd value%s to unpack", index,
        #endif
                 (index == 1) ? "" : "s");
}

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(void) {
    PyErr_SetString(PyExc_ValueError, "too many values to unpack");
}

static PyObject *__Pyx_UnpackItem(PyObject *iter, Py_ssize_t index) {
    PyObject *item;
    if (!(item = PyIter_Next(iter))) {
        if (!PyErr_Occurred()) {
            __Pyx_RaiseNeedMoreValuesError(index);
        }
    }
    return item;
}

static int __Pyx_EndUnpack(PyObject *iter) {
    PyObject *item;
    if ((item = PyIter_Next(iter))) {
        Py_DECREF(item);
        __Pyx_RaiseTooManyValuesError();
        return -1;
    }
    else if (!PyErr_Occurred())
        return 0;
    else
        return -1;
}

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
}

static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
    if (t == Py_None) {
      __Pyx_RaiseNoneNotIterableError();
    } else if (PyTuple_GET_SIZE(t) < index) {
      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
    } else {
      __Pyx_RaiseTooManyValuesError();
    }
}

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (!type) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (Py_TYPE(obj) == type) return 1;
    }
    else {
        if (PyObject_TypeCheck(obj, type)) return 1;
    }
    PyErr_Format(PyExc_TypeError,
        "Argument '%s' has incorrect type (expected %s, got %s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
    return 0;
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list) {
    PyObject *__import__ = 0;
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    __import__ = __Pyx_GetAttrString(__pyx_b, "__import__");
    if (!__import__)
        goto bad;
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    module = PyObject_CallFunctionObjArgs(__import__,
        name, global_dict, empty_dict, list, NULL);
bad:
    Py_XDECREF(empty_list);
    Py_XDECREF(__import__);
    Py_XDECREF(empty_dict);
    return module;
}

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_INT(INT val) {
    const INT neg_one = (INT)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(INT) <  sizeof(long)) {
        return PyInt_FromLong((long)val);
    } else if (sizeof(INT) == sizeof(long)) {
        if (is_unsigned)
            return PyLong_FromUnsignedLong((unsigned long)val);
        else
            return PyInt_FromLong((long)val);
    } else { /* (sizeof(INT) > sizeof(long)) */
        if (is_unsigned)
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
        else
            return PyLong_FromLongLong((PY_LONG_LONG)val);
    }
}

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result)
        PyErr_SetObject(PyExc_NameError, name);
    return result;
}

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();

    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}

static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;

    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}


#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
    Py_XINCREF(type);
    Py_XINCREF(value);
    Py_XINCREF(tb);
    /* First, check the traceback argument, replacing None with NULL. */
    if (tb == Py_None) {
        Py_DECREF(tb);
        tb = 0;
    }
    else if (tb != NULL && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto raise_error;
    }
    /* Next, replace a missing value with None */
    if (value == NULL) {
        value = Py_None;
        Py_INCREF(value);
    }
    #if PY_VERSION_HEX < 0x02050000
    if (!PyClass_Check(type))
    #else
    if (!PyType_Check(type))
    #endif
    {
        /* Raising an instance.  The value should be a dummy. */
        if (value != Py_None) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        /* Normalize to raise <class>, <instance> */
        Py_DECREF(value);
        value = type;
        #if PY_VERSION_HEX < 0x02050000
            if (PyInstance_Check(type)) {
                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
                Py_INCREF(type);
            }
            else {
                type = 0;
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception must be an old-style class or instance");
                goto raise_error;
            }
        #else
            type = (PyObject*) Py_TYPE(type);
            Py_INCREF(type);
            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception class must be a subclass of BaseException");
                goto raise_error;
            }
        #endif
    }

    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}

#else /* Python 3+ */

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;

    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (!PyExceptionClass_Check(type)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }

    PyErr_SetObject(type, value);

    if (tb) {
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
    }

bad:
    return;
}
#endif

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_WORD(WORD val) {
    const WORD neg_one = (WORD)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(WORD) <  sizeof(long)) {
        return PyInt_FromLong((long)val);
    } else if (sizeof(WORD) == sizeof(long)) {
        if (is_unsigned)
            return PyLong_FromUnsignedLong((unsigned long)val);
        else
            return PyInt_FromLong((long)val);
    } else { /* (sizeof(WORD) > sizeof(long)) */
        if (is_unsigned)
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
        else
            return PyLong_FromLongLong((PY_LONG_LONG)val);
    }
}

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_DWORD(DWORD val) {
    const DWORD neg_one = (DWORD)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(DWORD) <  sizeof(long)) {
        return PyInt_FromLong((long)val);
    } else if (sizeof(DWORD) == sizeof(long)) {
        if (is_unsigned)
            return PyLong_FromUnsignedLong((unsigned long)val);
        else
            return PyInt_FromLong((long)val);
    } else { /* (sizeof(DWORD) > sizeof(long)) */
        if (is_unsigned)
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
        else
            return PyLong_FromLongLong((PY_LONG_LONG)val);
    }
}

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_BOOL(BOOL val) {
    const BOOL neg_one = (BOOL)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(BOOL) <  sizeof(long)) {
        return PyInt_FromLong((long)val);
    } else if (sizeof(BOOL) == sizeof(long)) {
        if (is_unsigned)
            return PyLong_FromUnsignedLong((unsigned long)val);
        else
            return PyInt_FromLong((long)val);
    } else { /* (sizeof(BOOL) > sizeof(long)) */
        if (is_unsigned)
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
        else
            return PyLong_FromLongLong((PY_LONG_LONG)val);
    }
}

static CYTHON_INLINE npy_intp __Pyx_PyInt_from_py_npy_intp(PyObject* x) {
    const npy_intp neg_one = (npy_intp)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(npy_intp) == sizeof(char)) {
        if (is_unsigned)
            return (npy_intp)__Pyx_PyInt_AsUnsignedChar(x);
        else
            return (npy_intp)__Pyx_PyInt_AsSignedChar(x);
    } else if (sizeof(npy_intp) == sizeof(short)) {
        if (is_unsigned)
            return (npy_intp)__Pyx_PyInt_AsUnsignedShort(x);
        else
            return (npy_intp)__Pyx_PyInt_AsSignedShort(x);
    } else if (sizeof(npy_intp) == sizeof(int)) {
        if (is_unsigned)
            return (npy_intp)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (npy_intp)__Pyx_PyInt_AsSignedInt(x);
    } else if (sizeof(npy_intp) == sizeof(long)) {
        if (is_unsigned)
            return (npy_intp)__Pyx_PyInt_AsUnsignedLong(x);
        else
            return (npy_intp)__Pyx_PyInt_AsSignedLong(x);
    } else if (sizeof(npy_intp) == sizeof(PY_LONG_LONG)) {
        if (is_unsigned)
            return (npy_intp)__Pyx_PyInt_AsUnsignedLongLong(x);
        else
            return (npy_intp)__Pyx_PyInt_AsSignedLongLong(x);
#if 0
    } else if (sizeof(npy_intp) > sizeof(short) &&
               sizeof(npy_intp) < sizeof(int)) { /*  __int32 ILP64 ? */
        if (is_unsigned)
            return (npy_intp)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (npy_intp)__Pyx_PyInt_AsSignedInt(x);
#endif
    }
    PyErr_SetString(PyExc_TypeError, "npy_intp");
    return (npy_intp)-1;
}

static CYTHON_INLINE INT __Pyx_PyInt_from_py_INT(PyObject* x) {
    const INT neg_one = (INT)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(INT) == sizeof(char)) {
        if (is_unsigned)
            return (INT)__Pyx_PyInt_AsUnsignedChar(x);
        else
            return (INT)__Pyx_PyInt_AsSignedChar(x);
    } else if (sizeof(INT) == sizeof(short)) {
        if (is_unsigned)
            return (INT)__Pyx_PyInt_AsUnsignedShort(x);
        else
            return (INT)__Pyx_PyInt_AsSignedShort(x);
    } else if (sizeof(INT) == sizeof(int)) {
        if (is_unsigned)
            return (INT)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (INT)__Pyx_PyInt_AsSignedInt(x);
    } else if (sizeof(INT) == sizeof(long)) {
        if (is_unsigned)
            return (INT)__Pyx_PyInt_AsUnsignedLong(x);
        else
            return (INT)__Pyx_PyInt_AsSignedLong(x);
    } else if (sizeof(INT) == sizeof(PY_LONG_LONG)) {
        if (is_unsigned)
            return (INT)__Pyx_PyInt_AsUnsignedLongLong(x);
        else
            return (INT)__Pyx_PyInt_AsSignedLongLong(x);
#if 0
    } else if (sizeof(INT) > sizeof(short) &&
               sizeof(INT) < sizeof(int)) { /*  __int32 ILP64 ? */
        if (is_unsigned)
            return (INT)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (INT)__Pyx_PyInt_AsSignedInt(x);
#endif
    }
    PyErr_SetString(PyExc_TypeError, "INT");
    return (INT)-1;
}

static CYTHON_INLINE DWORD __Pyx_PyInt_from_py_DWORD(PyObject* x) {
    const DWORD neg_one = (DWORD)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(DWORD) == sizeof(char)) {
        if (is_unsigned)
            return (DWORD)__Pyx_PyInt_AsUnsignedChar(x);
        else
            return (DWORD)__Pyx_PyInt_AsSignedChar(x);
    } else if (sizeof(DWORD) == sizeof(short)) {
        if (is_unsigned)
            return (DWORD)__Pyx_PyInt_AsUnsignedShort(x);
        else
            return (DWORD)__Pyx_PyInt_AsSignedShort(x);
    } else if (sizeof(DWORD) == sizeof(int)) {
        if (is_unsigned)
            return (DWORD)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (DWORD)__Pyx_PyInt_AsSignedInt(x);
    } else if (sizeof(DWORD) == sizeof(long)) {
        if (is_unsigned)
            return (DWORD)__Pyx_PyInt_AsUnsignedLong(x);
        else
            return (DWORD)__Pyx_PyInt_AsSignedLong(x);
    } else if (sizeof(DWORD) == sizeof(PY_LONG_LONG)) {
        if (is_unsigned)
            return (DWORD)__Pyx_PyInt_AsUnsignedLongLong(x);
        else
            return (DWORD)__Pyx_PyInt_AsSignedLongLong(x);
#if 0
    } else if (sizeof(DWORD) > sizeof(short) &&
               sizeof(DWORD) < sizeof(int)) { /*  __int32 ILP64 ? */
        if (is_unsigned)
            return (DWORD)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (DWORD)__Pyx_PyInt_AsSignedInt(x);
#endif
    }
    PyErr_SetString(PyExc_TypeError, "DWORD");
    return (DWORD)-1;
}

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_UINT(UINT val) {
    const UINT neg_one = (UINT)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(UINT) <  sizeof(long)) {
        return PyInt_FromLong((long)val);
    } else if (sizeof(UINT) == sizeof(long)) {
        if (is_unsigned)
            return PyLong_FromUnsignedLong((unsigned long)val);
        else
            return PyInt_FromLong((long)val);
    } else { /* (sizeof(UINT) > sizeof(long)) */
        if (is_unsigned)
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
        else
            return PyLong_FromLongLong((PY_LONG_LONG)val);
    }
}

static CYTHON_INLINE WORD __Pyx_PyInt_from_py_WORD(PyObject* x) {
    const WORD neg_one = (WORD)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(WORD) == sizeof(char)) {
        if (is_unsigned)
            return (WORD)__Pyx_PyInt_AsUnsignedChar(x);
        else
            return (WORD)__Pyx_PyInt_AsSignedChar(x);
    } else if (sizeof(WORD) == sizeof(short)) {
        if (is_unsigned)
            return (WORD)__Pyx_PyInt_AsUnsignedShort(x);
        else
            return (WORD)__Pyx_PyInt_AsSignedShort(x);
    } else if (sizeof(WORD) == sizeof(int)) {
        if (is_unsigned)
            return (WORD)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (WORD)__Pyx_PyInt_AsSignedInt(x);
    } else if (sizeof(WORD) == sizeof(long)) {
        if (is_unsigned)
            return (WORD)__Pyx_PyInt_AsUnsignedLong(x);
        else
            return (WORD)__Pyx_PyInt_AsSignedLong(x);
    } else if (sizeof(WORD) == sizeof(PY_LONG_LONG)) {
        if (is_unsigned)
            return (WORD)__Pyx_PyInt_AsUnsignedLongLong(x);
        else
            return (WORD)__Pyx_PyInt_AsSignedLongLong(x);
#if 0
    } else if (sizeof(WORD) > sizeof(short) &&
               sizeof(WORD) < sizeof(int)) { /*  __int32 ILP64 ? */
        if (is_unsigned)
            return (WORD)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (WORD)__Pyx_PyInt_AsSignedInt(x);
#endif
    }
    PyErr_SetString(PyExc_TypeError, "WORD");
    return (WORD)-1;
}

static CYTHON_INLINE PyObject *__Pyx_PyInt_to_py_ULONG(ULONG val) {
    const ULONG neg_one = (ULONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(ULONG) <  sizeof(long)) {
        return PyInt_FromLong((long)val);
    } else if (sizeof(ULONG) == sizeof(long)) {
        if (is_unsigned)
            return PyLong_FromUnsignedLong((unsigned long)val);
        else
            return PyInt_FromLong((long)val);
    } else { /* (sizeof(ULONG) > sizeof(long)) */
        if (is_unsigned)
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)val);
        else
            return PyLong_FromLongLong((PY_LONG_LONG)val);
    }
}

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      return ::std::complex< float >(x, y);
    }
  #else
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      return x + y*(__pyx_t_float_complex)_Complex_I;
    }
  #endif
#else
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      __pyx_t_float_complex z;
      z.real = x;
      z.imag = y;
      return z;
    }
#endif

#if CYTHON_CCOMPLEX
#else
    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
       return (a.real == b.real) && (a.imag == b.imag);
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real + b.real;
        z.imag = a.imag + b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real - b.real;
        z.imag = a.imag - b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real * b.real - a.imag * b.imag;
        z.imag = a.real * b.imag + a.imag * b.real;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        float denom = b.real * b.real + b.imag * b.imag;
        z.real = (a.real * b.real + a.imag * b.imag) / denom;
        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex a) {
        __pyx_t_float_complex z;
        z.real = -a.real;
        z.imag = -a.imag;
        return z;
    }
    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex a) {
       return (a.real == 0) && (a.imag == 0);
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex a) {
        __pyx_t_float_complex z;
        z.real =  a.real;
        z.imag = -a.imag;
        return z;
    }
/*
    static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex z) {
#if HAVE_HYPOT
        return hypotf(z.real, z.imag);
#else
        return sqrtf(z.real*z.real + z.imag*z.imag);
#endif
    }
*/
#endif

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      return ::std::complex< double >(x, y);
    }
  #else
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      return x + y*(__pyx_t_double_complex)_Complex_I;
    }
  #endif
#else
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      __pyx_t_double_complex z;
      z.real = x;
      z.imag = y;
      return z;
    }
#endif

#if CYTHON_CCOMPLEX
#else
    static CYTHON_INLINE int __Pyx_c_eq(__pyx_t_double_complex a, __pyx_t_double_complex b) {
       return (a.real == b.real) && (a.imag == b.imag);
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real + b.real;
        z.imag = a.imag + b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_diff(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real - b.real;
        z.imag = a.imag - b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_prod(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real * b.real - a.imag * b.imag;
        z.imag = a.real * b.imag + a.imag * b.real;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        double denom = b.real * b.real + b.imag * b.imag;
        z.real = (a.real * b.real + a.imag * b.imag) / denom;
        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_neg(__pyx_t_double_complex a) {
        __pyx_t_double_complex z;
        z.real = -a.real;
        z.imag = -a.imag;
        return z;
    }
    static CYTHON_INLINE int __Pyx_c_is_zero(__pyx_t_double_complex a) {
       return (a.real == 0) && (a.imag == 0);
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj(__pyx_t_double_complex a) {
        __pyx_t_double_complex z;
        z.real =  a.real;
        z.imag = -a.imag;
        return z;
    }
/*
    static CYTHON_INLINE double __Pyx_c_abs(__pyx_t_double_complex z) {
#if HAVE_HYPOT
        return hypot(z.real, z.imag);
#else
        return sqrt(z.real*z.real + z.imag*z.imag);
#endif
    }
*/
#endif

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned char" :
                    "value too large to convert to unsigned char");
            }
            return (unsigned char)-1;
        }
        return (unsigned char)val;
    }
    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned short" :
                    "value too large to convert to unsigned short");
            }
            return (unsigned short)-1;
        }
        return (unsigned short)val;
    }
    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned int" :
                    "value too large to convert to unsigned int");
            }
            return (unsigned int)-1;
        }
        return (unsigned int)val;
    }
    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
    const char neg_one = (char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to char" :
                    "value too large to convert to char");
            }
            return (char)-1;
        }
        return (char)val;
    }
    return (char)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
    const short neg_one = (short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to short" :
                    "value too large to convert to short");
            }
            return (short)-1;
        }
        return (short)val;
    }
    return (short)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
    const signed char neg_one = (signed char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed char" :
                    "value too large to convert to signed char");
            }
            return (signed char)-1;
        }
        return (signed char)val;
    }
    return (signed char)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
    const signed short neg_one = (signed short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed short" :
                    "value too large to convert to signed short");
            }
            return (signed short)-1;
        }
        return (signed short)val;
    }
    return (signed short)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
    const signed int neg_one = (signed int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed int" :
                    "value too large to convert to signed int");
            }
            return (signed int)-1;
        }
        return (signed int)val;
    }
    return (signed int)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned long");
            return (unsigned long)-1;
        }
        return (unsigned long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned long");
                return (unsigned long)-1;
            }
            return PyLong_AsUnsignedLong(x);
        } else {
            return PyLong_AsLong(x);
        }
    } else {
        unsigned long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned long)-1;
        val = __Pyx_PyInt_AsUnsignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned PY_LONG_LONG");
            return (unsigned PY_LONG_LONG)-1;
        }
        return (unsigned PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned PY_LONG_LONG");
                return (unsigned PY_LONG_LONG)-1;
            }
            return PyLong_AsUnsignedLongLong(x);
        } else {
            return PyLong_AsLongLong(x);
        }
    } else {
        unsigned PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
    const long neg_one = (long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to long");
            return (long)-1;
        }
        return (long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to long");
                return (long)-1;
            }
            return PyLong_AsUnsignedLong(x);
        } else {
            return PyLong_AsLong(x);
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long)-1;
        val = __Pyx_PyInt_AsLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to PY_LONG_LONG");
            return (PY_LONG_LONG)-1;
        }
        return (PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to PY_LONG_LONG");
                return (PY_LONG_LONG)-1;
            }
            return PyLong_AsUnsignedLongLong(x);
        } else {
            return PyLong_AsLongLong(x);
        }
    } else {
        PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
    const signed long neg_one = (signed long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed long");
            return (signed long)-1;
        }
        return (signed long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed long");
                return (signed long)-1;
            }
            return PyLong_AsUnsignedLong(x);
        } else {
            return PyLong_AsLong(x);
        }
    } else {
        signed long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed long)-1;
        val = __Pyx_PyInt_AsSignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed PY_LONG_LONG");
            return (signed PY_LONG_LONG)-1;
        }
        return (signed PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed PY_LONG_LONG");
                return (signed PY_LONG_LONG)-1;
            }
            return PyLong_AsUnsignedLongLong(x);
        } else {
            return PyLong_AsLongLong(x);
        }
    } else {
        signed PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsSignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE UINT __Pyx_PyInt_from_py_UINT(PyObject* x) {
    const UINT neg_one = (UINT)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(UINT) == sizeof(char)) {
        if (is_unsigned)
            return (UINT)__Pyx_PyInt_AsUnsignedChar(x);
        else
            return (UINT)__Pyx_PyInt_AsSignedChar(x);
    } else if (sizeof(UINT) == sizeof(short)) {
        if (is_unsigned)
            return (UINT)__Pyx_PyInt_AsUnsignedShort(x);
        else
            return (UINT)__Pyx_PyInt_AsSignedShort(x);
    } else if (sizeof(UINT) == sizeof(int)) {
        if (is_unsigned)
            return (UINT)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (UINT)__Pyx_PyInt_AsSignedInt(x);
    } else if (sizeof(UINT) == sizeof(long)) {
        if (is_unsigned)
            return (UINT)__Pyx_PyInt_AsUnsignedLong(x);
        else
            return (UINT)__Pyx_PyInt_AsSignedLong(x);
    } else if (sizeof(UINT) == sizeof(PY_LONG_LONG)) {
        if (is_unsigned)
            return (UINT)__Pyx_PyInt_AsUnsignedLongLong(x);
        else
            return (UINT)__Pyx_PyInt_AsSignedLongLong(x);
#if 0
    } else if (sizeof(UINT) > sizeof(short) &&
               sizeof(UINT) < sizeof(int)) { /*  __int32 ILP64 ? */
        if (is_unsigned)
            return (UINT)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (UINT)__Pyx_PyInt_AsSignedInt(x);
#endif
    }
    PyErr_SetString(PyExc_TypeError, "UINT");
    return (UINT)-1;
}

static CYTHON_INLINE BOOL __Pyx_PyInt_from_py_BOOL(PyObject* x) {
    const BOOL neg_one = (BOOL)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(BOOL) == sizeof(char)) {
        if (is_unsigned)
            return (BOOL)__Pyx_PyInt_AsUnsignedChar(x);
        else
            return (BOOL)__Pyx_PyInt_AsSignedChar(x);
    } else if (sizeof(BOOL) == sizeof(short)) {
        if (is_unsigned)
            return (BOOL)__Pyx_PyInt_AsUnsignedShort(x);
        else
            return (BOOL)__Pyx_PyInt_AsSignedShort(x);
    } else if (sizeof(BOOL) == sizeof(int)) {
        if (is_unsigned)
            return (BOOL)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (BOOL)__Pyx_PyInt_AsSignedInt(x);
    } else if (sizeof(BOOL) == sizeof(long)) {
        if (is_unsigned)
            return (BOOL)__Pyx_PyInt_AsUnsignedLong(x);
        else
            return (BOOL)__Pyx_PyInt_AsSignedLong(x);
    } else if (sizeof(BOOL) == sizeof(PY_LONG_LONG)) {
        if (is_unsigned)
            return (BOOL)__Pyx_PyInt_AsUnsignedLongLong(x);
        else
            return (BOOL)__Pyx_PyInt_AsSignedLongLong(x);
#if 0
    } else if (sizeof(BOOL) > sizeof(short) &&
               sizeof(BOOL) < sizeof(int)) { /*  __int32 ILP64 ? */
        if (is_unsigned)
            return (BOOL)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (BOOL)__Pyx_PyInt_AsSignedInt(x);
#endif
    }
    PyErr_SetString(PyExc_TypeError, "BOOL");
    return (BOOL)-1;
}

static CYTHON_INLINE ULONG __Pyx_PyInt_from_py_ULONG(PyObject* x) {
    const ULONG neg_one = (ULONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(ULONG) == sizeof(char)) {
        if (is_unsigned)
            return (ULONG)__Pyx_PyInt_AsUnsignedChar(x);
        else
            return (ULONG)__Pyx_PyInt_AsSignedChar(x);
    } else if (sizeof(ULONG) == sizeof(short)) {
        if (is_unsigned)
            return (ULONG)__Pyx_PyInt_AsUnsignedShort(x);
        else
            return (ULONG)__Pyx_PyInt_AsSignedShort(x);
    } else if (sizeof(ULONG) == sizeof(int)) {
        if (is_unsigned)
            return (ULONG)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (ULONG)__Pyx_PyInt_AsSignedInt(x);
    } else if (sizeof(ULONG) == sizeof(long)) {
        if (is_unsigned)
            return (ULONG)__Pyx_PyInt_AsUnsignedLong(x);
        else
            return (ULONG)__Pyx_PyInt_AsSignedLong(x);
    } else if (sizeof(ULONG) == sizeof(PY_LONG_LONG)) {
        if (is_unsigned)
            return (ULONG)__Pyx_PyInt_AsUnsignedLongLong(x);
        else
            return (ULONG)__Pyx_PyInt_AsSignedLongLong(x);
#if 0
    } else if (sizeof(ULONG) > sizeof(short) &&
               sizeof(ULONG) < sizeof(int)) { /*  __int32 ILP64 ? */
        if (is_unsigned)
            return (ULONG)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (ULONG)__Pyx_PyInt_AsSignedInt(x);
#endif
    }
    PyErr_SetString(PyExc_TypeError, "ULONG");
    return (ULONG)-1;
}

#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
    long size, int strict)
{
    PyObject *py_module = 0;
    PyObject *result = 0;
    PyObject *py_name = 0;
    char warning[200];

    py_module = __Pyx_ImportModule(module_name);
    if (!py_module)
        goto bad;
    #if PY_MAJOR_VERSION < 3
    py_name = PyString_FromString(class_name);
    #else
    py_name = PyUnicode_FromString(class_name);
    #endif
    if (!py_name)
        goto bad;
    result = PyObject_GetAttr(py_module, py_name);
    Py_DECREF(py_name);
    py_name = 0;
    Py_DECREF(py_module);
    py_module = 0;
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError, 
            "%s.%s is not a type object",
            module_name, class_name);
        goto bad;
    }
    if (!strict && ((PyTypeObject *)result)->tp_basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning), 
            "%s.%s size changed, may indicate binary incompatibility",
            module_name, class_name);
        PyErr_WarnEx(NULL, warning, 0);
    }
    else if (((PyTypeObject *)result)->tp_basicsize != size) {
        PyErr_Format(PyExc_ValueError, 
            "%s.%s has the wrong size, try recompiling",
            module_name, class_name);
        goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(py_module);
    Py_XDECREF(result);
    return 0;
}
#endif

#ifndef __PYX_HAVE_RT_ImportModule
#define __PYX_HAVE_RT_ImportModule
static PyObject *__Pyx_ImportModule(const char *name) {
    PyObject *py_name = 0;
    PyObject *py_module = 0;

    #if PY_MAJOR_VERSION < 3
    py_name = PyString_FromString(name);
    #else
    py_name = PyUnicode_FromString(name);
    #endif
    if (!py_name)
        goto bad;
    py_module = PyImport_Import(py_name);
    Py_DECREF(py_name);
    return py_module;
bad:
    Py_XDECREF(py_name);
    return 0;
}
#endif

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"

static void __Pyx_AddTraceback(const char *funcname) {
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    PyObject *py_globals = 0;
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;

    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(__pyx_filename);
    #else
    py_srcfile = PyUnicode_FromString(__pyx_filename);
    #endif
    if (!py_srcfile) goto bad;
    if (__pyx_clineno) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    py_code = PyCode_New(
        0,            /*int argcount,*/
        #if PY_MAJOR_VERSION >= 3
        0,            /*int kwonlyargcount,*/
        #endif
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple,  /*PyObject *consts,*/
        __pyx_empty_tuple,  /*PyObject *names,*/
        __pyx_empty_tuple,  /*PyObject *varnames,*/
        __pyx_empty_tuple,  /*PyObject *freevars,*/
        __pyx_empty_tuple,  /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        __pyx_lineno,   /*int firstlineno,*/
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    if (!py_code) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = __pyx_lineno;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else  /* Python 3+ has unicode identifiers */
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

/* Type Conversion Functions */

static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   if (x == Py_True) return 1;
   else if ((x == Py_False) | (x == Py_None)) return 0;
   else return PyObject_IsTrue(x);
}

static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_VERSION_HEX < 0x03000000
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_VERSION_HEX < 0x03000000
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%s__ returned non-%s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}

static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}

static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
#if PY_VERSION_HEX < 0x02050000
   if (ival <= LONG_MAX)
       return PyInt_FromLong((long)ival);
   else {
       unsigned char *bytes = (unsigned char *) &ival;
       int one = 1; int little = (int)*(unsigned char*)&one;
       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
   }
#else
   return PyInt_FromSize_t(ival);
#endif
}

static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
   if (unlikely(val == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())) {
       return (size_t)-1;
   } else if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
       PyErr_SetString(PyExc_OverflowError,
                       "value too large to convert to size_t");
       return (size_t)-1;
   }
   return (size_t)val;
}


#endif /* Py_PYTHON_H */
